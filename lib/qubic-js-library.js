(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd)
    define("qli", [], factory);
  else if (typeof exports === 'object')
    exports["qli"] = factory();
  else
    root["qli"] = factory();
})(self, () => {
  return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/bignumber.js/bignumber.js":
/*!************************************************!*\
  !*** ./node_modules/bignumber.js/bignumber.js ***!
  \************************************************/
/***/ (function (module, exports, __webpack_require__) {

          var __WEBPACK_AMD_DEFINE_RESULT__;; (function (globalObject) {
            'use strict';

            /*
             *      bignumber.js v9.1.2
             *      A JavaScript library for arbitrary-precision arithmetic.
             *      https://github.com/MikeMcl/bignumber.js
             *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
             *      MIT Licensed.
             *
             *      BigNumber.prototype methods     |  BigNumber methods
             *                                      |
             *      absoluteValue            abs    |  clone
             *      comparedTo                      |  config               set
             *      decimalPlaces            dp     |      DECIMAL_PLACES
             *      dividedBy                div    |      ROUNDING_MODE
             *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
             *      exponentiatedBy          pow    |      RANGE
             *      integerValue                    |      CRYPTO
             *      isEqualTo                eq     |      MODULO_MODE
             *      isFinite                        |      POW_PRECISION
             *      isGreaterThan            gt     |      FORMAT
             *      isGreaterThanOrEqualTo   gte    |      ALPHABET
             *      isInteger                       |  isBigNumber
             *      isLessThan               lt     |  maximum              max
             *      isLessThanOrEqualTo      lte    |  minimum              min
             *      isNaN                           |  random
             *      isNegative                      |  sum
             *      isPositive                      |
             *      isZero                          |
             *      minus                           |
             *      modulo                   mod    |
             *      multipliedBy             times  |
             *      negated                         |
             *      plus                            |
             *      precision                sd     |
             *      shiftedBy                       |
             *      squareRoot               sqrt   |
             *      toExponential                   |
             *      toFixed                         |
             *      toFormat                        |
             *      toFraction                      |
             *      toJSON                          |
             *      toNumber                        |
             *      toPrecision                     |
             *      toString                        |
             *      valueOf                         |
             *
             */


            var BigNumber,
              isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
              mathceil = Math.ceil,
              mathfloor = Math.floor,

              bignumberError = '[BigNumber Error] ',
              tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

              BASE = 1e14,
              LOG_BASE = 14,
              MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
              // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
              POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
              SQRT_BASE = 1e7,

              // EDITABLE
              // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
              // the arguments to toExponential, toFixed, toFormat, and toPrecision.
              MAX = 1E9;                                   // 0 to MAX_INT32


            /*
             * Create and return a BigNumber constructor.
             */
            function clone(configObject) {
              var div, convertBase, parseNumeric,
                P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
                ONE = new BigNumber(1),


                //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


                // The default values below must be integers within the inclusive ranges stated.
                // The values can also be changed at run-time using BigNumber.set.

                // The maximum number of decimal places for operations involving division.
                DECIMAL_PLACES = 20,                     // 0 to MAX

                // The rounding mode used when rounding to the above decimal places, and when using
                // toExponential, toFixed, toFormat and toPrecision, and round (default value).
                // UP         0 Away from zero.
                // DOWN       1 Towards zero.
                // CEIL       2 Towards +Infinity.
                // FLOOR      3 Towards -Infinity.
                // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
                // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
                // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
                // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
                // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
                ROUNDING_MODE = 4,                       // 0 to 8

                // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

                // The exponent value at and beneath which toString returns exponential notation.
                // Number type: -7
                TO_EXP_NEG = -7,                         // 0 to -MAX

                // The exponent value at and above which toString returns exponential notation.
                // Number type: 21
                TO_EXP_POS = 21,                         // 0 to MAX

                // RANGE : [MIN_EXP, MAX_EXP]

                // The minimum exponent value, beneath which underflow to zero occurs.
                // Number type: -324  (5e-324)
                MIN_EXP = -1e7,                          // -1 to -MAX

                // The maximum exponent value, above which overflow to Infinity occurs.
                // Number type:  308  (1.7976931348623157e+308)
                // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
                MAX_EXP = 1e7,                           // 1 to MAX

                // Whether to use cryptographically-secure random number generation, if available.
                CRYPTO = false,                          // true or false

                // The modulo mode used when calculating the modulus: a mod n.
                // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
                // The remainder (r) is calculated as: r = a - n * q.
                //
                // UP        0 The remainder is positive if the dividend is negative, else is negative.
                // DOWN      1 The remainder has the same sign as the dividend.
                //             This modulo mode is commonly known as 'truncated division' and is
                //             equivalent to (a % n) in JavaScript.
                // FLOOR     3 The remainder has the same sign as the divisor (Python %).
                // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
                // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
                //             The remainder is always positive.
                //
                // The truncated division, floored division, Euclidian division and IEEE 754 remainder
                // modes are commonly used for the modulus operation.
                // Although the other rounding modes can also be used, they may not give useful results.
                MODULO_MODE = 1,                         // 0 to 9

                // The maximum number of significant digits of the result of the exponentiatedBy operation.
                // If POW_PRECISION is 0, there will be unlimited significant digits.
                POW_PRECISION = 0,                       // 0 to MAX

                // The format specification used by the BigNumber.prototype.toFormat method.
                FORMAT = {
                  prefix: '',
                  groupSize: 3,
                  secondaryGroupSize: 0,
                  groupSeparator: ',',
                  decimalSeparator: '.',
                  fractionGroupSize: 0,
                  fractionGroupSeparator: '\xA0',        // non-breaking space
                  suffix: ''
                },

                // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
                // '-', '.', whitespace, or repeated character.
                // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
                ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
                alphabetHasNormalDecimalDigits = true;


              //------------------------------------------------------------------------------------------


              // CONSTRUCTOR


              /*
               * The BigNumber constructor and exported function.
               * Create and return a new instance of a BigNumber object.
               *
               * v {number|string|BigNumber} A numeric value.
               * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
               */
              function BigNumber(v, b) {
                var alphabet, c, caseChanged, e, i, isNum, len, str,
                  x = this;

                // Enable constructor call without `new`.
                if (!(x instanceof BigNumber)) return new BigNumber(v, b);

                if (b == null) {

                  if (v && v._isBigNumber === true) {
                    x.s = v.s;

                    if (!v.c || v.e > MAX_EXP) {
                      x.c = x.e = null;
                    } else if (v.e < MIN_EXP) {
                      x.c = [x.e = 0];
                    } else {
                      x.e = v.e;
                      x.c = v.c.slice();
                    }

                    return;
                  }

                  if ((isNum = typeof v == 'number') && v * 0 == 0) {

                    // Use `1 / n` to handle minus zero also.
                    x.s = 1 / v < 0 ? (v = -v, -1) : 1;

                    // Fast path for integers, where n < 2147483648 (2**31).
                    if (v === ~~v) {
                      for (e = 0, i = v; i >= 10; i /= 10, e++);

                      if (e > MAX_EXP) {
                        x.c = x.e = null;
                      } else {
                        x.e = e;
                        x.c = [v];
                      }

                      return;
                    }

                    str = String(v);
                  } else {

                    if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

                    x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
                  }

                  // Decimal point?
                  if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

                  // Exponential form?
                  if ((i = str.search(/e/i)) > 0) {

                    // Determine exponent.
                    if (e < 0) e = i;
                    e += +str.slice(i + 1);
                    str = str.substring(0, i);
                  } else if (e < 0) {

                    // Integer.
                    e = str.length;
                  }

                } else {

                  // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
                  intCheck(b, 2, ALPHABET.length, 'Base');

                  // Allow exponential notation to be used with base 10 argument, while
                  // also rounding to DECIMAL_PLACES as with other bases.
                  if (b == 10 && alphabetHasNormalDecimalDigits) {
                    x = new BigNumber(v);
                    return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
                  }

                  str = String(v);

                  if (isNum = typeof v == 'number') {

                    // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                    if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

                    x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

                    // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                    if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
                      throw Error
                        (tooManyDigits + v);
                    }
                  } else {
                    x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
                  }

                  alphabet = ALPHABET.slice(0, b);
                  e = i = 0;

                  // Check that str is a valid base b number.
                  // Don't use RegExp, so alphabet can contain special characters.
                  for (len = str.length; i < len; i++) {
                    if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                      if (c == '.') {

                        // If '.' is not the first character and it has not be found before.
                        if (i > e) {
                          e = len;
                          continue;
                        }
                      } else if (!caseChanged) {

                        // Allow e.g. hexadecimal 'FF' as well as 'ff'.
                        if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                          str == str.toLowerCase() && (str = str.toUpperCase())) {
                          caseChanged = true;
                          i = -1;
                          e = 0;
                          continue;
                        }
                      }

                      return parseNumeric(x, String(v), isNum, b);
                    }
                  }

                  // Prevent later check for length on converted number.
                  isNum = false;
                  str = convertBase(str, b, 10, x.s);

                  // Decimal point?
                  if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
                  else e = str.length;
                }

                // Determine leading zeros.
                for (i = 0; str.charCodeAt(i) === 48; i++);

                // Determine trailing zeros.
                for (len = str.length; str.charCodeAt(--len) === 48;);

                if (str = str.slice(i, ++len)) {
                  len -= i;

                  // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
                  if (isNum && BigNumber.DEBUG &&
                    len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
                    throw Error
                      (tooManyDigits + (x.s * v));
                  }

                  // Overflow?
                  if ((e = e - i - 1) > MAX_EXP) {

                    // Infinity.
                    x.c = x.e = null;

                    // Underflow?
                  } else if (e < MIN_EXP) {

                    // Zero.
                    x.c = [x.e = 0];
                  } else {
                    x.e = e;
                    x.c = [];

                    // Transform base

                    // e is the base 10 exponent.
                    // i is where to slice str to get the first element of the coefficient array.
                    i = (e + 1) % LOG_BASE;
                    if (e < 0) i += LOG_BASE;  // i < 1

                    if (i < len) {
                      if (i) x.c.push(+str.slice(0, i));

                      for (len -= LOG_BASE; i < len;) {
                        x.c.push(+str.slice(i, i += LOG_BASE));
                      }

                      i = LOG_BASE - (str = str.slice(i)).length;
                    } else {
                      i -= len;
                    }

                    for (; i--; str += '0');
                    x.c.push(+str);
                  }
                } else {

                  // Zero.
                  x.c = [x.e = 0];
                }
              }


              // CONSTRUCTOR PROPERTIES


              BigNumber.clone = clone;

              BigNumber.ROUND_UP = 0;
              BigNumber.ROUND_DOWN = 1;
              BigNumber.ROUND_CEIL = 2;
              BigNumber.ROUND_FLOOR = 3;
              BigNumber.ROUND_HALF_UP = 4;
              BigNumber.ROUND_HALF_DOWN = 5;
              BigNumber.ROUND_HALF_EVEN = 6;
              BigNumber.ROUND_HALF_CEIL = 7;
              BigNumber.ROUND_HALF_FLOOR = 8;
              BigNumber.EUCLID = 9;


              /*
               * Configure infrequently-changing library-wide settings.
               *
               * Accept an object with the following optional properties (if the value of a property is
               * a number, it must be an integer within the inclusive range stated):
               *
               *   DECIMAL_PLACES   {number}           0 to MAX
               *   ROUNDING_MODE    {number}           0 to 8
               *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
               *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
               *   CRYPTO           {boolean}          true or false
               *   MODULO_MODE      {number}           0 to 9
               *   POW_PRECISION       {number}           0 to MAX
               *   ALPHABET         {string}           A string of two or more unique characters which does
               *                                       not contain '.'.
               *   FORMAT           {object}           An object with some of the following properties:
               *     prefix                 {string}
               *     groupSize              {number}
               *     secondaryGroupSize     {number}
               *     groupSeparator         {string}
               *     decimalSeparator       {string}
               *     fractionGroupSize      {number}
               *     fractionGroupSeparator {string}
               *     suffix                 {string}
               *
               * (The values assigned to the above FORMAT object properties are not checked for validity.)
               *
               * E.g.
               * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
               *
               * Ignore properties/parameters set to null or undefined, except for ALPHABET.
               *
               * Return an object with the properties current values.
               */
              BigNumber.config = BigNumber.set = function (obj) {
                var p, v;

                if (obj != null) {

                  if (typeof obj == 'object') {

                    // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
                    // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
                      v = obj[p];
                      intCheck(v, 0, MAX, p);
                      DECIMAL_PLACES = v;
                    }

                    // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
                    // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
                      v = obj[p];
                      intCheck(v, 0, 8, p);
                      ROUNDING_MODE = v;
                    }

                    // EXPONENTIAL_AT {number|number[]}
                    // Integer, -MAX to MAX inclusive or
                    // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
                    // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
                      v = obj[p];
                      if (v && v.pop) {
                        intCheck(v[0], -MAX, 0, p);
                        intCheck(v[1], 0, MAX, p);
                        TO_EXP_NEG = v[0];
                        TO_EXP_POS = v[1];
                      } else {
                        intCheck(v, -MAX, MAX, p);
                        TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                      }
                    }

                    // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
                    // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
                    // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
                    if (obj.hasOwnProperty(p = 'RANGE')) {
                      v = obj[p];
                      if (v && v.pop) {
                        intCheck(v[0], -MAX, -1, p);
                        intCheck(v[1], 1, MAX, p);
                        MIN_EXP = v[0];
                        MAX_EXP = v[1];
                      } else {
                        intCheck(v, -MAX, MAX, p);
                        if (v) {
                          MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                        } else {
                          throw Error
                            (bignumberError + p + ' cannot be zero: ' + v);
                        }
                      }
                    }

                    // CRYPTO {boolean} true or false.
                    // '[BigNumber Error] CRYPTO not true or false: {v}'
                    // '[BigNumber Error] crypto unavailable'
                    if (obj.hasOwnProperty(p = 'CRYPTO')) {
                      v = obj[p];
                      if (v === !!v) {
                        if (v) {
                          if (typeof crypto != 'undefined' && crypto &&
                            (crypto.getRandomValues || crypto.randomBytes)) {
                            CRYPTO = v;
                          } else {
                            CRYPTO = !v;
                            throw Error
                              (bignumberError + 'crypto unavailable');
                          }
                        } else {
                          CRYPTO = v;
                        }
                      } else {
                        throw Error
                          (bignumberError + p + ' not true or false: ' + v);
                      }
                    }

                    // MODULO_MODE {number} Integer, 0 to 9 inclusive.
                    // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
                      v = obj[p];
                      intCheck(v, 0, 9, p);
                      MODULO_MODE = v;
                    }

                    // POW_PRECISION {number} Integer, 0 to MAX inclusive.
                    // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
                    if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
                      v = obj[p];
                      intCheck(v, 0, MAX, p);
                      POW_PRECISION = v;
                    }

                    // FORMAT {object}
                    // '[BigNumber Error] FORMAT not an object: {v}'
                    if (obj.hasOwnProperty(p = 'FORMAT')) {
                      v = obj[p];
                      if (typeof v == 'object') FORMAT = v;
                      else throw Error
                        (bignumberError + p + ' not an object: ' + v);
                    }

                    // ALPHABET {string}
                    // '[BigNumber Error] ALPHABET invalid: {v}'
                    if (obj.hasOwnProperty(p = 'ALPHABET')) {
                      v = obj[p];

                      // Disallow if less than two characters,
                      // or if it contains '+', '-', '.', whitespace, or a repeated character.
                      if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                        alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
                        ALPHABET = v;
                      } else {
                        throw Error
                          (bignumberError + p + ' invalid: ' + v);
                      }
                    }

                  } else {

                    // '[BigNumber Error] Object expected: {v}'
                    throw Error
                      (bignumberError + 'Object expected: ' + obj);
                  }
                }

                return {
                  DECIMAL_PLACES: DECIMAL_PLACES,
                  ROUNDING_MODE: ROUNDING_MODE,
                  EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
                  RANGE: [MIN_EXP, MAX_EXP],
                  CRYPTO: CRYPTO,
                  MODULO_MODE: MODULO_MODE,
                  POW_PRECISION: POW_PRECISION,
                  FORMAT: FORMAT,
                  ALPHABET: ALPHABET
                };
              };


              /*
               * Return true if v is a BigNumber instance, otherwise return false.
               *
               * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
               *
               * v {any}
               *
               * '[BigNumber Error] Invalid BigNumber: {v}'
               */
              BigNumber.isBigNumber = function (v) {
                if (!v || v._isBigNumber !== true) return false;
                if (!BigNumber.DEBUG) return true;

                var i, n,
                  c = v.c,
                  e = v.e,
                  s = v.s;

                out: if ({}.toString.call(c) == '[object Array]') {

                  if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

                    // If the first element is zero, the BigNumber value must be zero.
                    if (c[0] === 0) {
                      if (e === 0 && c.length === 1) return true;
                      break out;
                    }

                    // Calculate number of digits that c[0] should have, based on the exponent.
                    i = (e + 1) % LOG_BASE;
                    if (i < 1) i += LOG_BASE;

                    // Calculate number of digits of c[0].
                    //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
                    if (String(c[0]).length == i) {

                      for (i = 0; i < c.length; i++) {
                        n = c[i];
                        if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                      }

                      // Last element cannot be zero, unless it is the only element.
                      if (n !== 0) return true;
                    }
                  }

                  // Infinity/NaN
                } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
                  return true;
                }

                throw Error
                  (bignumberError + 'Invalid BigNumber: ' + v);
              };


              /*
               * Return a new BigNumber whose value is the maximum of the arguments.
               *
               * arguments {number|string|BigNumber}
               */
              BigNumber.maximum = BigNumber.max = function () {
                return maxOrMin(arguments, -1);
              };


              /*
               * Return a new BigNumber whose value is the minimum of the arguments.
               *
               * arguments {number|string|BigNumber}
               */
              BigNumber.minimum = BigNumber.min = function () {
                return maxOrMin(arguments, 1);
              };


              /*
               * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
               * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
               * zeros are produced).
               *
               * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
               * '[BigNumber Error] crypto unavailable'
               */
              BigNumber.random = (function () {
                var pow2_53 = 0x20000000000000;

                // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
                // Check if Math.random() produces more than 32 bits of randomness.
                // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
                // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
                var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
                  ? function () { return mathfloor(Math.random() * pow2_53); }
                  : function () {
                    return ((Math.random() * 0x40000000 | 0) * 0x800000) +
                      (Math.random() * 0x800000 | 0);
                  };

                return function (dp) {
                  var a, b, e, k, v,
                    i = 0,
                    c = [],
                    rand = new BigNumber(ONE);

                  if (dp == null) dp = DECIMAL_PLACES;
                  else intCheck(dp, 0, MAX);

                  k = mathceil(dp / LOG_BASE);

                  if (CRYPTO) {

                    // Browsers supporting crypto.getRandomValues.
                    if (crypto.getRandomValues) {

                      a = crypto.getRandomValues(new Uint32Array(k *= 2));

                      for (; i < k;) {

                        // 53 bits:
                        // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                        // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                        // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                        //                                     11111 11111111 11111111
                        // 0x20000 is 2^21.
                        v = a[i] * 0x20000 + (a[i + 1] >>> 11);

                        // Rejection sampling:
                        // 0 <= v < 9007199254740992
                        // Probability that v >= 9e15, is
                        // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                        if (v >= 9e15) {
                          b = crypto.getRandomValues(new Uint32Array(2));
                          a[i] = b[0];
                          a[i + 1] = b[1];
                        } else {

                          // 0 <= v <= 8999999999999999
                          // 0 <= (v % 1e14) <= 99999999999999
                          c.push(v % 1e14);
                          i += 2;
                        }
                      }
                      i = k / 2;

                      // Node.js supporting crypto.randomBytes.
                    } else if (crypto.randomBytes) {

                      // buffer
                      a = crypto.randomBytes(k *= 7);

                      for (; i < k;) {

                        // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                        // 0x100000000 is 2^32, 0x1000000 is 2^24
                        // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                        // 0 <= v < 9007199254740992
                        v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                          (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                          (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

                        if (v >= 9e15) {
                          crypto.randomBytes(7).copy(a, i);
                        } else {

                          // 0 <= (v % 1e14) <= 99999999999999
                          c.push(v % 1e14);
                          i += 7;
                        }
                      }
                      i = k / 7;
                    } else {
                      CRYPTO = false;
                      throw Error
                        (bignumberError + 'crypto unavailable');
                    }
                  }

                  // Use Math.random.
                  if (!CRYPTO) {

                    for (; i < k;) {
                      v = random53bitInt();
                      if (v < 9e15) c[i++] = v % 1e14;
                    }
                  }

                  k = c[--i];
                  dp %= LOG_BASE;

                  // Convert trailing digits to zeros according to dp.
                  if (k && dp) {
                    v = POWS_TEN[LOG_BASE - dp];
                    c[i] = mathfloor(k / v) * v;
                  }

                  // Remove trailing elements which are zero.
                  for (; c[i] === 0; c.pop(), i--);

                  // Zero?
                  if (i < 0) {
                    c = [e = 0];
                  } else {

                    // Remove leading elements which are zero and adjust exponent accordingly.
                    for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

                    // Count the digits of the first element of c to determine leading zeros, and...
                    for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

                    // adjust the exponent accordingly.
                    if (i < LOG_BASE) e -= LOG_BASE - i;
                  }

                  rand.e = e;
                  rand.c = c;
                  return rand;
                };
              })();


              /*
               * Return a BigNumber whose value is the sum of the arguments.
               *
               * arguments {number|string|BigNumber}
               */
              BigNumber.sum = function () {
                var i = 1,
                  args = arguments,
                  sum = new BigNumber(args[0]);
                for (; i < args.length;) sum = sum.plus(args[i++]);
                return sum;
              };


              // PRIVATE FUNCTIONS


              // Called by BigNumber and BigNumber.prototype.toString.
              convertBase = (function () {
                var decimal = '0123456789';

                /*
                 * Convert string of baseIn to an array of numbers of baseOut.
                 * Eg. toBaseOut('255', 10, 16) returns [15, 15].
                 * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
                 */
                function toBaseOut(str, baseIn, baseOut, alphabet) {
                  var j,
                    arr = [0],
                    arrL,
                    i = 0,
                    len = str.length;

                  for (; i < len;) {
                    for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

                    arr[0] += alphabet.indexOf(str.charAt(i++));

                    for (j = 0; j < arr.length; j++) {

                      if (arr[j] > baseOut - 1) {
                        if (arr[j + 1] == null) arr[j + 1] = 0;
                        arr[j + 1] += arr[j] / baseOut | 0;
                        arr[j] %= baseOut;
                      }
                    }
                  }

                  return arr.reverse();
                }

                // Convert a numeric string of baseIn to a numeric string of baseOut.
                // If the caller is toString, we are converting from base 10 to baseOut.
                // If the caller is BigNumber, we are converting from baseIn to base 10.
                return function (str, baseIn, baseOut, sign, callerIsToString) {
                  var alphabet, d, e, k, r, x, xc, y,
                    i = str.indexOf('.'),
                    dp = DECIMAL_PLACES,
                    rm = ROUNDING_MODE;

                  // Non-integer.
                  if (i >= 0) {
                    k = POW_PRECISION;

                    // Unlimited precision.
                    POW_PRECISION = 0;
                    str = str.replace('.', '');
                    y = new BigNumber(baseIn);
                    x = y.pow(str.length - i);
                    POW_PRECISION = k;

                    // Convert str as if an integer, then restore the fraction part by dividing the
                    // result by its base raised to a power.

                    y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
                      10, baseOut, decimal);
                    y.e = y.c.length;
                  }

                  // Convert the number as integer.

                  xc = toBaseOut(str, baseIn, baseOut, callerIsToString
                    ? (alphabet = ALPHABET, decimal)
                    : (alphabet = decimal, ALPHABET));

                  // xc now represents str as an integer and converted to baseOut. e is the exponent.
                  e = k = xc.length;

                  // Remove trailing zeros.
                  for (; xc[--k] == 0; xc.pop());

                  // Zero?
                  if (!xc[0]) return alphabet.charAt(0);

                  // Does str represent an integer? If so, no need for the division.
                  if (i < 0) {
                    --e;
                  } else {
                    x.c = xc;
                    x.e = e;

                    // The sign is needed for correct rounding.
                    x.s = sign;
                    x = div(x, y, dp, rm, baseOut);
                    xc = x.c;
                    r = x.r;
                    e = x.e;
                  }

                  // xc now represents str converted to baseOut.

                  // THe index of the rounding digit.
                  d = e + dp + 1;

                  // The rounding digit: the digit to the right of the digit that may be rounded up.
                  i = xc[d];

                  // Look at the rounding digits and mode to determine whether to round up.

                  k = baseOut / 2;
                  r = r || d < 0 || xc[d + 1] != null;

                  r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
                    : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
                      rm == (x.s < 0 ? 8 : 7));

                  // If the index of the rounding digit is not greater than zero, or xc represents
                  // zero, then the result of the base conversion is zero or, if rounding up, a value
                  // such as 0.00001.
                  if (d < 1 || !xc[0]) {

                    // 1^-dp or 0
                    str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
                  } else {

                    // Truncate xc to the required number of decimal places.
                    xc.length = d;

                    // Round up?
                    if (r) {

                      // Rounding up may mean the previous digit has to be rounded up and so on.
                      for (--baseOut; ++xc[--d] > baseOut;) {
                        xc[d] = 0;

                        if (!d) {
                          ++e;
                          xc = [1].concat(xc);
                        }
                      }
                    }

                    // Determine trailing zeros.
                    for (k = xc.length; !xc[--k];);

                    // E.g. [4, 11, 15] becomes 4bf.
                    for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

                    // Add leading zeros, decimal point and trailing zeros as required.
                    str = toFixedPoint(str, e, alphabet.charAt(0));
                  }

                  // The caller will add the sign.
                  return str;
                };
              })();


              // Perform division in the specified base. Called by div and convertBase.
              div = (function () {

                // Assume non-zero x and k.
                function multiply(x, k, base) {
                  var m, temp, xlo, xhi,
                    carry = 0,
                    i = x.length,
                    klo = k % SQRT_BASE,
                    khi = k / SQRT_BASE | 0;

                  for (x = x.slice(); i--;) {
                    xlo = x[i] % SQRT_BASE;
                    xhi = x[i] / SQRT_BASE | 0;
                    m = khi * xlo + xhi * klo;
                    temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
                    carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
                    x[i] = temp % base;
                  }

                  if (carry) x = [carry].concat(x);

                  return x;
                }

                function compare(a, b, aL, bL) {
                  var i, cmp;

                  if (aL != bL) {
                    cmp = aL > bL ? 1 : -1;
                  } else {

                    for (i = cmp = 0; i < aL; i++) {

                      if (a[i] != b[i]) {
                        cmp = a[i] > b[i] ? 1 : -1;
                        break;
                      }
                    }
                  }

                  return cmp;
                }

                function subtract(a, b, aL, base) {
                  var i = 0;

                  // Subtract b from a.
                  for (; aL--;) {
                    a[aL] -= i;
                    i = a[aL] < b[aL] ? 1 : 0;
                    a[aL] = i * base + a[aL] - b[aL];
                  }

                  // Remove leading zeros.
                  for (; !a[0] && a.length > 1; a.splice(0, 1));
                }

                // x: dividend, y: divisor.
                return function (x, y, dp, rm, base) {
                  var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
                    yL, yz,
                    s = x.s == y.s ? 1 : -1,
                    xc = x.c,
                    yc = y.c;

                  // Either NaN, Infinity or 0?
                  if (!xc || !xc[0] || !yc || !yc[0]) {

                    return new BigNumber(

                      // Return NaN if either NaN, or both Infinity or 0.
                      !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

                        // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                        xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                    );
                  }

                  q = new BigNumber(s);
                  qc = q.c = [];
                  e = x.e - y.e;
                  s = dp + e + 1;

                  if (!base) {
                    base = BASE;
                    e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
                    s = s / LOG_BASE | 0;
                  }

                  // Result exponent may be one less then the current value of e.
                  // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                  for (i = 0; yc[i] == (xc[i] || 0); i++);

                  if (yc[i] > (xc[i] || 0)) e--;

                  if (s < 0) {
                    qc.push(1);
                    more = true;
                  } else {
                    xL = xc.length;
                    yL = yc.length;
                    i = 0;
                    s += 2;

                    // Normalise xc and yc so highest order digit of yc is >= base / 2.

                    n = mathfloor(base / (yc[0] + 1));

                    // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
                    // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
                    if (n > 1) {
                      yc = multiply(yc, n, base);
                      xc = multiply(xc, n, base);
                      yL = yc.length;
                      xL = xc.length;
                    }

                    xi = yL;
                    rem = xc.slice(0, yL);
                    remL = rem.length;

                    // Add zeros to make remainder as long as divisor.
                    for (; remL < yL; rem[remL++] = 0);
                    yz = yc.slice();
                    yz = [0].concat(yz);
                    yc0 = yc[0];
                    if (yc[1] >= base / 2) yc0++;
                    // Not necessary, but to prevent trial digit n > base, when using base 3.
                    // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

                    do {
                      n = 0;

                      // Compare divisor and remainder.
                      cmp = compare(yc, rem, yL, remL);

                      // If divisor < remainder.
                      if (cmp < 0) {

                        // Calculate trial digit, n.

                        rem0 = rem[0];
                        if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

                        // n is how many times the divisor goes into the current remainder.
                        n = mathfloor(rem0 / yc0);

                        //  Algorithm:
                        //  product = divisor multiplied by trial digit (n).
                        //  Compare product and remainder.
                        //  If product is greater than remainder:
                        //    Subtract divisor from product, decrement trial digit.
                        //  Subtract product from remainder.
                        //  If product was less than remainder at the last compare:
                        //    Compare new remainder and divisor.
                        //    If remainder is greater than divisor:
                        //      Subtract divisor from remainder, increment trial digit.

                        if (n > 1) {

                          // n may be > base only when base is 3.
                          if (n >= base) n = base - 1;

                          // product = divisor * trial digit.
                          prod = multiply(yc, n, base);
                          prodL = prod.length;
                          remL = rem.length;

                          // Compare product and remainder.
                          // If product > remainder then trial digit n too high.
                          // n is 1 too high about 5% of the time, and is not known to have
                          // ever been more than 1 too high.
                          while (compare(prod, rem, prodL, remL) == 1) {
                            n--;

                            // Subtract divisor from product.
                            subtract(prod, yL < prodL ? yz : yc, prodL, base);
                            prodL = prod.length;
                            cmp = 1;
                          }
                        } else {

                          // n is 0 or 1, cmp is -1.
                          // If n is 0, there is no need to compare yc and rem again below,
                          // so change cmp to 1 to avoid it.
                          // If n is 1, leave cmp as -1, so yc and rem are compared again.
                          if (n == 0) {

                            // divisor < remainder, so n must be at least 1.
                            cmp = n = 1;
                          }

                          // product = divisor
                          prod = yc.slice();
                          prodL = prod.length;
                        }

                        if (prodL < remL) prod = [0].concat(prod);

                        // Subtract product from remainder.
                        subtract(rem, prod, remL, base);
                        remL = rem.length;

                        // If product was < remainder.
                        if (cmp == -1) {

                          // Compare divisor and new remainder.
                          // If divisor < new remainder, subtract divisor from remainder.
                          // Trial digit n too low.
                          // n is 1 too low about 5% of the time, and very rarely 2 too low.
                          while (compare(yc, rem, yL, remL) < 1) {
                            n++;

                            // Subtract divisor from remainder.
                            subtract(rem, yL < remL ? yz : yc, remL, base);
                            remL = rem.length;
                          }
                        }
                      } else if (cmp === 0) {
                        n++;
                        rem = [0];
                      } // else cmp === 1 and n will be 0

                      // Add the next digit, n, to the result array.
                      qc[i++] = n;

                      // Update the remainder.
                      if (rem[0]) {
                        rem[remL++] = xc[xi] || 0;
                      } else {
                        rem = [xc[xi]];
                        remL = 1;
                      }
                    } while ((xi++ < xL || rem[0] != null) && s--);

                    more = rem[0] != null;

                    // Leading zero?
                    if (!qc[0]) qc.splice(0, 1);
                  }

                  if (base == BASE) {

                    // To calculate q.e, first get the number of digits of qc[0].
                    for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

                    round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

                    // Caller is convertBase.
                  } else {
                    q.e = e;
                    q.r = +more;
                  }

                  return q;
                };
              })();


              /*
               * Return a string representing the value of BigNumber n in fixed-point or exponential
               * notation rounded to the specified decimal places or significant digits.
               *
               * n: a BigNumber.
               * i: the index of the last digit required (i.e. the digit that may be rounded up).
               * rm: the rounding mode.
               * id: 1 (toExponential) or 2 (toPrecision).
               */
              function format(n, i, rm, id) {
                var c0, e, ne, len, str;

                if (rm == null) rm = ROUNDING_MODE;
                else intCheck(rm, 0, 8);

                if (!n.c) return n.toString();

                c0 = n.c[0];
                ne = n.e;

                if (i == null) {
                  str = coeffToString(n.c);
                  str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
                    ? toExponential(str, ne)
                    : toFixedPoint(str, ne, '0');
                } else {
                  n = round(new BigNumber(n), i, rm);

                  // n.e may have changed if the value was rounded up.
                  e = n.e;

                  str = coeffToString(n.c);
                  len = str.length;

                  // toPrecision returns exponential notation if the number of significant digits
                  // specified is less than the number of digits necessary to represent the integer
                  // part of the value in fixed-point notation.

                  // Exponential notation.
                  if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

                    // Append zeros?
                    for (; len < i; str += '0', len++);
                    str = toExponential(str, e);

                    // Fixed-point notation.
                  } else {
                    i -= ne;
                    str = toFixedPoint(str, e, '0');

                    // Append zeros?
                    if (e + 1 > len) {
                      if (--i > 0) for (str += '.'; i--; str += '0');
                    } else {
                      i += e - len;
                      if (i > 0) {
                        if (e + 1 == len) str += '.';
                        for (; i--; str += '0');
                      }
                    }
                  }
                }

                return n.s < 0 && c0 ? '-' + str : str;
              }


              // Handle BigNumber.max and BigNumber.min.
              // If any number is NaN, return NaN.
              function maxOrMin(args, n) {
                var k, y,
                  i = 1,
                  x = new BigNumber(args[0]);

                for (; i < args.length; i++) {
                  y = new BigNumber(args[i]);
                  if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
                    x = y;
                  }
                }

                return x;
              }


              /*
               * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
               * Called by minus, plus and times.
               */
              function normalise(n, c, e) {
                var i = 1,
                  j = c.length;

                // Remove trailing zeros.
                for (; !c[--j]; c.pop());

                // Calculate the base 10 exponent. First get the number of digits of c[0].
                for (j = c[0]; j >= 10; j /= 10, i++);

                // Overflow?
                if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

                  // Infinity.
                  n.c = n.e = null;

                  // Underflow?
                } else if (e < MIN_EXP) {

                  // Zero.
                  n.c = [n.e = 0];
                } else {
                  n.e = e;
                  n.c = c;
                }

                return n;
              }


              // Handle values that fail the validity test in BigNumber.
              parseNumeric = (function () {
                var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
                  dotAfter = /^([^.]+)\.$/,
                  dotBefore = /^\.([^.]+)$/,
                  isInfinityOrNaN = /^-?(Infinity|NaN)$/,
                  whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

                return function (x, str, isNum, b) {
                  var base,
                    s = isNum ? str : str.replace(whitespaceOrPlus, '');

                  // No exception on ±Infinity or NaN.
                  if (isInfinityOrNaN.test(s)) {
                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                  } else {
                    if (!isNum) {

                      // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                      s = s.replace(basePrefix, function (m, p1, p2) {
                        base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                        return !b || b == base ? p1 : m;
                      });

                      if (b) {
                        base = b;

                        // E.g. '1.' to '1', '.1' to '0.1'
                        s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
                      }

                      if (str != s) return new BigNumber(s, base);
                    }

                    // '[BigNumber Error] Not a number: {n}'
                    // '[BigNumber Error] Not a base {b} number: {n}'
                    if (BigNumber.DEBUG) {
                      throw Error
                        (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
                    }

                    // NaN
                    x.s = null;
                  }

                  x.c = x.e = null;
                }
              })();


              /*
               * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
               * If r is truthy, it is known that there are more digits after the rounding digit.
               */
              function round(x, sd, rm, r) {
                var d, i, j, k, n, ni, rd,
                  xc = x.c,
                  pows10 = POWS_TEN;

                // if x is not Infinity or NaN...
                if (xc) {

                  // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                  // n is a base 1e14 number, the value of the element of array x.c containing rd.
                  // ni is the index of n within x.c.
                  // d is the number of digits of n.
                  // i is the index of rd within n including leading zeros.
                  // j is the actual index of rd within n (if < 0, rd is a leading zero).
                  out: {

                    // Get the number of digits of the first element of xc.
                    for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
                    i = sd - d;

                    // If the rounding digit is in the first element of xc...
                    if (i < 0) {
                      i += LOG_BASE;
                      j = sd;
                      n = xc[ni = 0];

                      // Get the rounding digit at index j of n.
                      rd = mathfloor(n / pows10[d - j - 1] % 10);
                    } else {
                      ni = mathceil((i + 1) / LOG_BASE);

                      if (ni >= xc.length) {

                        if (r) {

                          // Needed by sqrt.
                          for (; xc.length <= ni; xc.push(0));
                          n = rd = 0;
                          d = 1;
                          i %= LOG_BASE;
                          j = i - LOG_BASE + 1;
                        } else {
                          break out;
                        }
                      } else {
                        n = k = xc[ni];

                        // Get the number of digits of n.
                        for (d = 1; k >= 10; k /= 10, d++);

                        // Get the index of rd within n.
                        i %= LOG_BASE;

                        // Get the index of rd within n, adjusted for leading zeros.
                        // The number of leading zeros of n is given by LOG_BASE - d.
                        j = i - LOG_BASE + d;

                        // Get the rounding digit at index j of n.
                        rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                      }
                    }

                    r = r || sd < 0 ||

                      // Are there any non-zero digits after the rounding digit?
                      // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                      // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                      xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

                    r = rm < 4
                      ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
                      : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

                        // Check whether the digit to the left of the rounding digit is odd.
                        ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
                        rm == (x.s < 0 ? 8 : 7));

                    if (sd < 1 || !xc[0]) {
                      xc.length = 0;

                      if (r) {

                        // Convert sd to decimal places.
                        sd -= x.e + 1;

                        // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                        xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                        x.e = -sd || 0;
                      } else {

                        // Zero.
                        xc[0] = x.e = 0;
                      }

                      return x;
                    }

                    // Remove excess digits.
                    if (i == 0) {
                      xc.length = ni;
                      k = 1;
                      ni--;
                    } else {
                      xc.length = ni + 1;
                      k = pows10[LOG_BASE - i];

                      // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                      // j > 0 means i > number of leading zeros of n.
                      xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
                    }

                    // Round up?
                    if (r) {

                      for (; ;) {

                        // If the digit to be rounded up is in the first element of xc...
                        if (ni == 0) {

                          // i will be the length of xc[0] before k is added.
                          for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                          j = xc[0] += k;
                          for (k = 1; j >= 10; j /= 10, k++);

                          // if i != k the length has increased.
                          if (i != k) {
                            x.e++;
                            if (xc[0] == BASE) xc[0] = 1;
                          }

                          break;
                        } else {
                          xc[ni] += k;
                          if (xc[ni] != BASE) break;
                          xc[ni--] = 0;
                          k = 1;
                        }
                      }
                    }

                    // Remove trailing zeros.
                    for (i = xc.length; xc[--i] === 0; xc.pop());
                  }

                  // Overflow? Infinity.
                  if (x.e > MAX_EXP) {
                    x.c = x.e = null;

                    // Underflow? Zero.
                  } else if (x.e < MIN_EXP) {
                    x.c = [x.e = 0];
                  }
                }

                return x;
              }


              function valueOf(n) {
                var str,
                  e = n.e;

                if (e === null) return n.toString();

                str = coeffToString(n.c);

                str = e <= TO_EXP_NEG || e >= TO_EXP_POS
                  ? toExponential(str, e)
                  : toFixedPoint(str, e, '0');

                return n.s < 0 ? '-' + str : str;
              }


              // PROTOTYPE/INSTANCE METHODS


              /*
               * Return a new BigNumber whose value is the absolute value of this BigNumber.
               */
              P.absoluteValue = P.abs = function () {
                var x = new BigNumber(this);
                if (x.s < 0) x.s = 1;
                return x;
              };


              /*
               * Return
               *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
               *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
               *   0 if they have the same value,
               *   or null if the value of either is NaN.
               */
              P.comparedTo = function (y, b) {
                return compare(this, new BigNumber(y, b));
              };


              /*
               * If dp is undefined or null or true or false, return the number of decimal places of the
               * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
               *
               * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
               * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
               * ROUNDING_MODE if rm is omitted.
               *
               * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
               */
              P.decimalPlaces = P.dp = function (dp, rm) {
                var c, n, v,
                  x = this;

                if (dp != null) {
                  intCheck(dp, 0, MAX);
                  if (rm == null) rm = ROUNDING_MODE;
                  else intCheck(rm, 0, 8);

                  return round(new BigNumber(x), dp + x.e + 1, rm);
                }

                if (!(c = x.c)) return null;
                n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

                // Subtract the number of trailing zeros of the last number.
                if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
                if (n < 0) n = 0;

                return n;
              };


              /*
               *  n / 0 = I
               *  n / N = N
               *  n / I = 0
               *  0 / n = 0
               *  0 / 0 = N
               *  0 / N = N
               *  0 / I = 0
               *  N / n = N
               *  N / 0 = N
               *  N / N = N
               *  N / I = N
               *  I / n = I
               *  I / 0 = I
               *  I / N = N
               *  I / I = N
               *
               * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
               * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
               */
              P.dividedBy = P.div = function (y, b) {
                return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
              };


              /*
               * Return a new BigNumber whose value is the integer part of dividing the value of this
               * BigNumber by the value of BigNumber(y, b).
               */
              P.dividedToIntegerBy = P.idiv = function (y, b) {
                return div(this, new BigNumber(y, b), 0, 1);
              };


              /*
               * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
               *
               * If m is present, return the result modulo m.
               * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
               * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
               *
               * The modular power operation works efficiently when x, n, and m are integers, otherwise it
               * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
               *
               * n {number|string|BigNumber} The exponent. An integer.
               * [m] {number|string|BigNumber} The modulus.
               *
               * '[BigNumber Error] Exponent not an integer: {n}'
               */
              P.exponentiatedBy = P.pow = function (n, m) {
                var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
                  x = this;

                n = new BigNumber(n);

                // Allow NaN and ±Infinity, but not other non-integers.
                if (n.c && !n.isInteger()) {
                  throw Error
                    (bignumberError + 'Exponent not an integer: ' + valueOf(n));
                }

                if (m != null) m = new BigNumber(m);

                // Exponent of MAX_SAFE_INTEGER is 15.
                nIsBig = n.e > 14;

                // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.
                if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

                  // The sign of the result of pow when x is negative depends on the evenness of n.
                  // If +n overflows to ±Infinity, the evenness of n would be not be known.
                  y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
                  return m ? y.mod(m) : y;
                }

                nIsNeg = n.s < 0;

                if (m) {

                  // x % m returns NaN if abs(m) is zero, or m is NaN.
                  if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

                  isModExp = !nIsNeg && x.isInteger() && m.isInteger();

                  if (isModExp) x = x.mod(m);

                  // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.
                  // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.
                } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
                  // [1, 240000000]
                  ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
                  // [80000000000000]  [99999750000000]
                  : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

                  // If x is negative and n is odd, k = -0, else k = 0.
                  k = x.s < 0 && isOdd(n) ? -0 : 0;

                  // If x >= 1, k = ±Infinity.
                  if (x.e > -1) k = 1 / k;

                  // If n is negative return ±0, else return ±Infinity.
                  return new BigNumber(nIsNeg ? 1 / k : k);

                } else if (POW_PRECISION) {

                  // Truncating each coefficient array to a length of k after each multiplication
                  // equates to truncating significant digits to POW_PRECISION + [28, 41],
                  // i.e. there will be a minimum of 28 guard digits retained.
                  k = mathceil(POW_PRECISION / LOG_BASE + 2);
                }

                if (nIsBig) {
                  half = new BigNumber(0.5);
                  if (nIsNeg) n.s = 1;
                  nIsOdd = isOdd(n);
                } else {
                  i = Math.abs(+valueOf(n));
                  nIsOdd = i % 2;
                }

                y = new BigNumber(ONE);

                // Performs 54 loop iterations for n of 9007199254740991.
                for (; ;) {

                  if (nIsOdd) {
                    y = y.times(x);
                    if (!y.c) break;

                    if (k) {
                      if (y.c.length > k) y.c.length = k;
                    } else if (isModExp) {
                      y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
                    }
                  }

                  if (i) {
                    i = mathfloor(i / 2);
                    if (i === 0) break;
                    nIsOdd = i % 2;
                  } else {
                    n = n.times(half);
                    round(n, n.e + 1, 1);

                    if (n.e > 14) {
                      nIsOdd = isOdd(n);
                    } else {
                      i = +valueOf(n);
                      if (i === 0) break;
                      nIsOdd = i % 2;
                    }
                  }

                  x = x.times(x);

                  if (k) {
                    if (x.c && x.c.length > k) x.c.length = k;
                  } else if (isModExp) {
                    x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
                  }
                }

                if (isModExp) return y;
                if (nIsNeg) y = ONE.div(y);

                return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
              };


              /*
               * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
               * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
               *
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
               */
              P.integerValue = function (rm) {
                var n = new BigNumber(this);
                if (rm == null) rm = ROUNDING_MODE;
                else intCheck(rm, 0, 8);
                return round(n, n.e + 1, rm);
              };


              /*
               * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
               * otherwise return false.
               */
              P.isEqualTo = P.eq = function (y, b) {
                return compare(this, new BigNumber(y, b)) === 0;
              };


              /*
               * Return true if the value of this BigNumber is a finite number, otherwise return false.
               */
              P.isFinite = function () {
                return !!this.c;
              };


              /*
               * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
               * otherwise return false.
               */
              P.isGreaterThan = P.gt = function (y, b) {
                return compare(this, new BigNumber(y, b)) > 0;
              };


              /*
               * Return true if the value of this BigNumber is greater than or equal to the value of
               * BigNumber(y, b), otherwise return false.
               */
              P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
                return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

              };


              /*
               * Return true if the value of this BigNumber is an integer, otherwise return false.
               */
              P.isInteger = function () {
                return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
              };


              /*
               * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
               * otherwise return false.
               */
              P.isLessThan = P.lt = function (y, b) {
                return compare(this, new BigNumber(y, b)) < 0;
              };


              /*
               * Return true if the value of this BigNumber is less than or equal to the value of
               * BigNumber(y, b), otherwise return false.
               */
              P.isLessThanOrEqualTo = P.lte = function (y, b) {
                return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
              };


              /*
               * Return true if the value of this BigNumber is NaN, otherwise return false.
               */
              P.isNaN = function () {
                return !this.s;
              };


              /*
               * Return true if the value of this BigNumber is negative, otherwise return false.
               */
              P.isNegative = function () {
                return this.s < 0;
              };


              /*
               * Return true if the value of this BigNumber is positive, otherwise return false.
               */
              P.isPositive = function () {
                return this.s > 0;
              };


              /*
               * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
               */
              P.isZero = function () {
                return !!this.c && this.c[0] == 0;
              };


              /*
               *  n - 0 = n
               *  n - N = N
               *  n - I = -I
               *  0 - n = -n
               *  0 - 0 = 0
               *  0 - N = N
               *  0 - I = -I
               *  N - n = N
               *  N - 0 = N
               *  N - N = N
               *  N - I = N
               *  I - n = I
               *  I - 0 = I
               *  I - N = N
               *  I - I = N
               *
               * Return a new BigNumber whose value is the value of this BigNumber minus the value of
               * BigNumber(y, b).
               */
              P.minus = function (y, b) {
                var i, j, t, xLTy,
                  x = this,
                  a = x.s;

                y = new BigNumber(y, b);
                b = y.s;

                // Either NaN?
                if (!a || !b) return new BigNumber(NaN);

                // Signs differ?
                if (a != b) {
                  y.s = -b;
                  return x.plus(y);
                }

                var xe = x.e / LOG_BASE,
                  ye = y.e / LOG_BASE,
                  xc = x.c,
                  yc = y.c;

                if (!xe || !ye) {

                  // Either Infinity?
                  if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

                  // Either zero?
                  if (!xc[0] || !yc[0]) {

                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                    return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

                      // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                      ROUNDING_MODE == 3 ? -0 : 0);
                  }
                }

                xe = bitFloor(xe);
                ye = bitFloor(ye);
                xc = xc.slice();

                // Determine which is the bigger number.
                if (a = xe - ye) {

                  if (xLTy = a < 0) {
                    a = -a;
                    t = xc;
                  } else {
                    ye = xe;
                    t = yc;
                  }

                  t.reverse();

                  // Prepend zeros to equalise exponents.
                  for (b = a; b--; t.push(0));
                  t.reverse();
                } else {

                  // Exponents equal. Check digit by digit.
                  j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

                  for (a = b = 0; b < j; b++) {

                    if (xc[b] != yc[b]) {
                      xLTy = xc[b] < yc[b];
                      break;
                    }
                  }
                }

                // x < y? Point xc to the array of the bigger number.
                if (xLTy) {
                  t = xc;
                  xc = yc;
                  yc = t;
                  y.s = -y.s;
                }

                b = (j = yc.length) - (i = xc.length);

                // Append zeros to xc if shorter.
                // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
                if (b > 0) for (; b--; xc[i++] = 0);
                b = BASE - 1;

                // Subtract yc from xc.
                for (; j > a;) {

                  if (xc[--j] < yc[j]) {
                    for (i = j; i && !xc[--i]; xc[i] = b);
                    --xc[i];
                    xc[j] += BASE;
                  }

                  xc[j] -= yc[j];
                }

                // Remove leading zeros and adjust exponent accordingly.
                for (; xc[0] == 0; xc.splice(0, 1), --ye);

                // Zero?
                if (!xc[0]) {

                  // Following IEEE 754 (2008) 6.3,
                  // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                  y.s = ROUNDING_MODE == 3 ? -1 : 1;
                  y.c = [y.e = 0];
                  return y;
                }

                // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
                // for finite x and y.
                return normalise(y, xc, ye);
              };


              /*
               *   n % 0 =  N
               *   n % N =  N
               *   n % I =  n
               *   0 % n =  0
               *  -0 % n = -0
               *   0 % 0 =  N
               *   0 % N =  N
               *   0 % I =  0
               *   N % n =  N
               *   N % 0 =  N
               *   N % N =  N
               *   N % I =  N
               *   I % n =  N
               *   I % 0 =  N
               *   I % N =  N
               *   I % I =  N
               *
               * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
               * BigNumber(y, b). The result depends on the value of MODULO_MODE.
               */
              P.modulo = P.mod = function (y, b) {
                var q, s,
                  x = this;

                y = new BigNumber(y, b);

                // Return NaN if x is Infinity or NaN, or y is NaN or zero.
                if (!x.c || !y.s || y.c && !y.c[0]) {
                  return new BigNumber(NaN);

                  // Return x if y is Infinity or x is zero.
                } else if (!y.c || x.c && !x.c[0]) {
                  return new BigNumber(x);
                }

                if (MODULO_MODE == 9) {

                  // Euclidian division: q = sign(y) * floor(x / abs(y))
                  // r = x - qy    where  0 <= r < abs(y)
                  s = y.s;
                  y.s = 1;
                  q = div(x, y, 0, 3);
                  y.s = s;
                  q.s *= s;
                } else {
                  q = div(x, y, 0, MODULO_MODE);
                }

                y = x.minus(q.times(y));

                // To match JavaScript %, ensure sign of zero is sign of dividend.
                if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

                return y;
              };


              /*
               *  n * 0 = 0
               *  n * N = N
               *  n * I = I
               *  0 * n = 0
               *  0 * 0 = 0
               *  0 * N = N
               *  0 * I = N
               *  N * n = N
               *  N * 0 = N
               *  N * N = N
               *  N * I = N
               *  I * n = I
               *  I * 0 = N
               *  I * N = N
               *  I * I = I
               *
               * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
               * of BigNumber(y, b).
               */
              P.multipliedBy = P.times = function (y, b) {
                var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
                  base, sqrtBase,
                  x = this,
                  xc = x.c,
                  yc = (y = new BigNumber(y, b)).c;

                // Either NaN, ±Infinity or ±0?
                if (!xc || !yc || !xc[0] || !yc[0]) {

                  // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                  if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
                    y.c = y.e = y.s = null;
                  } else {
                    y.s *= x.s;

                    // Return ±Infinity if either is ±Infinity.
                    if (!xc || !yc) {
                      y.c = y.e = null;

                      // Return ±0 if either is ±0.
                    } else {
                      y.c = [0];
                      y.e = 0;
                    }
                  }

                  return y;
                }

                e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
                y.s *= x.s;
                xcL = xc.length;
                ycL = yc.length;

                // Ensure xc points to longer array and xcL to its length.
                if (xcL < ycL) {
                  zc = xc;
                  xc = yc;
                  yc = zc;
                  i = xcL;
                  xcL = ycL;
                  ycL = i;
                }

                // Initialise the result array with zeros.
                for (i = xcL + ycL, zc = []; i--; zc.push(0));

                base = BASE;
                sqrtBase = SQRT_BASE;

                for (i = ycL; --i >= 0;) {
                  c = 0;
                  ylo = yc[i] % sqrtBase;
                  yhi = yc[i] / sqrtBase | 0;

                  for (k = xcL, j = i + k; j > i;) {
                    xlo = xc[--k] % sqrtBase;
                    xhi = xc[k] / sqrtBase | 0;
                    m = yhi * xlo + xhi * ylo;
                    xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
                    c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
                    zc[j--] = xlo % base;
                  }

                  zc[j] = c;
                }

                if (c) {
                  ++e;
                } else {
                  zc.splice(0, 1);
                }

                return normalise(y, zc, e);
              };


              /*
               * Return a new BigNumber whose value is the value of this BigNumber negated,
               * i.e. multiplied by -1.
               */
              P.negated = function () {
                var x = new BigNumber(this);
                x.s = -x.s || null;
                return x;
              };


              /*
               *  n + 0 = n
               *  n + N = N
               *  n + I = I
               *  0 + n = n
               *  0 + 0 = 0
               *  0 + N = N
               *  0 + I = I
               *  N + n = N
               *  N + 0 = N
               *  N + N = N
               *  N + I = N
               *  I + n = I
               *  I + 0 = I
               *  I + N = N
               *  I + I = I
               *
               * Return a new BigNumber whose value is the value of this BigNumber plus the value of
               * BigNumber(y, b).
               */
              P.plus = function (y, b) {
                var t,
                  x = this,
                  a = x.s;

                y = new BigNumber(y, b);
                b = y.s;

                // Either NaN?
                if (!a || !b) return new BigNumber(NaN);

                // Signs differ?
                if (a != b) {
                  y.s = -b;
                  return x.minus(y);
                }

                var xe = x.e / LOG_BASE,
                  ye = y.e / LOG_BASE,
                  xc = x.c,
                  yc = y.c;

                if (!xe || !ye) {

                  // Return ±Infinity if either ±Infinity.
                  if (!xc || !yc) return new BigNumber(a / 0);

                  // Either zero?
                  // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                  if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
                }

                xe = bitFloor(xe);
                ye = bitFloor(ye);
                xc = xc.slice();

                // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
                if (a = xe - ye) {
                  if (a > 0) {
                    ye = xe;
                    t = yc;
                  } else {
                    a = -a;
                    t = xc;
                  }

                  t.reverse();
                  for (; a--; t.push(0));
                  t.reverse();
                }

                a = xc.length;
                b = yc.length;

                // Point xc to the longer array, and b to the shorter length.
                if (a - b < 0) {
                  t = yc;
                  yc = xc;
                  xc = t;
                  b = a;
                }

                // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
                for (a = 0; b;) {
                  a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
                  xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
                }

                if (a) {
                  xc = [a].concat(xc);
                  ++ye;
                }

                // No need to check for zero, as +x + +y != 0 && -x + -y != 0
                // ye = MAX_EXP + 1 possible
                return normalise(y, xc, ye);
              };


              /*
               * If sd is undefined or null or true or false, return the number of significant digits of
               * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.
               * If sd is true include integer-part trailing zeros in the count.
               *
               * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
               * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
               * ROUNDING_MODE if rm is omitted.
               *
               * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
               *                     boolean: whether to count integer-part trailing zeros: true or false.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
               */
              P.precision = P.sd = function (sd, rm) {
                var c, n, v,
                  x = this;

                if (sd != null && sd !== !!sd) {
                  intCheck(sd, 1, MAX);
                  if (rm == null) rm = ROUNDING_MODE;
                  else intCheck(rm, 0, 8);

                  return round(new BigNumber(x), sd, rm);
                }

                if (!(c = x.c)) return null;
                v = c.length - 1;
                n = v * LOG_BASE + 1;

                if (v = c[v]) {

                  // Subtract the number of trailing zeros of the last element.
                  for (; v % 10 == 0; v /= 10, n--);

                  // Add the number of digits of the first element.
                  for (v = c[0]; v >= 10; v /= 10, n++);
                }

                if (sd && x.e + 1 > n) n = x.e + 1;

                return n;
              };


              /*
               * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
               * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
               *
               * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
               */
              P.shiftedBy = function (k) {
                intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
                return this.times('1e' + k);
              };


              /*
               *  sqrt(-n) =  N
               *  sqrt(N) =  N
               *  sqrt(-I) =  N
               *  sqrt(I) =  I
               *  sqrt(0) =  0
               *  sqrt(-0) = -0
               *
               * Return a new BigNumber whose value is the square root of the value of this BigNumber,
               * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
               */
              P.squareRoot = P.sqrt = function () {
                var m, n, r, rep, t,
                  x = this,
                  c = x.c,
                  s = x.s,
                  e = x.e,
                  dp = DECIMAL_PLACES + 4,
                  half = new BigNumber('0.5');

                // Negative/NaN/Infinity/zero?
                if (s !== 1 || !c || !c[0]) {
                  return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
                }

                // Initial estimate.
                s = Math.sqrt(+valueOf(x));

                // Math.sqrt underflow/overflow?
                // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
                if (s == 0 || s == 1 / 0) {
                  n = coeffToString(c);
                  if ((n.length + e) % 2 == 0) n += '0';
                  s = Math.sqrt(+n);
                  e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

                  if (s == 1 / 0) {
                    n = '5e' + e;
                  } else {
                    n = s.toExponential();
                    n = n.slice(0, n.indexOf('e') + 1) + e;
                  }

                  r = new BigNumber(n);
                } else {
                  r = new BigNumber(s + '');
                }

                // Check for zero.
                // r could be zero if MIN_EXP is changed after the this value was created.
                // This would cause a division by zero (x/t) and hence Infinity below, which would cause
                // coeffToString to throw.
                if (r.c[0]) {
                  e = r.e;
                  s = e + dp;
                  if (s < 3) s = 0;

                  // Newton-Raphson iteration.
                  for (; ;) {
                    t = r;
                    r = half.times(t.plus(div(x, t, dp, 1)));

                    if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

                      // The exponent of r may here be one less than the final result exponent,
                      // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
                      // are indexed correctly.
                      if (r.e < e) --s;
                      n = n.slice(s - 3, s + 1);

                      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                      // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                      // iteration.
                      if (n == '9999' || !rep && n == '4999') {

                        // On the first iteration only, check to see if rounding up gives the
                        // exact result as the nines may infinitely repeat.
                        if (!rep) {
                          round(t, t.e + DECIMAL_PLACES + 2, 0);

                          if (t.times(t).eq(x)) {
                            r = t;
                            break;
                          }
                        }

                        dp += 4;
                        s += 4;
                        rep = 1;
                      } else {

                        // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                        // result. If not, then there are further digits and m will be truthy.
                        if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                          // Truncate to the first rounding digit.
                          round(r, r.e + DECIMAL_PLACES + 2, 1);
                          m = !r.times(r).eq(x);
                        }

                        break;
                      }
                    }
                  }
                }

                return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
              };


              /*
               * Return a string representing the value of this BigNumber in exponential notation and
               * rounded using ROUNDING_MODE to dp fixed decimal places.
               *
               * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
               */
              P.toExponential = function (dp, rm) {
                if (dp != null) {
                  intCheck(dp, 0, MAX);
                  dp++;
                }
                return format(this, dp, rm, 1);
              };


              /*
               * Return a string representing the value of this BigNumber in fixed-point notation rounding
               * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
               *
               * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
               * but e.g. (-0.00001).toFixed(0) is '-0'.
               *
               * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
               */
              P.toFixed = function (dp, rm) {
                if (dp != null) {
                  intCheck(dp, 0, MAX);
                  dp = dp + this.e + 1;
                }
                return format(this, dp, rm);
              };


              /*
               * Return a string representing the value of this BigNumber in fixed-point notation rounded
               * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
               * of the format or FORMAT object (see BigNumber.set).
               *
               * The formatting object may contain some or all of the properties shown below.
               *
               * FORMAT = {
               *   prefix: '',
               *   groupSize: 3,
               *   secondaryGroupSize: 0,
               *   groupSeparator: ',',
               *   decimalSeparator: '.',
               *   fractionGroupSize: 0,
               *   fractionGroupSeparator: '\xA0',      // non-breaking space
               *   suffix: ''
               * };
               *
               * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               * [format] {object} Formatting options. See FORMAT pbject above.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
               * '[BigNumber Error] Argument not an object: {format}'
               */
              P.toFormat = function (dp, rm, format) {
                var str,
                  x = this;

                if (format == null) {
                  if (dp != null && rm && typeof rm == 'object') {
                    format = rm;
                    rm = null;
                  } else if (dp && typeof dp == 'object') {
                    format = dp;
                    dp = rm = null;
                  } else {
                    format = FORMAT;
                  }
                } else if (typeof format != 'object') {
                  throw Error
                    (bignumberError + 'Argument not an object: ' + format);
                }

                str = x.toFixed(dp, rm);

                if (x.c) {
                  var i,
                    arr = str.split('.'),
                    g1 = +format.groupSize,
                    g2 = +format.secondaryGroupSize,
                    groupSeparator = format.groupSeparator || '',
                    intPart = arr[0],
                    fractionPart = arr[1],
                    isNeg = x.s < 0,
                    intDigits = isNeg ? intPart.slice(1) : intPart,
                    len = intDigits.length;

                  if (g2) {
                    i = g1;
                    g1 = g2;
                    g2 = i;
                    len -= i;
                  }

                  if (g1 > 0 && len > 0) {
                    i = len % g1 || g1;
                    intPart = intDigits.substr(0, i);
                    for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
                    if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
                    if (isNeg) intPart = '-' + intPart;
                  }

                  str = fractionPart
                    ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
                      ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
                        '$&' + (format.fractionGroupSeparator || ''))
                      : fractionPart)
                    : intPart;
                }

                return (format.prefix || '') + str + (format.suffix || '');
              };


              /*
               * Return an array of two BigNumbers representing the value of this BigNumber as a simple
               * fraction with an integer numerator and an integer denominator.
               * The denominator will be a positive non-zero value less than or equal to the specified
               * maximum denominator. If a maximum denominator is not specified, the denominator will be
               * the lowest value necessary to represent the number exactly.
               *
               * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
               *
               * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
               */
              P.toFraction = function (md) {
                var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
                  x = this,
                  xc = x.c;

                if (md != null) {
                  n = new BigNumber(md);

                  // Throw if md is less than one or is not an integer, unless it is Infinity.
                  if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
                    throw Error
                      (bignumberError + 'Argument ' +
                        (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
                  }
                }

                if (!xc) return new BigNumber(x);

                d = new BigNumber(ONE);
                n1 = d0 = new BigNumber(ONE);
                d1 = n0 = new BigNumber(ONE);
                s = coeffToString(xc);

                // Determine initial denominator.
                // d is a power of 10 and the minimum max denominator that specifies the value exactly.
                e = d.e = s.length - x.e - 1;
                d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
                md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

                exp = MAX_EXP;
                MAX_EXP = 1 / 0;
                n = new BigNumber(s);

                // n0 = d1 = 0
                n0.c[0] = 0;

                for (; ;) {
                  q = div(n, d, 0, 1);
                  d2 = d0.plus(q.times(d1));
                  if (d2.comparedTo(md) == 1) break;
                  d0 = d1;
                  d1 = d2;
                  n1 = n0.plus(q.times(d2 = n1));
                  n0 = d2;
                  d = n.minus(q.times(d2 = d));
                  n = d2;
                }

                d2 = div(md.minus(d0), d1, 0, 1);
                n0 = n0.plus(d2.times(n1));
                d0 = d0.plus(d2.times(d1));
                n0.s = n1.s = x.s;
                e = e * 2;

                // Determine which fraction is closer to x, n0/d0 or n1/d1
                r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
                  div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

                MAX_EXP = exp;

                return r;
              };


              /*
               * Return the value of this BigNumber converted to a number primitive.
               */
              P.toNumber = function () {
                return +valueOf(this);
              };


              /*
               * Return a string representing the value of this BigNumber rounded to sd significant digits
               * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
               * necessary to represent the integer part of the value in fixed-point notation, then use
               * exponential notation.
               *
               * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
               */
              P.toPrecision = function (sd, rm) {
                if (sd != null) intCheck(sd, 1, MAX);
                return format(this, sd, rm, 2);
              };


              /*
               * Return a string representing the value of this BigNumber in base b, or base 10 if b is
               * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
               * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
               * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
               * TO_EXP_NEG, return exponential notation.
               *
               * [b] {number} Integer, 2 to ALPHABET.length inclusive.
               *
               * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
               */
              P.toString = function (b) {
                var str,
                  n = this,
                  s = n.s,
                  e = n.e;

                // Infinity or NaN?
                if (e === null) {
                  if (s) {
                    str = 'Infinity';
                    if (s < 0) str = '-' + str;
                  } else {
                    str = 'NaN';
                  }
                } else {
                  if (b == null) {
                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
                      ? toExponential(coeffToString(n.c), e)
                      : toFixedPoint(coeffToString(n.c), e, '0');
                  } else if (b === 10 && alphabetHasNormalDecimalDigits) {
                    n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
                    str = toFixedPoint(coeffToString(n.c), n.e, '0');
                  } else {
                    intCheck(b, 2, ALPHABET.length, 'Base');
                    str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
                  }

                  if (s < 0 && n.c[0]) str = '-' + str;
                }

                return str;
              };


              /*
               * Return as toString, but do not accept a base argument, and include the minus sign for
               * negative zero.
               */
              P.valueOf = P.toJSON = function () {
                return valueOf(this);
              };


              P._isBigNumber = true;

              if (configObject != null) BigNumber.set(configObject);

              return BigNumber;
            }


            // PRIVATE HELPER FUNCTIONS

            // These functions don't need access to variables,
            // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


            function bitFloor(n) {
              var i = n | 0;
              return n > 0 || n === i ? i : i - 1;
            }


            // Return a coefficient array as a string of base 10 digits.
            function coeffToString(a) {
              var s, z,
                i = 1,
                j = a.length,
                r = a[0] + '';

              for (; i < j;) {
                s = a[i++] + '';
                z = LOG_BASE - s.length;
                for (; z--; s = '0' + s);
                r += s;
              }

              // Determine trailing zeros.
              for (j = r.length; r.charCodeAt(--j) === 48;);

              return r.slice(0, j + 1 || 1);
            }


            // Compare the value of BigNumbers x and y.
            function compare(x, y) {
              var a, b,
                xc = x.c,
                yc = y.c,
                i = x.s,
                j = y.s,
                k = x.e,
                l = y.e;

              // Either NaN?
              if (!i || !j) return null;

              a = xc && !xc[0];
              b = yc && !yc[0];

              // Either zero?
              if (a || b) return a ? b ? 0 : -j : i;

              // Signs differ?
              if (i != j) return i;

              a = i < 0;
              b = k == l;

              // Either Infinity?
              if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

              // Compare exponents.
              if (!b) return k > l ^ a ? 1 : -1;

              j = (k = xc.length) < (l = yc.length) ? k : l;

              // Compare digit by digit.
              for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

              // Compare lengths.
              return k == l ? 0 : k > l ^ a ? 1 : -1;
            }


            /*
             * Check that n is a primitive number, an integer, and in range, otherwise throw.
             */
            function intCheck(n, min, max, name) {
              if (n < min || n > max || n !== mathfloor(n)) {
                throw Error
                  (bignumberError + (name || 'Argument') + (typeof n == 'number'
                    ? n < min || n > max ? ' out of range: ' : ' not an integer: '
                    : ' not a primitive number: ') + String(n));
              }
            }


            // Assumes finite n.
            function isOdd(n) {
              var k = n.c.length - 1;
              return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
            }


            function toExponential(str, e) {
              return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
                (e < 0 ? 'e' : 'e+') + e;
            }


            function toFixedPoint(str, e, z) {
              var len, zs;

              // Negative exponent?
              if (e < 0) {

                // Prepend zeros.
                for (zs = z + '.'; ++e; zs += z);
                str = zs + str;

                // Positive exponent
              } else {
                len = str.length;

                // Append zeros.
                if (++e > len) {
                  for (zs = z, e -= len; --e; zs += z);
                  str += zs;
                } else if (e < len) {
                  str = str.slice(0, e) + '.' + str.slice(e);
                }
              }

              return str;
            }


            // EXPORT


            BigNumber = clone();
            BigNumber['default'] = BigNumber.BigNumber = BigNumber;

            // AMD.
            if (true) {
              !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),
                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

              // Node.js and other environments that support module.exports.
            } else { }
          })(this);


          /***/
}),

/***/ "./node_modules/net/index.js":
/*!***********************************!*\
  !*** ./node_modules/net/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

          /*
          Copyright 2013 Sleepless Software Inc. All rights reserved.
          
          Permission is hereby granted, free of charge, to any person obtaining a copy
          of this software and associated documentation files (the "Software"), to
          deal in the Software without restriction, including without limitation the
          rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
          sell copies of the Software, and to permit persons to whom the Software is
          furnished to do so, subject to the following conditions:
          
          The above copyright notice and this permission notice shall be included in
          all copies or substantial portions of the Software.
          
          THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
          IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
          FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
          AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
          LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
          FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
          IN THE SOFTWARE. 
          */

          // yes, I know this seems stupid, but I have my reasons.

          var net = __webpack_require__(/*! net */ "./node_modules/net/index.js")
          for (k in net)
            __webpack_require__.g[k] = net[k]



          /***/
}),

/***/ "./src/QubicConnector.ts":
/*!*******************************!*\
  !*** ./src/QubicConnector.ts ***!
  \*******************************/
/***/ (function (__unused_webpack_module, exports, __webpack_require__) {

          "use strict";

          var __importDefault = (this && this.__importDefault) || function (mod) {
            return (mod && mod.__esModule) ? mod : { "default": mod };
          };
          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.QubicConnector = void 0;
          const QubicPackageType_1 = __webpack_require__(/*! ./qubic-communication/QubicPackageType */ "./src/qubic-communication/QubicPackageType.ts");
          const ReceivedPackage_1 = __webpack_require__(/*! ./qubic-communication/ReceivedPackage */ "./src/qubic-communication/ReceivedPackage.ts");
          const RequestResponseHeader_1 = __webpack_require__(/*! ./qubic-communication/RequestResponseHeader */ "./src/qubic-communication/RequestResponseHeader.ts");
          const QubicTickInfo_1 = __webpack_require__(/*! ./qubic-types/QubicTickInfo */ "./src/qubic-types/QubicTickInfo.ts");
          const QubicEntityResponse_1 = __webpack_require__(/*! ./qubic-communication/QubicEntityResponse */ "./src/qubic-communication/QubicEntityResponse.ts");
          const QubicPackageBuilder_1 = __webpack_require__(/*! ./QubicPackageBuilder */ "./src/QubicPackageBuilder.ts");
          const QubicEntityRequest_1 = __webpack_require__(/*! ./qubic-communication/QubicEntityRequest */ "./src/qubic-communication/QubicEntityRequest.ts");
          const crypto_1 = __importDefault(__webpack_require__(/*! ./crypto */ "./src/crypto/index.js"));
          const keyHelper_1 = __webpack_require__(/*! ./keyHelper */ "./src/keyHelper.ts");
          class QubicConnector {
            constructor(bridgeAddress) {
              this.PORT = 21841;
              this.isWsConnected = false;
              this.peerConnected = false;
              this.buffer = new Uint8Array(4 * 1024 * 1024);
              this.bufferWritePosition = 0;
              this.bufferReadPosition = 0;
              this.currentTick = 0;
              this.isNodeJs = false;
              this.isNodeJs = this.isNodeJsCheck();
              if (!this.isNodeJs) {
                this.webSocket = new WebSocket(bridgeAddress || 'wss://webbridge.qubic.li/'); // qli web bridge address
              }
              else {
                // assume we are running in nodejs
                const net2 = __webpack_require__(/*! net */ "./node_modules/net/index.js");
                this.socket = new net2.Socket();
                if (this.socket) {
                  this.socket.on('data', (d) => {
                    this.writeBuffer(d);
                  });
                  this.socket.on('close', (d) => {
                    if (this.onPeerDisconnected)
                      this.onPeerDisconnected();
                  });
                }
              }
            }
            isNodeJsCheck() {
              if (typeof window === 'undefined') {
                return true;
              }
              else {
                return false;
              }
            }
            onPeerConnect() {
              this.peerConnected = true;
              if (this.onPeerConnected)
                this.onPeerConnected();
            }
            toBase64(u8) {
              return btoa(String.fromCharCode.apply(null, u8));
            }
            connectPeer(ipAddress) {
              if (!this.isNodeJs) {
                if (!this.isWsConnected) {
                  console.error("WS not connected");
                  return false;
                }
                this.webSocket?.send(JSON.stringify({
                  command: 'connect',
                  host: ipAddress,
                  port: this.PORT
                }));
              }
              else {
                this.socket?.connect(this.PORT, ipAddress, () => {
                  this.onPeerConnect();
                });
              }
              this.connectedPeerAddress = ipAddress;
              return true;
            }
            disconnectPeer() {
              if (this.connectedPeerAddress) {
                if (!this.isNodeJs) {
                  this.webSocket?.send(JSON.stringify({
                    command: 'disconnect',
                    host: this.connectedPeerAddress,
                    port: this.PORT
                  }));
                }
                else {
                  this.socket?.destroy();
                }
                this.connectedPeerAddress = undefined;
                this.peerConnected = false;
              }
            }
            reconnectPeer() {
              this.disconnectPeer(); // disconnect
              if (this.connectedPeerAddress) {
                return this.connectPeer(this.connectedPeerAddress); // conncet
              }
              return false;
            }
            writeBuffer(data) {
              //console.log("writeBuffer", data);
              let writeLength = data.length;
              if (this.bufferWritePosition + data.length > this.buffer.length)
                writeLength = this.buffer.length - this.bufferWritePosition;
              this.buffer.set(data.slice(0, writeLength), this.bufferWritePosition);
              this.bufferWritePosition += writeLength;
              if (writeLength < data.length) {
                this.bufferWritePosition = 0;
                this.buffer.set(data.slice(writeLength, data.length));
                this.bufferWritePosition += data.length - writeLength;
              }
              this.processBuffer();
            }
            readFromBuffer(numberOfBytes, setReadPosition = false) {
              const extract = new Uint8Array(numberOfBytes);
              if (this.bufferReadPosition + numberOfBytes <= this.buffer.length) {
                const readBytes = this.buffer.slice(this.bufferReadPosition, this.bufferReadPosition + numberOfBytes);
                //console.log("BUFFER READ " + this.bufferReadPosition + " - " + numberOfBytes, readBytes);
                extract.set(readBytes);
              }
              else {
                extract.set(this.buffer.slice(this.bufferReadPosition));
                extract.set(this.buffer.slice(0, this.bufferReadPosition + numberOfBytes - this.buffer.length));
              }
              if (setReadPosition)
                this.setReadPosition(numberOfBytes);
              return extract;
            }
            setReadPosition(numberOfReadByts) {
              if (this.bufferReadPosition + numberOfReadByts > this.buffer.length)
                this.bufferReadPosition = 0 + (this.bufferReadPosition + numberOfReadByts - this.buffer.length);
              else
                this.bufferReadPosition += numberOfReadByts;
            }
            processBuffer() {
              while (true) {
                const toReadBytes = Math.abs(this.bufferWritePosition - this.bufferReadPosition);
                if (toReadBytes < 8) /* header size */ {
                  break;
                }
                // read header
                const header = new RequestResponseHeader_1.RequestResponseHeader();
                header.parse(this.readFromBuffer(8 /* header size */));
                if (header === undefined || toReadBytes < header?.getSize()) {
                  //console.log("NOT ENOUGH BYTES FOR COMPLETE PACKAGE");
                  break;
                }
                this.setReadPosition(header.getPackageSize());
                const recPackage = new ReceivedPackage_1.ReceivedPackage();
                recPackage.header = header;
                recPackage.ipAddress = this.connectedPeerAddress ?? "";
                if (header.getSize() > 8) {
                  recPackage.payLoad = this.readFromBuffer(header.getSize() - header.getPackageSize(), true);
                }
                else {
                  recPackage.payLoad = new Uint8Array(0);
                }
                this.processPackage(recPackage);
                if (this.onPackageReceived)
                  this.onPackageReceived(recPackage);
              }
            }
            processPackage(p) {
              if (p.header.getType() == QubicPackageType_1.QubicPackageType.RESPOND_CURRENT_TICK_INFO) {
                const tickInfo = new QubicTickInfo_1.QubicTickInfo().parse(p.payLoad);
                if (tickInfo && this.currentTick < tickInfo.getTick()) {
                  this.currentTick = tickInfo.getTick();
                  if (this.onTick)
                    this.onTick(this.currentTick);
                }
              }
              else if (p.header.getType() == QubicPackageType_1.QubicPackageType.RESPOND_ENTITY) {
                const entityResponse = new QubicEntityResponse_1.QubicEntityResponse().parse(p.payLoad);
                if (this.onBalance)
                  this.onBalance(entityResponse);
              }
            }
            requestTickInfo() {
              if (this.peerConnected) {
                const header = new RequestResponseHeader_1.RequestResponseHeader(QubicPackageType_1.QubicPackageType.REQUEST_CURRENT_TICK_INFO);
                header.randomizeDejaVu();
                this.sendPackage(header.getPackageData());
              }
            }
            requestBalance(pkey) {
              if (!this.peerConnected)
                return;
              const header = new RequestResponseHeader_1.RequestResponseHeader(QubicPackageType_1.QubicPackageType.REQUEST_ENTITY, pkey.getPackageSize());
              header.randomizeDejaVu();
              const builder = new QubicPackageBuilder_1.QubicPackageBuilder(header.getSize());
              builder.add(header);
              builder.add(new QubicEntityRequest_1.QubicEntityRequest(pkey));
              const data = builder.getData();
              this.sendPackage(data);
            }
            GetPrivatePublicKey(seed) {
              return crypto_1.default.then(({ schnorrq, K12 }) => {
                const keyHelper = new keyHelper_1.KeyHelper();
                const privateKey = keyHelper.privateKey(seed, 0, K12);
                const publicKey = keyHelper.createPublicKey(privateKey, schnorrq, K12);
                return { privateKey, publicKey };
              });
            }
            initialize() {
              this.bufferReadPosition = 0;
              this.bufferWritePosition = 0;
              // start tick info interval to get current tick regularly
              this.timer = setInterval(() => {
                this.requestTickInfo();
              }, 500);
              if (!this.isNodeJs && this.webSocket) {
                this.webSocket.onmessage = (event) => {
                  const jsonData = JSON.parse(event.data);
                  if (jsonData.message === 'connect done') {
                    this.onPeerConnect();
                  }
                  else if (jsonData.message === 'disconnect done') {
                    if (this.onPeerDisconnected)
                      this.onPeerDisconnected();
                  }
                  else if (jsonData.message && jsonData.message.indexOf("ConnectionResetError") >= 0) {
                    // when the peer closes the conection this error occures. if we are publishing we want to reconnect now
                    this.reconnectPeer();
                  }
                  else if (jsonData.message === 'recv data') {
                    const byteArray = Uint8Array.from(atob(jsonData.data), c => c.charCodeAt(0));
                    this.writeBuffer(byteArray);
                  }
                };
                this.webSocket.onopen = () => {
                  this.isWsConnected = true;
                  if (this.onReady)
                    this.onReady();
                };
                this.webSocket.onclose = () => {
                  this.isWsConnected = false;
                  this.peerConnected = false;
                  if (this.onWsDisconnected)
                    this.onWsDisconnected();
                };
              }
              else if (this.socket) {
                if (this.onReady)
                  this.onReady();
              }
            }
            /**
             * connects to a specific peer
             * @param ip node/peer ip address
             */
            connect(ip) {
              this.connectPeer(ip);
            }
            sendPackage(data) {
              if (!this.isNodeJs) {
                return this.sendWsPackage(data);
              }
              else {
                return this.sendTcpPackage(data);
              }
            }
            sendWsPackage(data) {
              if (!this.isWsConnected || !this.peerConnected) {
                return false;
              }
              //console.log("REQUEST", data);
              this.webSocket?.send(JSON.stringify({
                command: 'sendb',
                data: this.toBase64(data)
              }));
              return true;
            }
            sendTcpPackage(data) {
              if (!this.peerConnected) {
                return false;
              }
              this.socket?.write(data);
              return true;
            }
            /**
             * starts the connection
             */
            start() {
              this.initialize();
            }
            /**
             * stops the web bridge ws connection
             */
            stop() {
              clearInterval(this.timer);
              this.disconnectPeer();
            }
            destroy() {
              this.stop();
              if (this.webSocket)
                this.webSocket.close();
              if (this.socket)
                this.socket.destroy(); // untested!
            }
          }
          exports.QubicConnector = QubicConnector;


          /***/
}),

/***/ "./src/QubicDefinitions.ts":
/*!*********************************!*\
  !*** ./src/QubicDefinitions.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.QubicDefinitions = void 0;
          class QubicDefinitions {
          }
          exports.QubicDefinitions = QubicDefinitions;
          QubicDefinitions.SIGNATURE_LENGTH = 64;
          QubicDefinitions.PUBLIC_KEY_LENGTH = 32;
          QubicDefinitions.MAX_TRANSACTION_SIZE = 1024;
          QubicDefinitions.DIGEST_LENGTH = 32;
          QubicDefinitions.SPECTRUM_DEPTH = 24;
          QubicDefinitions.NUMBER_OF_TRANSACTIONS_PER_TICK = 1024;
          QubicDefinitions.MAX_NUMBER_OF_CONTRACTS = 1024;
          // important addresses
          QubicDefinitions.EMPTY_ADDRESS = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFXIB";
          QubicDefinitions.ARBITRATOR_ADDRESS = "AFZPUAIYVPNUYGJRQVLUKOPPVLHAZQTGLYAAUUNBXFTVTAMSBKQBLEIEPCVJ";
          QubicDefinitions.DISPATCHER_ADDRESSS = "XPXYKFLGSWRHRGAUKWFWVXCDVEYAPCPCNUTMUDWFGDYQCWZNJMWFZEEGCFFO";
          QubicDefinitions.QX_ADDRESS = "BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARMID";
          // deprectaed/obsolete (only here for backward compatibility)
          QubicDefinitions.ARBITRATOR = "AFZPUAIYVPNUYGJRQVLUKOPPVLHAZQTGLYAAUUNBXFTVTAMSBKQBLEIEPCVJ";
          QubicDefinitions.QX_TRANSFER_ASSET_FEE = 100; // 100 Qubic's
          QubicDefinitions.QX_ISSUE_ASSET_FEE = 1000000000; // 1b Qubic's
          QubicDefinitions.QX_ISSUE_ASSET_INPUT_TYPE = 1; // input type for a tx to issue an asset
          QubicDefinitions.QX_TRANSFER_ASSET_INPUT_TYPE = 2; // input type for a tx to transfer an asset
          QubicDefinitions.QX_ADD_ASK_ORDER = 5; // input type for a tx to create an ask order
          QubicDefinitions.QX_ADD_BID_ORDER = 6; // input type for a tx to create a bid order
          QubicDefinitions.QX_REMOVE_ASK_ORDER = 7; // input type for a tx to remove an ask order
          QubicDefinitions.QX_REMOVE_BID_ORDER = 8; // input type for a tx to remove a bid order
          /* QUTIL SC */
          QubicDefinitions.QUTIL_ADDRESS = "EAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVWRF";
          QubicDefinitions.QUTIL_SENDMANY_INPUT_TYPE = 1; // input type for send many on Qutil
          QubicDefinitions.QUTIL_SENDMANY_FEE = 10; // fee in qubics for send many


          /***/
}),

/***/ "./src/QubicPackageBuilder.ts":
/*!************************************!*\
  !*** ./src/QubicPackageBuilder.ts ***!
  \************************************/
/***/ (function (__unused_webpack_module, exports, __webpack_require__) {

          "use strict";

          var __importDefault = (this && this.__importDefault) || function (mod) {
            return (mod && mod.__esModule) ? mod : { "default": mod };
          };
          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.QubicPackageBuilder = void 0;
          const QubicDefinitions_1 = __webpack_require__(/*! ./QubicDefinitions */ "./src/QubicDefinitions.ts");
          const crypto_1 = __importDefault(__webpack_require__(/*! ./crypto */ "./src/crypto/index.js"));
          const keyHelper_1 = __webpack_require__(/*! ./keyHelper */ "./src/keyHelper.ts");
          class QubicPackageBuilder {
            constructor(size) {
              this.offset = 0;
              // todo: create a dynamic builder
              this.packet = new Uint8Array(size);
            }
            getData() {
              return this.packet;
            }
            sign(seed) {
              return crypto_1.default.then(({ schnorrq, K12 }) => {
                const keyHelper = new keyHelper_1.KeyHelper();
                const privateKey = keyHelper.privateKey(seed, 0, K12);
                const publicKey = keyHelper.createPublicKey(privateKey, schnorrq, K12);
                const digest = new Uint8Array(QubicDefinitions_1.QubicDefinitions.DIGEST_LENGTH);
                const toSign = this.packet.slice(0, this.offset);
                K12(toSign, digest, QubicDefinitions_1.QubicDefinitions.DIGEST_LENGTH);
                const signatur = schnorrq.sign(privateKey, publicKey, digest);
                this.packet.set(signatur, this.offset);
                this.offset += QubicDefinitions_1.QubicDefinitions.SIGNATURE_LENGTH;
                return this.packet.slice(0, this.offset);
              });
            }
            signAndDigest(seed) {
              return crypto_1.default.then(({ schnorrq, K12 }) => {
                const keyHelper = new keyHelper_1.KeyHelper();
                const privateKey = keyHelper.privateKey(seed, 0, K12);
                const publicKey = keyHelper.createPublicKey(privateKey, schnorrq, K12);
                const digest = new Uint8Array(QubicDefinitions_1.QubicDefinitions.DIGEST_LENGTH);
                const toSign = this.packet.slice(0, this.offset);
                K12(toSign, digest, QubicDefinitions_1.QubicDefinitions.DIGEST_LENGTH);
                const signature = schnorrq.sign(privateKey, publicKey, digest);
                this.packet.set(signature, this.offset);
                this.offset += QubicDefinitions_1.QubicDefinitions.SIGNATURE_LENGTH;
                const signedData = this.packet.slice(0, this.offset);
                K12(signedData, digest, QubicDefinitions_1.QubicDefinitions.DIGEST_LENGTH);
                return {
                  signedData: signedData,
                  digest: digest,
                  signature: signature
                };
              });
            }
            add(q) {
              const data = q.getPackageData();
              this.packet.set(data, this.offset);
              this.offset += data.length;
              return this;
            }
            adduint8Array(q) {
              return this.addRaw(q);
            }
            addRaw(q) {
              this.packet.set(q, this.offset);
              this.offset += q.length;
              return this;
            }
            addShort(q /* must be a short */) {
              this.packet.set(this.FromShort(q), this.offset);
              this.offset += 2;
              return this;
            }
            addInt(q /* must be a short */) {
              this.packet.set(this.FromInt(q), this.offset);
              this.offset += 4;
              return this;
            }
            FromInt(num) {
              // If num is a 32-bit integer
              let buffer = new ArrayBuffer(4); // 4 bytes for a 32-bit integer
              let dataview = new DataView(buffer);
              dataview.setInt32(0, num, true); // Use setUint32 if you are dealing with unsigned integers
              return new Uint8Array(buffer);
            }
            FromShort(num) {
              // If num is a 32-bit integer
              let buffer = new ArrayBuffer(2); // 4 bytes for a 32-bit integer
              let dataview = new DataView(buffer);
              dataview.setInt16(0, num, true); // Use setUint32 if you are dealing with unsigned integers
              return new Uint8Array(buffer);
            }
          }
          exports.QubicPackageBuilder = QubicPackageBuilder;


          /***/
}),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function (__unused_webpack_module, exports, __webpack_require__) {

          "use strict";

          var __importDefault = (this && this.__importDefault) || function (mod) {
            return (mod && mod.__esModule) ? mod : { "default": mod };
          };
          Object.defineProperty(exports, "__esModule", ({ value: true }));
          // main accessors
          const QubicConnector_1 = __webpack_require__(/*! ./QubicConnector */ "./src/QubicConnector.ts");
          const QubicDefinitions_1 = __webpack_require__(/*! ./QubicDefinitions */ "./src/QubicDefinitions.ts");
          const qubicHelper_1 = __webpack_require__(/*! ./qubicHelper */ "./src/qubicHelper.ts");
          const QubicPackageBuilder_1 = __webpack_require__(/*! ./QubicPackageBuilder */ "./src/QubicPackageBuilder.ts");
          // types
          const DynamicPayload_1 = __webpack_require__(/*! ./qubic-types/DynamicPayload */ "./src/qubic-types/DynamicPayload.ts");
          const Long_1 = __webpack_require__(/*! ./qubic-types/Long */ "./src/qubic-types/Long.ts");
          const PublicKey_1 = __webpack_require__(/*! ./qubic-types/PublicKey */ "./src/qubic-types/PublicKey.ts");
          const QubicEntity_1 = __webpack_require__(/*! ./qubic-types/QubicEntity */ "./src/qubic-types/QubicEntity.ts");
          const QubicTickData_1 = __webpack_require__(/*! ./qubic-types/QubicTickData */ "./src/qubic-types/QubicTickData.ts");
          const QubicTickInfo_1 = __webpack_require__(/*! ./qubic-types/QubicTickInfo */ "./src/qubic-types/QubicTickInfo.ts");
          const QubicTransaction_1 = __webpack_require__(/*! ./qubic-types/QubicTransaction */ "./src/qubic-types/QubicTransaction.ts");
          const Signature_1 = __webpack_require__(/*! ./qubic-types/Signature */ "./src/qubic-types/Signature.ts");
          // transaction Payloads
          const QubicTransferAssetPayload_1 = __webpack_require__(/*! ./qubic-types/transacion-payloads/QubicTransferAssetPayload */ "./src/qubic-types/transacion-payloads/QubicTransferAssetPayload.ts");
          const QubicTransferSendManyPayload_1 = __webpack_require__(/*! ./qubic-types/transacion-payloads/QubicTransferSendManyPayload */ "./src/qubic-types/transacion-payloads/QubicTransferSendManyPayload.ts");
          // communication packages
          const QubicEntityRequest_1 = __webpack_require__(/*! ./qubic-communication/QubicEntityRequest */ "./src/qubic-communication/QubicEntityRequest.ts");
          const QubicEntityResponse_1 = __webpack_require__(/*! ./qubic-communication/QubicEntityResponse */ "./src/qubic-communication/QubicEntityResponse.ts");
          const QubicPackageType_1 = __webpack_require__(/*! ./qubic-communication/QubicPackageType */ "./src/qubic-communication/QubicPackageType.ts");
          const ReceivedPackage_1 = __webpack_require__(/*! ./qubic-communication/ReceivedPackage */ "./src/qubic-communication/ReceivedPackage.ts");
          const RequestResponseHeader_1 = __webpack_require__(/*! ./qubic-communication/RequestResponseHeader */ "./src/qubic-communication/RequestResponseHeader.ts");
          // crypto (base qubic library)
          const index_1 = __importDefault(__webpack_require__(/*! ./crypto/index */ "./src/crypto/index.js"));
          exports["default"] = {
            crypto: index_1.default,
            QubicEntityRequest: QubicEntityRequest_1.QubicEntityRequest,
            QubicEntityResponse: QubicEntityResponse_1.QubicEntityResponse,
            QubicPackageType: QubicPackageType_1.QubicPackageType,
            ReceivedPackage: ReceivedPackage_1.ReceivedPackage,
            RequestResponseHeader: RequestResponseHeader_1.RequestResponseHeader,
            DynamicPayload: DynamicPayload_1.DynamicPayload,
            Long: Long_1.Long,
            PublicKey: PublicKey_1.PublicKey,
            QubicEntity: QubicEntity_1.QubicEntity,
            QubicTickData: QubicTickData_1.QubicTickData,
            QubicTickInfo: QubicTickInfo_1.QubicTickInfo,
            QubicTransaction: QubicTransaction_1.QubicTransaction,
            Signature: Signature_1.Signature,
            QubicConnector: QubicConnector_1.QubicConnector,
            QubicDefinitions: QubicDefinitions_1.QubicDefinitions,
            QubicHelper: qubicHelper_1.QubicHelper,
            QubicPackageBuilder: QubicPackageBuilder_1.QubicPackageBuilder,
            QubicTransferAssetPayload: QubicTransferAssetPayload_1.QubicTransferAssetPayload,
            QubicTransferSendManyPayload: QubicTransferSendManyPayload_1.QubicTransferSendManyPayload
          };


          /***/
}),

/***/ "./src/keyHelper.ts":
/*!**************************!*\
  !*** ./src/keyHelper.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.KeyHelper = void 0;
          class KeyHelper {
            constructor() {
              this.SEED_ALPHABET = 'abcdefghijklmnopqrstuvwxyz';
              this.PRIVATE_KEY_LENGTH = 32;
              this.PUBLIC_KEY_LENGTH = 32;
              this.CHECKSUM_LENGTH = 3;
            }
            createPublicKey(privateKey, schnorrq, K12) {
              const publicKeyWithChecksum = new Uint8Array(this.PUBLIC_KEY_LENGTH + this.CHECKSUM_LENGTH);
              publicKeyWithChecksum.set(schnorrq.generatePublicKey(privateKey));
              K12(publicKeyWithChecksum.subarray(0, this.PUBLIC_KEY_LENGTH), publicKeyWithChecksum, this.CHECKSUM_LENGTH, this.PUBLIC_KEY_LENGTH);
              return publicKeyWithChecksum;
            }
            seedToBytes(seed) {
              const bytes = new Uint8Array(seed.length);
              for (let i = 0; i < seed.length; i++) {
                bytes[i] = this.SEED_ALPHABET.indexOf(seed[i]);
              }
              return bytes;
            }
            ;
            privateKey(seed, index, K12) {
              const byteSeed = this.seedToBytes(seed);
              const preimage = byteSeed.slice();
              while (index-- > 0) {
                for (let i = 0; i < preimage.length; i++) {
                  if (++preimage[i] > this.SEED_ALPHABET.length) {
                    preimage[i] = 1;
                  }
                  else {
                    break;
                  }
                }
              }
              const key = new Uint8Array(this.PRIVATE_KEY_LENGTH);
              K12(preimage, key, this.PRIVATE_KEY_LENGTH);
              return key;
            }
            ;
          }
          exports.KeyHelper = KeyHelper;
          KeyHelper.getIdentityBytes = function (identity) {
            const publicKeyBytes = new Uint8Array(32);
            const view = new DataView(publicKeyBytes.buffer, 0);
            for (let i = 0; i < 4; i++) {
              view.setBigUint64(i * 8, 0n, true);
              for (let j = 14; j-- > 0;) {
                view.setBigUint64(i * 8, view.getBigUint64(i * 8, true) * 26n + BigInt(identity.charCodeAt(i * 14 + j)) - BigInt('A'.charCodeAt(0)), true);
              }
            }
            return publicKeyBytes;
          };


          /***/
}),

/***/ "./src/qubic-communication/QubicEntityRequest.ts":
/*!*******************************************************!*\
  !*** ./src/qubic-communication/QubicEntityRequest.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.QubicEntityRequest = void 0;
          const QubicPackageBuilder_1 = __webpack_require__(/*! ../QubicPackageBuilder */ "./src/QubicPackageBuilder.ts");
          const PublicKey_1 = __webpack_require__(/*! ../qubic-types/PublicKey */ "./src/qubic-types/PublicKey.ts");
          const QubicDefinitions_1 = __webpack_require__(/*! ../QubicDefinitions */ "./src/QubicDefinitions.ts");
          /**
           * typedef struct
          * {
          *     unsigned char publicKey[32];
          * } RequestedEntity;
           */
          class QubicEntityRequest {
            getPublicKey() {
              return this.publicKey;
            }
            setPublicKey(publicKey) {
              this.publicKey = publicKey;
            }
            constructor(publicKey) {
              this._internalPackageSize = 32;
              this.publicKey = new PublicKey_1.PublicKey();
              if (publicKey !== undefined)
                this.setPublicKey(publicKey);
            }
            getPackageSize() {
              return this.getPackageData().length;
            }
            parse(data) {
              if (data.length !== this._internalPackageSize) {
                console.error("INVALID PACKAGE SIZE");
                return undefined;
              }
              this.setPublicKey(new PublicKey_1.PublicKey(data.slice(0, QubicDefinitions_1.QubicDefinitions.PUBLIC_KEY_LENGTH)));
              return this;
            }
            getPackageData() {
              const builder = new QubicPackageBuilder_1.QubicPackageBuilder(this._internalPackageSize);
              builder.add(this.publicKey);
              return builder.getData();
            }
          }
          exports.QubicEntityRequest = QubicEntityRequest;


          /***/
}),

/***/ "./src/qubic-communication/QubicEntityResponse.ts":
/*!********************************************************!*\
  !*** ./src/qubic-communication/QubicEntityResponse.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.QubicEntityResponse = void 0;
          const QubicPackageBuilder_1 = __webpack_require__(/*! ../QubicPackageBuilder */ "./src/QubicPackageBuilder.ts");
          const QubicEntity_1 = __webpack_require__(/*! ../qubic-types/QubicEntity */ "./src/qubic-types/QubicEntity.ts");
          /**
           * typedef struct
           * {
           *     unsigned char publicKey[32];
           *     long long incomingAmount, outgoingAmount;
           *     unsigned int numberOfIncomingTransfers, numberOfOutgoingTransfers;
           *     unsigned int latestIncomingTransferTick, latestOutgoingTransferTick;
           *     unsigned int tick;
           *     int spectrumIndex;
           *     unsigned char siblings[SPECTRUM_DEPTH][32];
           * } RespondedEntity;
           */
          class QubicEntityResponse {
            getEntity() {
              return this.entity;
            }
            setEntity(entity) {
              this.entity = entity;
            }
            getTick() {
              return this.tick;
            }
            setTick(tick) {
              this.tick = tick;
            }
            getSpectrumIndex() {
              return this.spectrumIndex;
            }
            setSpectrumIndex(spectrumIndex) {
              this.spectrumIndex = spectrumIndex;
            }
            getSiblings() {
              return this.siblings;
            }
            setSiblings(siblings) {
              this.siblings = siblings;
            }
            constructor() {
              this._internalPackageSize = 840;
              this.entity = new QubicEntity_1.QubicEntity();
              this.tick = 0;
              this.spectrumIndex = 0;
              this.siblings = new Uint8Array();
            }
            getPackageSize() {
              return this.getPackageData().length;
            }
            parse(data) {
              if (data.length !== this._internalPackageSize) {
                console.error("INVALID PACKAGE SIZE");
                return undefined;
              }
              const dataView = new DataView(data.buffer);
              let offset = 0;
              const entity = new QubicEntity_1.QubicEntity();
              if (entity.parse(data.slice(0, entity.getPackageSize())) !== undefined) {
                this.setEntity(entity);
                offset += entity.getPackageSize();
                this.setTick(dataView.getInt32(offset, true));
                offset += 4;
                this.setSpectrumIndex(dataView.getInt16(offset, true));
                offset += 4;
                this.setSiblings(data.slice(offset));
              }
              return this;
            }
            getPackageData() {
              const builder = new QubicPackageBuilder_1.QubicPackageBuilder(this._internalPackageSize);
              builder.add(this.entity);
              builder.addInt(this.tick);
              builder.addInt(this.spectrumIndex);
              builder.addRaw(this.siblings);
              return builder.getData();
            }
          }
          exports.QubicEntityResponse = QubicEntityResponse;


          /***/
}),

/***/ "./src/qubic-communication/QubicPackageType.ts":
/*!*****************************************************!*\
  !*** ./src/qubic-communication/QubicPackageType.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.QubicPackageType = void 0;
          class QubicPackageType {
          }
          exports.QubicPackageType = QubicPackageType;
          QubicPackageType.EXCHANGE_PUBLIC_PEER = 0;
          QubicPackageType.BROADCAST_MESSAGE = 1;
          QubicPackageType.BROADCAST_COMPUTORS = 2;
          QubicPackageType.BROADCAST_TICK = 3;
          QubicPackageType.BROADCAST_FUTURE_TICK_DATA = 8;
          QubicPackageType.REQUEST_COMPUTORS = 11;
          QubicPackageType.REQUEST_QUORUM_TICK = 14;
          QubicPackageType.REQUEST_TICK_DATA = 16;
          QubicPackageType.BROADCAST_TRANSACTION = 24;
          QubicPackageType.REQUEST_CURRENT_TICK_INFO = 27;
          QubicPackageType.RESPOND_CURRENT_TICK_INFO = 28;
          QubicPackageType.REQUEST_TICK_TRANSACTIONS = 29;
          QubicPackageType.REQUEST_ENTITY = 31;
          QubicPackageType.RESPOND_ENTITY = 32;
          QubicPackageType.REQUEST_CONTRACT_IPO = 33;
          QubicPackageType.RESPOND_CONTRACT_IPO = 34;
          QubicPackageType.REQUEST_ISSUED_ASSETS = 36;
          QubicPackageType.RESPOND_ISSUED_ASSETS = 37;
          QubicPackageType.REQUEST_OWNED_ASSETS = 38;
          QubicPackageType.RESPOND_OWNED_ASSETS = 39;
          QubicPackageType.REQUEST_POSSESSED_ASSETS = 39;
          QubicPackageType.RESPOND_POSSESSED_ASSETS = 40;
          QubicPackageType.PROCESS_SPECIAL_COMMAND = 255;


          /***/
}),

/***/ "./src/qubic-communication/ReceivedPackage.ts":
/*!****************************************************!*\
  !*** ./src/qubic-communication/ReceivedPackage.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.ReceivedPackage = void 0;
          class ReceivedPackage {
          }
          exports.ReceivedPackage = ReceivedPackage;


          /***/
}),

/***/ "./src/qubic-communication/RequestResponseHeader.ts":
/*!**********************************************************!*\
  !*** ./src/qubic-communication/RequestResponseHeader.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.RequestResponseHeader = void 0;
          class RequestResponseHeader {
            /**
             *
             * @param packageType type of the package to send (use QubicPackagetypes statics)
             * @param payloadSize size of the qubic package (header size is added automatically)
             */
            constructor(packageType = undefined, payloadSize = undefined) {
              this.size = 0;
              this.type = 0;
              this.dejaVu = 0;
              if (packageType !== undefined) {
                this.setType(packageType);
              }
              if (payloadSize !== undefined) {
                this.setSize(payloadSize + this.getPackageSize());
              }
              else {
                this.setSize(this.getPackageSize());
              }
            }
            setType(t) {
              this.type = t;
              return this;
            }
            getType() {
              return this.type;
            }
            setSize(t) {
              this.size = t;
              return this;
            }
            getSize() {
              return this.size;
            }
            setDejaVu(t) {
              this.dejaVu = t;
              return this;
            }
            getDejaVu() {
              return this.dejaVu;
            }
            randomizeDejaVu() {
              this.dejaVu = Math.floor(Math.random() * 2147483647);
            }
            getPackageSize() {
              return this.getPackageData().length;
            }
            parse(data) {
              if (data.length < 8) {
                console.error("INVALID PACKAGE SIZE");
                return undefined;
              }
              this.setSize((data[2] << 16) | (data[1] << 8) | data[0]);
              this.setType(data[3]);
              this.setDejaVu((data[2] << 24) | (data[2] << 16) | (data[1] << 8) | data[0]);
              return this;
            }
            getPackageData() {
              // validation of packet
              if (this.size > 16777215) {
                throw new Error("Size cannot be >16777215");
              }
              if (this.type > 255 || this.type < 0) {
                throw new Error("Type must be between 0 and 255");
              }
              var bytes = new Uint8Array(8).fill(0);
              let offset = 0;
              // generate size
              bytes[offset++] = this.size;
              bytes[offset++] = (this.size >> 8);
              bytes[offset++] = (this.size >> 16);
              bytes[offset++] = this.type;
              bytes[offset++] = this.dejaVu;
              bytes[offset++] = (this.dejaVu >> 8);
              bytes[offset++] = (this.dejaVu >> 16);
              bytes[offset++] = (this.dejaVu >> 24);
              return bytes;
            }
          }
          exports.RequestResponseHeader = RequestResponseHeader;


          /***/
}),

/***/ "./src/qubic-types/DynamicPayload.ts":
/*!*******************************************!*\
  !*** ./src/qubic-types/DynamicPayload.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.DynamicPayload = void 0;
          class DynamicPayload {
            /**
             * Create a dynamic payload
             * the maxSize should be set to the max expected size for this paload.
             */
            constructor(maxSize) {
              this.filledSize = 0;
              this.maxSize = 0;
              this.bytes = new Uint8Array(maxSize).fill(0);
              this.maxSize = maxSize;
            }
            setPayload(data) {
              if (data.length > this.maxSize)
                throw new Error("data must be lower or equal " + this.maxSize);
              this.bytes = data;
              this.filledSize = this.bytes.length;
            }
            getPackageData() {
              if (this.filledSize == 0)
                return new Uint8Array(0);
              return this.bytes;
            }
            getPackageSize() {
              return this.filledSize;
            }
          }
          exports.DynamicPayload = DynamicPayload;


          /***/
}),

/***/ "./src/qubic-types/Long.ts":
/*!*********************************!*\
  !*** ./src/qubic-types/Long.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.Long = void 0;
          class Long {
            constructor(initialValue = 0) {
              this.value = BigInt(0);
              if (typeof initialValue === "number") {
                this.setNumber(initialValue);
              }
              else if (initialValue instanceof Uint8Array) {
                const view = new DataView(initialValue.buffer, 0);
                this.setNumber(view.getBigUint64(0, true));
              }
              else if (initialValue !== undefined) {
                this.setNumber(initialValue);
              }
            }
            setNumber(n) {
              if (typeof n === "number")
                this.value = BigInt(n);
              else
                this.value = n;
            }
            getNumber() {
              return this.value;
            }
            getPackageSize() {
              return 8; // fixed size 
            }
            getPackageData() {
              let buffer = new ArrayBuffer(8);
              let dataview = new DataView(buffer);
              dataview.setBigInt64(0, this.value, true);
              return new Uint8Array(buffer);
            }
          }
          exports.Long = Long;


          /***/
}),

/***/ "./src/qubic-types/PublicKey.ts":
/*!**************************************!*\
  !*** ./src/qubic-types/PublicKey.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.PublicKey = void 0;
          const keyHelper_1 = __webpack_require__(/*! ../keyHelper */ "./src/keyHelper.ts");
          const QubicDefinitions_1 = __webpack_require__(/*! ../QubicDefinitions */ "./src/QubicDefinitions.ts");
          const qubicHelper_1 = __webpack_require__(/*! ../qubicHelper */ "./src/qubicHelper.ts");
          class PublicKey {
            constructor(identity = undefined) {
              this.bytes = new Uint8Array(QubicDefinitions_1.QubicDefinitions.PUBLIC_KEY_LENGTH).fill(0);
              this.identity = undefined;
              if (typeof identity === "string") {
                this.setIdentityFromString(identity);
              }
              else if (identity !== undefined) {
                this.setIdentity(identity);
              }
            }
            setIdentityFromString(id) {
              this.identity = id;
              this.setIdentity(keyHelper_1.KeyHelper.getIdentityBytes(id));
            }
            async setIdentity(bytes) {
              this.bytes = bytes;
              // convert byte to id
              this.identity = await new qubicHelper_1.QubicHelper().getIdentity(bytes);
            }
            getIdentity() {
              return this.bytes;
            }
            getIdentityAsSring() {
              return this.identity;
            }
            getPackageSize() {
              return this.bytes.length;
            }
            getPackageData() {
              return this.bytes;
            }
            equals(compare) {
              return compare && this.bytes.length === compare.bytes.length && this.bytes.every((value, index) => value === compare.bytes[index]);
            }
            async verifyIdentity() {
              return await new qubicHelper_1.QubicHelper().verifyIdentity(this.identity);
            }
          }
          exports.PublicKey = PublicKey;


          /***/
}),

/***/ "./src/qubic-types/QubicEntity.ts":
/*!****************************************!*\
  !*** ./src/qubic-types/QubicEntity.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.QubicEntity = void 0;
          const Long_1 = __webpack_require__(/*! ./Long */ "./src/qubic-types/Long.ts");
          const QubicPackageBuilder_1 = __webpack_require__(/*! ../QubicPackageBuilder */ "./src/QubicPackageBuilder.ts");
          const PublicKey_1 = __webpack_require__(/*! ./PublicKey */ "./src/qubic-types/PublicKey.ts");
          const QubicDefinitions_1 = __webpack_require__(/*! ../QubicDefinitions */ "./src/QubicDefinitions.ts");
          /**
           * typedef struct
           * {
           *     unsigned char publicKey[32];
           *     long long incomingAmount, outgoingAmount;
           *     unsigned int numberOfIncomingTransfers, numberOfOutgoingTransfers;
           *     unsigned int latestIncomingTransferTick, latestOutgoingTransferTick;
           * } Entity;
           */
          class QubicEntity {
            getPublicKey() {
              return this.publicKey;
            }
            setPublicKey(publicKey) {
              this.publicKey = publicKey;
            }
            getIncomingAmount() {
              return this.incomingAmount;
            }
            setIncomingAmount(incomingAcmount) {
              this.incomingAmount = incomingAcmount;
            }
            getOutgoingAmount() {
              return this.outgoingAmount;
            }
            setOutgoingAmount(outgoingAmount) {
              this.outgoingAmount = outgoingAmount;
            }
            getNumberOfIncomingTransfers() {
              return this.numberOfIncomingTransfers;
            }
            setNumberOfIncomingTransfers(numberOfIncomingTransfers) {
              this.numberOfIncomingTransfers = numberOfIncomingTransfers;
            }
            getNumberOfOutgoingTransfers() {
              return this.numberOfOutgoingTransfers;
            }
            setNumberOfOutgoingTransfers(numberOfOutgoingTransfers) {
              this.numberOfOutgoingTransfers = numberOfOutgoingTransfers;
            }
            getLatestIncomingTransferTick() {
              return this.latestIncomingTransferTick;
            }
            setLatestIncomingTransferTick(latestIncomingTransferTick) {
              this.latestIncomingTransferTick = latestIncomingTransferTick;
            }
            getLatestOutgoingTransferTick() {
              return this.latestOutgoingTransferTick;
            }
            setLatestOutgoingTransferTick(latestOutgoingTransferTick) {
              this.latestOutgoingTransferTick = latestOutgoingTransferTick;
            }
            constructor() {
              this._internalPackageSize = 64;
              this.publicKey = new PublicKey_1.PublicKey();
              this.incomingAmount = new Long_1.Long();
              this.outgoingAmount = new Long_1.Long();
              this.numberOfIncomingTransfers = 0;
              this.numberOfOutgoingTransfers = 0;
              this.latestIncomingTransferTick = 0;
              this.latestOutgoingTransferTick = 0;
            }
            getBalance() {
              return Number(this.getIncomingAmount().getNumber() - this.getOutgoingAmount().getNumber());
            }
            getPackageSize() {
              return this.getPackageData().length;
            }
            parse(data) {
              if (data.length !== this._internalPackageSize) {
                console.error("INVALID PACKAGE SIZE");
                return undefined;
              }
              const dataView = new DataView(data.buffer);
              let offset = 0;
              this.setPublicKey(new PublicKey_1.PublicKey(data.slice(0, QubicDefinitions_1.QubicDefinitions.PUBLIC_KEY_LENGTH)));
              offset += QubicDefinitions_1.QubicDefinitions.PUBLIC_KEY_LENGTH;
              this.setIncomingAmount(new Long_1.Long(dataView.getBigInt64(offset, true)));
              offset += 8;
              this.setOutgoingAmount(new Long_1.Long(dataView.getBigInt64(offset, true)));
              offset += 8;
              this.setNumberOfIncomingTransfers(dataView.getInt32(offset, true));
              offset += 4;
              this.setNumberOfOutgoingTransfers(dataView.getInt32(offset, true));
              offset += 4;
              this.setLatestIncomingTransferTick(dataView.getInt32(offset, true));
              offset += 4;
              this.setLatestOutgoingTransferTick(dataView.getInt32(offset, true));
              offset += 4;
              return this;
            }
            getPackageData() {
              const builder = new QubicPackageBuilder_1.QubicPackageBuilder(this._internalPackageSize);
              builder.add(this.publicKey);
              builder.add(this.incomingAmount);
              builder.add(this.outgoingAmount);
              builder.addInt(this.numberOfIncomingTransfers);
              builder.addInt(this.numberOfOutgoingTransfers);
              builder.addInt(this.latestIncomingTransferTick);
              builder.addInt(this.latestOutgoingTransferTick);
              return builder.getData();
            }
          }
          exports.QubicEntity = QubicEntity;


          /***/
}),

/***/ "./src/qubic-types/QubicTickData.ts":
/*!******************************************!*\
  !*** ./src/qubic-types/QubicTickData.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.QubicTickData = void 0;
          const QubicDefinitions_1 = __webpack_require__(/*! ../QubicDefinitions */ "./src/QubicDefinitions.ts");
          const Signature_1 = __webpack_require__(/*! ./Signature */ "./src/qubic-types/Signature.ts");
          /**
           * typedef struct
          {
              unsigned short computorIndex;
              unsigned short epoch;
              unsigned int tick;
          
              unsigned short millisecond;
              unsigned char second;
              unsigned char minute;
              unsigned char hour;
              unsigned char day;
              unsigned char month;
              unsigned char year;
          
              union
              {
                  struct
                  {
                      unsigned char uriSize;
                      unsigned char uri[255];
                  } proposal;
                  struct
                  {
                      unsigned char zero;
                      unsigned char votes[(NUMBER_OF_COMPUTORS * 3 + 7) / 8];
                      unsigned char quasiRandomNumber;
                  } ballot;
              } varStruct;
          
              unsigned char timelock[32];
              unsigned char transactionDigests[NUMBER_OF_TRANSACTIONS_PER_TICK][32];
              long long contractFees[MAX_NUMBER_OF_CONTRACTS];
          
              unsigned char signature[SIGNATURE_SIZE];
          } TickData;
           */
          class QubicTickData {
            get unionDataView() {
              if (!this._unionDataView)
                this._unionDataView = new DataView(this.unionData.buffer);
              return this._unionDataView;
            }
            set unionDataView(value) {
              this._unionDataView = value;
            }
            getSignature() {
              return this.signature;
            }
            setSignature(signature) {
              this.signature = signature;
            }
            getComputorIndex() {
              return this.computorIndex;
            }
            setComputorIndex(computorIndex) {
              this.computorIndex = computorIndex;
            }
            getEpoch() {
              return this.epoch;
            }
            setEpoch(epoch) {
              this.epoch = epoch;
            }
            getTick() {
              return this.tick;
            }
            setTick(tick) {
              this.tick = tick;
            }
            getMillisecond() {
              return this.millisecond;
            }
            setMillisecond(millisecond) {
              this.millisecond = millisecond;
            }
            getSecond() {
              return this.second;
            }
            setSecond(second) {
              this.second = second;
            }
            getMinute() {
              return this.minute;
            }
            setMinute(minute) {
              this.minute = minute;
            }
            getHour() {
              return this.hour;
            }
            setHour(hour) {
              this.hour = hour;
            }
            getDay() {
              return this.day;
            }
            setDay(day) {
              this.day = day;
            }
            getMonth() {
              return this.month;
            }
            setMonth(month) {
              this.month = month;
            }
            getYear() {
              return this.year;
            }
            setYear(year) {
              this.year = year;
            }
            getUnionData() {
              return this.unionData;
            }
            setUnionData(unionData) {
              this.unionData = unionData;
            }
            getTimeLock() {
              return this.timeLock;
            }
            setTimeLock(timeLock) {
              this.timeLock = timeLock;
            }
            // todo: implement
            // public getTransactionDigests(): Uint8Array[][] {
            //     return this.transactionDigests;
            // }
            setTransactionDigests(transactionDigests /* jagged array 1024x32 */) {
              this.transactionDigests = transactionDigests;
            }
            getContractFees() {
              return this.contractFees;
            }
            setContractFees(contractFees) {
              this.contractFees = contractFees;
            }
            /* union data types */
            getProposalUriSize() {
              return this.unionData[0];
            }
            setProposalUriSize(size) {
              this.unionData[0] = size;
            }
            getProposalUri() {
              return new TextDecoder().decode(this.unionData.slice(1, this.getProposalUriSize()));
            }
            setProposalUri(uri) {
              if (uri.length > 255) {
                console.error("URI SIZE MUST BE MAX 255");
                throw "URI SIZE MUST BE MAX 255";
              }
              const bytes = new TextEncoder().encode(uri);
              this.unionData.set(bytes, 1);
              this.setProposalUriSize(uri.length);
            }
            constructor() {
              this._internalPackageSize = 41328;
            }
            getPackageSize() {
              return this._internalPackageSize;
            }
            parse(data) {
              if (data.length !== this._internalPackageSize) {
                console.error("INVALID PACKAGE SIZE");
                return undefined;
              }
              const dataView = new DataView(data.buffer);
              let offset = 0;
              this.setComputorIndex(dataView.getUint16(offset, true));
              offset += 2;
              this.setEpoch(dataView.getUint16(offset, true));
              offset += 2;
              this.setTick(dataView.getUint32(offset, true));
              offset += 4;
              this.setMillisecond(dataView.getUint16(offset, true));
              offset += 2;
              this.setSecond(data[offset++]);
              this.setMinute(data[offset++]);
              this.setHour(data[offset++]);
              this.setDay(data[offset++]);
              this.setMonth(data[offset++]);
              this.setYear(data[offset++]);
              this.setUnionData(data.slice(offset, 256));
              offset += 256;
              this.setTimeLock(data.slice(offset, 32));
              offset += 32;
              this.setTransactionDigests(data.slice(offset, QubicDefinitions_1.QubicDefinitions.NUMBER_OF_TRANSACTIONS_PER_TICK * QubicDefinitions_1.QubicDefinitions.DIGEST_LENGTH));
              offset += QubicDefinitions_1.QubicDefinitions.NUMBER_OF_TRANSACTIONS_PER_TICK * QubicDefinitions_1.QubicDefinitions.DIGEST_LENGTH;
              const contractFees = [];
              for (let i = 0; i < QubicDefinitions_1.QubicDefinitions.MAX_NUMBER_OF_CONTRACTS; i++) {
                contractFees.push(dataView.getBigInt64(offset, true));
                offset += 8;
              }
              this.setContractFees(contractFees);
              this.setSignature(new Signature_1.Signature(data.slice(offset, QubicDefinitions_1.QubicDefinitions.SIGNATURE_LENGTH)));
              offset += QubicDefinitions_1.QubicDefinitions.SIGNATURE_LENGTH;
              return this;
            }
            getPackageData() {
              // todo: implement
              return new Uint8Array();
            }
          }
          exports.QubicTickData = QubicTickData;


          /***/
}),

/***/ "./src/qubic-types/QubicTickInfo.ts":
/*!******************************************!*\
  !*** ./src/qubic-types/QubicTickInfo.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.QubicTickInfo = void 0;
          const QubicPackageBuilder_1 = __webpack_require__(/*! ../QubicPackageBuilder */ "./src/QubicPackageBuilder.ts");
          /**
           * typedef struct
          * {
          *     unsigned short tickDuration;
          *     unsigned short epoch;
          *     unsigned int tick;
          *     unsigned short numberOfAlignedVotes;
          *     unsigned short numberOfMisalignedVotes;
          * } CurrentTickInfo;
           */
          class QubicTickInfo {
            getTickDuration() {
              return this.tickDuration;
            }
            setTickDuration(tickDuration) {
              this.tickDuration = tickDuration;
            }
            getEpoch() {
              return this.epoch;
            }
            setEpoch(epoch) {
              this.epoch = epoch;
            }
            getTick() {
              return this.tick;
            }
            setTick(tick) {
              this.tick = tick;
            }
            getNumberOfAlignedVotes() {
              return this.numberOfAlignedVotes;
            }
            setNumberOfAlignedVotes(numberOfAlignedVotes) {
              this.numberOfAlignedVotes = numberOfAlignedVotes;
            }
            getNumberOfMisalignedVotes() {
              return this.numberOfMisalignedVotes;
            }
            setNumberOfMisalignedVotes(numberOfMisalignedVotes) {
              this.numberOfMisalignedVotes = numberOfMisalignedVotes;
            }
            getInitialTick() {
              return this.initialTick;
            }
            setInitialTick(tick) {
              this.initialTick = tick;
            }
            constructor() {
              this._internalPackageSize = 16;
              this.tickDuration = 0;
              this.epoch = 0;
              this.tick = 0;
              this.numberOfAlignedVotes = 0;
              this.numberOfMisalignedVotes = 0;
              this.initialTick = 0;
            }
            getPackageSize() {
              return this.getPackageData().length;
            }
            parse(data) {
              if (data.length !== this._internalPackageSize) {
                console.error("INVALID PACKAGE SIZE");
                return undefined;
              }
              const dataView = new DataView(data.buffer);
              let offset = 0;
              this.setTickDuration(dataView.getInt16(0, true));
              offset += 2;
              this.setEpoch(dataView.getInt16(offset, true));
              offset += 2;
              this.setTick(dataView.getInt32(offset, true));
              offset += 4;
              this.setNumberOfAlignedVotes(dataView.getInt16(offset, true));
              offset += 2;
              this.setNumberOfMisalignedVotes(dataView.getInt16(offset, true));
              offset += 2;
              this.setInitialTick(dataView.getInt32(offset, true));
              return this;
            }
            getPackageData() {
              const builder = new QubicPackageBuilder_1.QubicPackageBuilder(this._internalPackageSize);
              builder.addShort(this.tickDuration);
              builder.addShort(this.epoch);
              builder.addInt(this.tick);
              builder.addShort(this.numberOfAlignedVotes);
              builder.addShort(this.numberOfMisalignedVotes);
              builder.addInt(this.initialTick);
              return builder.getData();
            }
          }
          exports.QubicTickInfo = QubicTickInfo;


          /***/
}),

/***/ "./src/qubic-types/QubicTransaction.ts":
/*!*********************************************!*\
  !*** ./src/qubic-types/QubicTransaction.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.QubicTransaction = void 0;
          const qubicHelper_1 = __webpack_require__(/*! ../qubicHelper */ "./src/qubicHelper.ts");
          const DynamicPayload_1 = __webpack_require__(/*! ./DynamicPayload */ "./src/qubic-types/DynamicPayload.ts");
          const Long_1 = __webpack_require__(/*! ./Long */ "./src/qubic-types/Long.ts");
          const QubicPackageBuilder_1 = __webpack_require__(/*! ../QubicPackageBuilder */ "./src/QubicPackageBuilder.ts");
          const PublicKey_1 = __webpack_require__(/*! ./PublicKey */ "./src/qubic-types/PublicKey.ts");
          const QubicDefinitions_1 = __webpack_require__(/*! ../QubicDefinitions */ "./src/QubicDefinitions.ts");
          const Signature_1 = __webpack_require__(/*! ./Signature */ "./src/qubic-types/Signature.ts");
          /**
           * C+S Struct
           * typedef struct
           * {
           *  unsigned char sourcePublicKey[32];
           *  unsigned char destinationPublicKey[32];
           *  long long amount;
           *  unsigned int tick;
           *  unsigned short inputType;
           *  unsigned short inputSize;
           * } Transaction;
           */
          class QubicTransaction {
            constructor() {
              // todo: create getter/setter
              this.sourcePublicKey = new PublicKey_1.PublicKey();
              this.destinationPublicKey = new PublicKey_1.PublicKey();
              this.amount = new Long_1.Long();
              this.tick = 0;
              this.inputType = 0;
              this.inputSize = 0;
              this.payload = new DynamicPayload_1.DynamicPayload(QubicDefinitions_1.QubicDefinitions.MAX_TRANSACTION_SIZE);
              this.signature = new Signature_1.Signature();
            }
            setSourcePublicKey(p) {
              if (p instanceof PublicKey_1.PublicKey)
                this.sourcePublicKey = p;
              else
                this.sourcePublicKey = new PublicKey_1.PublicKey(p);
              return this;
            }
            setDestinationPublicKey(p) {
              if (p instanceof PublicKey_1.PublicKey)
                this.destinationPublicKey = p;
              else
                this.destinationPublicKey = new PublicKey_1.PublicKey(p);
              return this;
            }
            setAmount(p) {
              if (p instanceof Long_1.Long)
                this.amount = p;
              else
                this.amount = new Long_1.Long(p);
              return this;
            }
            setTick(p) {
              this.tick = p;
              return this;
            }
            setInputType(p) {
              this.inputType = p;
              return this;
            }
            setInputSize(p) {
              this.inputSize = p;
              return this;
            }
            setPayload(payload) {
              this.payload = payload;
              this.inputSize = this.payload.getPackageSize();
              return this;
            }
            getPayload() {
              return this.payload;
            }
            _internalSize() {
              return this.sourcePublicKey.getPackageSize()
                + this.destinationPublicKey.getPackageSize()
                + this.amount.getPackageSize()
                + 4 // tick
                + 2 // inputType
                + 2 // inputSize
                + this.inputSize
                + this.signature.getPackageSize();
            }
            getPackageSize() {
              return this._internalSize();
            }
            getId() {
              if (!this.id) {
                console.error("CALL build() BEFORE USING getId() METHOD");
                return "";
              }
              return this.id;
            }
            /**
             * builds the transaction to be sent
             * includes signing with seed
             *
             * @param seed the seed to be used to sign this transacion. the seed should be the same as the sourcePublicKey
             * @returns a complete transaction package
             */
            async build(seed) {
              this.builtData = undefined;
              var builder = new QubicPackageBuilder_1.QubicPackageBuilder(this._internalSize());
              builder.add(this.sourcePublicKey);
              builder.add(this.destinationPublicKey);
              builder.add(this.amount);
              builder.addInt(this.tick);
              builder.addShort(this.inputType);
              builder.addShort(this.inputSize);
              builder.add(this.payload);
              const { signedData, digest, signature } = await builder.signAndDigest(seed);
              this.builtData = signedData;
              this.digest = digest;
              this.signature = new Signature_1.Signature(signature);
              this.id = await new qubicHelper_1.QubicHelper().getHumanReadableBytes(digest);
              return signedData;
            }
            /**
             * The result of build() must be passed through this function,
             * as the `broadcast-transaction` endpoint expects the transaction to be Base64 encoded.
             */
            encodeTransactionToBase64(transaction) {
              const byteArray = new Uint8Array(transaction);
              const str = String.fromCharCode.apply(null, byteArray);
              return btoa(str);
            }
            getPackageData() {
              if (!this.builtData) {
                console.error("CALL build() BEFORE USING getPackageData() METHOD");
              }
              return this.builtData ?? new Uint8Array();
            }
          }
          exports.QubicTransaction = QubicTransaction;


          /***/
}),

/***/ "./src/qubic-types/Signature.ts":
/*!**************************************!*\
  !*** ./src/qubic-types/Signature.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.Signature = void 0;
          const QubicDefinitions_1 = __webpack_require__(/*! ../QubicDefinitions */ "./src/QubicDefinitions.ts");
          class Signature {
            constructor(data = undefined) {
              this.bytes = new Uint8Array(QubicDefinitions_1.QubicDefinitions.SIGNATURE_LENGTH).fill(0);
              if (data) {
                this.setSignature(data);
              }
            }
            setSignature(bytes) {
              this.bytes = bytes;
            }
            getPackageData() {
              return this.bytes;
            }
            getPackageSize() {
              return this.bytes.length;
            }
          }
          exports.Signature = Signature;


          /***/
}),

/***/ "./src/qubic-types/transacion-payloads/QubicTransferAssetPayload.ts":
/*!**************************************************************************!*\
  !*** ./src/qubic-types/transacion-payloads/QubicTransferAssetPayload.ts ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.QubicTransferAssetPayload = void 0;
          const QubicPackageBuilder_1 = __webpack_require__(/*! ../../QubicPackageBuilder */ "./src/QubicPackageBuilder.ts");
          const DynamicPayload_1 = __webpack_require__(/*! ../DynamicPayload */ "./src/qubic-types/DynamicPayload.ts");
          const Long_1 = __webpack_require__(/*! ../Long */ "./src/qubic-types/Long.ts");
          const PublicKey_1 = __webpack_require__(/*! ../PublicKey */ "./src/qubic-types/PublicKey.ts");
          const qubicHelper_1 = __webpack_require__(/*! ../../qubicHelper */ "./src/qubicHelper.ts");
          /**
           *
           * Transaction Payload to transfer an Asset
           *
           * typedef struct
          * {
          *     uint8_t issuer[32];
          *     uint8_t newOwnerAndPossessor[32];
          *     unsigned long long assetName;
          *     long long numberOfUnits;
          * } TransferAssetOwnershipAndPossession_input;
           *
           *
           *
           */
          class QubicTransferAssetPayload {
            constructor() {
              this._internalPackageSize = 32 + 32 + 8 + 8;
            }
            // todo: think about adding getters
            setIssuer(issuer) {
              if (typeof issuer === "string") {
                this.issuer = new PublicKey_1.PublicKey(issuer);
              }
              else {
                this.issuer = issuer;
              }
              return this;
            }
            setNewOwnerAndPossessor(newOwnerAndPossessor) {
              if (typeof newOwnerAndPossessor === "string") {
                this.newOwnerAndPossessor = new PublicKey_1.PublicKey(newOwnerAndPossessor);
              }
              else {
                this.newOwnerAndPossessor = newOwnerAndPossessor;
              }
              return this;
            }
            setAssetName(assetName) {
              if (typeof assetName === "string") {
                const utf8Encode = new TextEncoder();
                const nameBytes = utf8Encode.encode(assetName);
                this.assetName = new Uint8Array(8);
                nameBytes.forEach((b, i) => {
                  this.assetName[i] = b;
                });
              }
              else {
                this.assetName = assetName;
              }
              return this;
            }
            getAssetName() {
              return this.assetName;
            }
            getIssuer() {
              return this.issuer;
            }
            getNewOwnerAndPossessor() {
              return this.newOwnerAndPossessor;
            }
            getNumberOfUnits() {
              return this.numberOfUnits;
            }
            setNumberOfUnits(numberOfUnits) {
              if (typeof numberOfUnits === "number") {
                this.numberOfUnits = new Long_1.Long(numberOfUnits);
              }
              else {
                this.numberOfUnits = numberOfUnits;
              }
              return this;
            }
            getPackageSize() {
              return this._internalPackageSize;
            }
            getPackageData() {
              const builder = new QubicPackageBuilder_1.QubicPackageBuilder(this.getPackageSize());
              builder.add(this.issuer);
              builder.add(this.newOwnerAndPossessor);
              builder.addRaw(this.assetName);
              builder.add(this.numberOfUnits);
              return builder.getData();
            }
            getTransactionPayload() {
              const payload = new DynamicPayload_1.DynamicPayload(this.getPackageSize());
              payload.setPayload(this.getPackageData());
              return payload;
            }
            async parse(data) {
              if (data.length !== this._internalPackageSize) {
                console.error("INVALID PACKAGE SIZE");
                return undefined;
              }
              const helper = new qubicHelper_1.QubicHelper();
              let start = 0;
              let end = 32; // size for issuer and newOwnerAndPossessor
              this.issuer = new PublicKey_1.PublicKey(await helper.getIdentity(data.slice(start, end)));
              start = end;
              end = start + 32; // size for newOwnerAndPossessor
              this.newOwnerAndPossessor = new PublicKey_1.PublicKey(await helper.getIdentity(data.slice(start, end)));
              start = end;
              end = start + 8; // size for asset name
              this.assetName = data.slice(start, end);
              let decoder = new TextDecoder(); // Create a TextDecoder for UTF-8 by default
              const result = decoder.decode(this.assetName); // Convert Uint8Array to string
              start = end;
              end = start + 8; // size for number of units
              this.numberOfUnits = new Long_1.Long(data.slice(start, end));
              return this;
            }
          }
          exports.QubicTransferAssetPayload = QubicTransferAssetPayload;


          /***/
}),

/***/ "./src/qubic-types/transacion-payloads/QubicTransferSendManyPayload.ts":
/*!*****************************************************************************!*\
  !*** ./src/qubic-types/transacion-payloads/QubicTransferSendManyPayload.ts ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

          "use strict";

          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.QubicTransferSendManyPayload = void 0;
          const QubicDefinitions_1 = __webpack_require__(/*! ../../QubicDefinitions */ "./src/QubicDefinitions.ts");
          const QubicPackageBuilder_1 = __webpack_require__(/*! ../../QubicPackageBuilder */ "./src/QubicPackageBuilder.ts");
          const qubicHelper_1 = __webpack_require__(/*! ../../qubicHelper */ "./src/qubicHelper.ts");
          const DynamicPayload_1 = __webpack_require__(/*! ../DynamicPayload */ "./src/qubic-types/DynamicPayload.ts");
          const Long_1 = __webpack_require__(/*! ../Long */ "./src/qubic-types/Long.ts");
          const PublicKey_1 = __webpack_require__(/*! ../PublicKey */ "./src/qubic-types/PublicKey.ts");
          /**
           *
           * Transaction Payload to use Qutil/SendMany SC
           *
           * struct SendToManyV1_input {
           *   uint8_t addresses[25][32];
           *   int64_t amounts[25];
           * };
           *
           *
           *
           */
          class QubicTransferSendManyPayload {
            constructor() {
              this._internalPackageSize = 1000; /* 25 * 32  + 25 * 8 */
              // max 25 transfers allowed
              this.sendManyTransfers = [];
            }
            addTransfer(transfer) {
              if (this.sendManyTransfers.length < 25) {
                this.sendManyTransfers.push(transfer);
              }
              else {
                throw new Error("max 25 send many transfers allowed");
              }
              return this;
            }
            addTranfers(transfers) {
              if (this.sendManyTransfers.length + transfers.length > 25) {
                throw new Error("max 25 send many transfers allowed");
              }
              transfers.forEach((transfer) => {
                this.addTransfer(transfer);
              });
              return this;
            }
            /**
             *
             * @returns the transfers for this send many request
             */
            getTransfers() {
              return this.sendManyTransfers;
            }
            /**
             * the acumulated amount of all transfers
             * @returns
             *
             */
            getTotalAmount() {
              return this.sendManyTransfers.reduce((a, b) => (a += b && b.amount ? b.amount.getNumber() : BigInt(0)), BigInt(0));
            }
            getPackageSize() {
              return this._internalPackageSize;
            }
            getPackageData() {
              const builder = new QubicPackageBuilder_1.QubicPackageBuilder(this.getPackageSize());
              for (let i = 0; i < 25; i++) {
                if (this.sendManyTransfers.length > i &&
                  this.sendManyTransfers[i].amount.getNumber() > 0) {
                  builder.add(this.sendManyTransfers[i].destId);
                }
                else {
                  builder.add(new PublicKey_1.PublicKey(QubicDefinitions_1.QubicDefinitions.EMPTY_ADDRESS)); // add empty address to have 0 in byte
                }
              }
              for (let i = 0; i < 25; i++) {
                if (this.sendManyTransfers.length > i &&
                  this.sendManyTransfers[i].amount.getNumber() > 0) {
                  const amount = this.sendManyTransfers[i].amount;
                  if (typeof amount === "number") {
                    builder.add(new Long_1.Long(amount));
                  }
                  else {
                    builder.add(amount);
                  }
                }
                else {
                  builder.add(new Long_1.Long(0));
                }
              }
              return builder.getData();
            }
            getTransactionPayload() {
              const payload = new DynamicPayload_1.DynamicPayload(this.getPackageSize());
              payload.setPayload(this.getPackageData());
              return payload;
            }
            /**
             * parses raw binary package to js object
             * @param data raw send many input (payload)
             * @returns QubicTransferSendManyPayload
             */
            async parse(data) {
              if (data.length !== this._internalPackageSize) {
                console.error("INVALID PACKAGE SIZE");
                return undefined;
              }
              const helper = new qubicHelper_1.QubicHelper();
              const sendManyTransfers = [];
              // a send many tx can have maximum 25 recipients
              for (let i = 0; i < 25; i++) {
                // get the amount for the transfer
                const amount = new Long_1.Long(data.slice(800 + i * 8, 800 + i * 8 + 8));
                // only add transfer to output array if amount > 0; 0 or lower means, no transfer
                if (amount.getNumber() > 0) {
                  const dest = data.slice(32 * i, 32 * i + 32);
                  this.sendManyTransfers.push({
                    amount: amount,
                    destId: new PublicKey_1.PublicKey(await helper.getIdentity(dest)),
                  });
                }
              }
              this.addTranfers(sendManyTransfers);
              return this;
            }
          }
          exports.QubicTransferSendManyPayload = QubicTransferSendManyPayload;


          /***/
}),

/***/ "./src/qubicHelper.ts":
/*!****************************!*\
  !*** ./src/qubicHelper.ts ***!
  \****************************/
/***/ (function (__unused_webpack_module, exports, __webpack_require__) {

          "use strict";

          /*
          
          Permission is hereby granted, perpetual, worldwide, non-exclusive, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
          to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
          and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
          
          
            1. The Software cannot be used in any form or in any substantial portions for development, maintenance and for any other purposes, in the military sphere and in relation to military products,
            including, but not limited to:
          
              a. any kind of armored force vehicles, missile weapons, warships, artillery weapons, air military vehicles (including military aircrafts, combat helicopters, military drones aircrafts),
              air defense systems, rifle armaments, small arms, firearms and side arms, melee weapons, chemical weapons, weapons of mass destruction;
          
              b. any special software for development technical documentation for military purposes;
          
              c. any special equipment for tests of prototypes of any subjects with military purpose of use;
          
              d. any means of protection for conduction of acts of a military nature;
          
              e. any software or hardware for determining strategies, reconnaissance, troop positioning, conducting military actions, conducting special operations;
          
              f. any dual-use products with possibility to use the product in military purposes;
          
              g. any other products, software or services connected to military activities;
          
              h. any auxiliary means related to abovementioned spheres and products.
          
          
            2. The Software cannot be used as described herein in any connection to the military activities. A person, a company, or any other entity, which wants to use the Software,
            shall take all reasonable actions to make sure that the purpose of use of the Software cannot be possibly connected to military purposes.
          
          
            3. The Software cannot be used by a person, a company, or any other entity, activities of which are connected to military sphere in any means. If a person, a company, or any other entity,
            during the period of time for the usage of Software, would engage in activities, connected to military purposes, such person, company, or any other entity shall immediately stop the usage
            of Software and any its modifications or alterations.
          
          
            4. Abovementioned restrictions should apply to all modification, alteration, merge, and to other actions, related to the Software, regardless of how the Software was changed due to the
            abovementioned actions.
          
          
          The above copyright notice and this permission notice shall be included in all copies or substantial portions, modifications and alterations of the Software.
          
          
          THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
          IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH
          THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
          
          */
          var __importDefault = (this && this.__importDefault) || function (mod) {
            return (mod && mod.__esModule) ? mod : { "default": mod };
          };
          Object.defineProperty(exports, "__esModule", ({ value: true }));
          exports.QubicHelper = void 0;
          const crypto_1 = __importDefault(__webpack_require__(/*! ./crypto */ "./src/crypto/index.js"));
          const converter_js_1 = __webpack_require__(/*! ./converter/converter.js */ "./src/converter/converter.js");
          const bignumber_js_1 = __importDefault(__webpack_require__(/*! bignumber.js */ "./node_modules/bignumber.js/bignumber.js"));
          const QubicDefinitions_1 = __webpack_require__(/*! ./QubicDefinitions */ "./src/QubicDefinitions.ts");
          // todo: refactor
          /**
           * this class contains a lot of legacy code and should be refactored
           */
          class QubicHelper {
            constructor() {
              this.SEED_ALPHABET = 'abcdefghijklmnopqrstuvwxyz';
              this.SHIFTED_HEX_CHARS = 'abcdefghijklmnop';
              this.PRIVATE_KEY_LENGTH = 32;
              this.PUBLIC_KEY_LENGTH = 32;
              this.SEED_IN_LOWERCASE_LATIN_LENGTH = 55;
              this.CHECKSUM_LENGTH = 3;
              this.getIdentityBytes = function (identity) {
                const publicKeyBytes = new Uint8Array(32);
                const view = new DataView(publicKeyBytes.buffer, 0);
                for (let i = 0; i < 4; i++) {
                  view.setBigUint64(i * 8, 0n, true);
                  for (let j = 14; j-- > 0;) {
                    view.setBigUint64(i * 8, view.getBigUint64(i * 8, true) * 26n + BigInt(identity.charCodeAt(i * 14 + j)) - BigInt('A'.charCodeAt(0)), true);
                  }
                }
                return publicKeyBytes;
              };
              this.REQUEST_RESPONSE_HEADER_SIZE = 8;
              this.TRANSACTION_SIZE = 144;
              this.IPO_TRANSACTION_SIZE = 144 + 8 /*price*/ + 2 /* quantity */ + 6 /* padding */;
              this.SET_PROPOSAL_AND_BALLOT_REQUEST_SIZE = 592;
              this.TRANSACTION_INPUT_SIZE_OFFSET = 0;
              this.TRANSACTION_INPUT_SIZE_LENGTH = 0;
              this.SIGNATURE_LENGTH = 64;
              this.DIGEST_LENGTH = 32;
              this.SPECIAL_COMMAND_SHUT_DOWN = 0;
              this.SPECIAL_COMMAND_GET_PROPOSAL_AND_BALLOT_REQUEST = 1;
              this.SPECIAL_COMMAND_GET_PROPOSAL_AND_BALLOT_RESPONSE = 2;
              this.SPECIAL_COMMAND_SET_PROPOSAL_AND_BALLOT_REQUEST = 3;
              this.SPECIAL_COMMAND_SET_PROPOSAL_AND_BALLOT_RESPONSE = 4;
              this.PROCESS_SPECIAL_COMMAND = 255;
            }
            /**
             *
             * Creates a complete ID Package based on the provided seed
             *
             * @param seed
             * @returns
             */
            async createIdPackage(seed) {
              const { schnorrq, K12 } = await crypto_1.default;
              const privateKey = this.privateKey(seed, 0, K12);
              const publicKey = schnorrq.generatePublicKey(privateKey);
              const publicId = await this.getIdentity(publicKey);
              return { publicKey, privateKey, publicId };
            }
            /**
             * creates the checksum for a given key
             *
             * @param publicKey
             * @returns
             */
            async getCheckSum(publicKey) {
              const { K12 } = await crypto_1.default;
              const digest = new Uint8Array(QubicDefinitions_1.QubicDefinitions.DIGEST_LENGTH);
              K12(publicKey, digest, QubicDefinitions_1.QubicDefinitions.DIGEST_LENGTH);
              const checksum = digest.slice(0, this.CHECKSUM_LENGTH);
              return checksum;
            }
            /**
             *
             * Creates the human readable public key from the publickey
             *
             * @param publicKey
             * @param lowerCase
             * @returns
             */
            async getIdentity(publicKey, lowerCase = false) {
              let newId = '';
              for (let i = 0; i < 4; i++) {
                let longNUmber = new bignumber_js_1.default(0);
                longNUmber.decimalPlaces(0);
                publicKey.slice(i * 8, (i + 1) * 8).forEach((val, index) => {
                  longNUmber = longNUmber.plus(new bignumber_js_1.default((val * 256 ** index).toString(2), 2));
                });
                for (let j = 0; j < 14; j++) {
                  newId += String.fromCharCode(longNUmber.mod(26).plus((lowerCase ? 'a' : 'A').charCodeAt(0)).toNumber());
                  longNUmber = longNUmber.div(26);
                }
              }
              // calculate checksum
              const checksum = await this.getCheckSum(publicKey);
              // convert to int
              let identityBytesChecksum = (checksum[2] << 16) | (checksum[1] << 8) | checksum[0];
              identityBytesChecksum = identityBytesChecksum & 0x3FFFF;
              for (let i = 0; i < 4; i++) {
                newId += String.fromCharCode(identityBytesChecksum % 26 + (lowerCase ? 'a' : 'A').charCodeAt(0));
                identityBytesChecksum = identityBytesChecksum / 26;
              }
              return newId;
            }
            async getHumanReadableBytes(publicKey) {
              return await this.getIdentity(publicKey, true);
            }
            seedToBytes(seed) {
              const bytes = new Uint8Array(seed.length);
              for (let i = 0; i < seed.length; i++) {
                bytes[i] = this.SEED_ALPHABET.indexOf(seed[i]);
              }
              return bytes;
            }
            ;
            privateKey(seed, index, K12) {
              const byteSeed = this.seedToBytes(seed);
              const preimage = byteSeed.slice();
              while (index-- > 0) {
                for (let i = 0; i < preimage.length; i++) {
                  if (++preimage[i] > this.SEED_ALPHABET.length) {
                    preimage[i] = 1;
                  }
                  else {
                    break;
                  }
                }
              }
              const key = new Uint8Array(this.PRIVATE_KEY_LENGTH);
              K12(preimage, key, this.PRIVATE_KEY_LENGTH);
              return key;
            }
            ;
            /**
             * Verifies if a given identity is valid
             * @param identity
             */
            async verifyIdentity(identity) {
              if (!identity || identity.length != 60 || !/^[A-Z]+$/.test(identity)) // must be 60 upper case characters
                return false;
              const publicKey = this.getIdentityBytes(identity);
              const idFromBytes = await this.getIdentity(publicKey);
              // todo: it would be enough to just check checksum bytes instead of compare complete id
              return identity === idFromBytes;
            }
            createPublicKey(privateKey, schnorrq, K12) {
              const publicKeyWithChecksum = new Uint8Array(this.PUBLIC_KEY_LENGTH + this.CHECKSUM_LENGTH);
              publicKeyWithChecksum.set(schnorrq.generatePublicKey(privateKey));
              K12(publicKeyWithChecksum.subarray(0, this.PUBLIC_KEY_LENGTH), publicKeyWithChecksum, this.CHECKSUM_LENGTH, this.PUBLIC_KEY_LENGTH);
              return publicKeyWithChecksum;
            }
            async createIpo(sourceSeed, contractIndex, price, quantity, tick) {
              return crypto_1.default.then(({ schnorrq, K12 }) => {
                // sender
                const sourcePrivateKey = this.privateKey(sourceSeed, 0, K12);
                const sourcePublicKey = this.createPublicKey(sourcePrivateKey, schnorrq, K12);
                const tx = new Uint8Array(this.IPO_TRANSACTION_SIZE).fill(0);
                const txView = new DataView(tx.buffer);
                // fill all with zero
                for (let i = 0; i < this.IPO_TRANSACTION_SIZE; i++) {
                  tx[i] = 0;
                }
                // sourcePublicKey byte[] // 32
                let offset = 0;
                let i = 0;
                for (i = 0; i < this.PUBLIC_KEY_LENGTH; i++) {
                  tx[i] = sourcePublicKey[i];
                }
                offset = i;
                tx[offset] = contractIndex;
                offset++;
                for (i = 1; i < this.PUBLIC_KEY_LENGTH; i++) {
                  tx[offset + i] = 0;
                }
                offset += i - 1;
                txView.setBigInt64(offset, BigInt(0), true); // for ipo tx amoun is just 0
                offset += 8;
                txView.setUint32(offset, tick, true);
                offset += 4;
                txView.setUint16(offset, 1, true); // inputType for IPO is 1
                offset += 2;
                txView.setUint16(offset, 16, true); // inputSize for IPO is 16
                offset += 2;
                // add ipo specifix stuff
                // price
                txView.setBigInt64(offset, BigInt(price), true);
                offset += 8;
                // quantity
                txView.setInt16(offset, quantity, true);
                offset += 2;
                // padding
                offset += 6;
                const digest = new Uint8Array(this.DIGEST_LENGTH);
                const toSign = tx.slice(0, offset);
                K12(toSign, digest, this.DIGEST_LENGTH);
                const signedtx = schnorrq.sign(sourcePrivateKey, sourcePublicKey, digest);
                tx.set(signedtx, offset);
                offset += this.SIGNATURE_LENGTH;
                return tx;
              });
            }
            async createTransaction(sourceSeed, destPublicId, amount, tick) {
              return crypto_1.default.then(({ schnorrq, K12 }) => {
                // sender
                const sourcePrivateKey = this.privateKey(sourceSeed, 0, K12);
                const sourcePublicKey = this.createPublicKey(sourcePrivateKey, schnorrq, K12);
                const destPublicKey = (0, converter_js_1.publicKeyStringToBytes)(destPublicId).slice(0, this.PUBLIC_KEY_LENGTH);
                const tx = new Uint8Array(this.TRANSACTION_SIZE).fill(0);
                const txView = new DataView(tx.buffer);
                // sourcePublicKey byte[] // 32
                let offset = 0;
                let i = 0;
                for (i = 0; i < this.PUBLIC_KEY_LENGTH; i++) {
                  tx[i] = sourcePublicKey[i];
                }
                offset = i;
                for (i = 0; i < this.PUBLIC_KEY_LENGTH; i++) {
                  tx[offset + i] = destPublicKey[i];
                }
                offset += i;
                txView.setBigInt64(offset, BigInt(amount), true);
                offset += 8;
                txView.setUint32(offset, tick, true);
                offset += 4;
                txView.setUint16(offset, 0, true);
                offset += 2;
                txView.setUint16(offset, 0, true);
                offset += 2;
                const digest = new Uint8Array(this.DIGEST_LENGTH);
                const toSign = tx.slice(0, offset);
                K12(toSign, digest, this.DIGEST_LENGTH);
                const signedtx = schnorrq.sign(sourcePrivateKey, sourcePublicKey, digest);
                tx.set(signedtx, offset);
                offset += this.SIGNATURE_LENGTH;
                return tx;
              });
            }
            // todo: remove on next update
            // private getIncreasingNonceAndCommandType(type: number): Uint8Array {
            //     let timestamp = Math.floor(Date.now() / 1000);
            //     const byteArray = new Uint8Array(8);
            //     const txView = new DataView(byteArray.buffer);
            //     txView.setUint32(0, timestamp, true);
            //     byteArray[7] = type;
            //     return byteArray;
            // }
            /**
             *
             * implementation aligned with qubic-cli
             *
             * @param type
             * @returns
             */
            getIncreasingNonceAndCommandType(type) {
              const timestamp = BigInt(Math.floor(Date.now() / 1000));
              const commandByte = BigInt(type) << BigInt(56);
              const result = commandByte | timestamp;
              const byteArray = new Uint8Array(8);
              const txView = new DataView(byteArray.buffer);
              txView.setBigUint64(0, result, true);
              return byteArray;
            }
            async createProposal(protocol, computorIndex, operatorSeed, url) {
              return crypto_1.default.then(({ schnorrq, K12 }) => {
                // operator
                const operatorPrivateKey = this.privateKey(operatorSeed, 0, K12);
                const operatorPublicKey = this.createPublicKey(operatorPrivateKey, schnorrq, K12);
                // prepare url
                const encoder = new TextEncoder();
                const urlBytes = encoder.encode(url);
                const uri = new Uint8Array(255);
                const uriSize = urlBytes.length;
                uri.set(urlBytes);
                const proposal = new Uint8Array(this.SET_PROPOSAL_AND_BALLOT_REQUEST_SIZE + this.REQUEST_RESPONSE_HEADER_SIZE).fill(0);
                const txView = new DataView(proposal.buffer);
                let offset = 0;
                // header
                // byte[3] size
                const size = 600;
                proposal[0] = size;
                proposal[1] = (size >> 8);
                proposal[2] = (size >> 16);
                offset += 3;
                // byte type
                proposal[offset] = this.PROCESS_SPECIAL_COMMAND;
                offset++;
                // byte[3] dejavu (we let it empty)
                proposal[offset++] = Math.floor(Math.random() * 255);
                proposal[offset++] = Math.floor(Math.random() * 255);
                proposal[offset++] = Math.floor(Math.random() * 255);
                // byte type deprecated
                proposal[offset] = this.PROCESS_SPECIAL_COMMAND;
                offset++;
                // ulong everIncreasingNonceAndCommandType // 8
                var timeStamp = this.getIncreasingNonceAndCommandType(this.SPECIAL_COMMAND_SET_PROPOSAL_AND_BALLOT_REQUEST);
                for (let i = 0; i < timeStamp.length; i++) {
                  proposal[offset + i] = timeStamp[i];
                }
                offset += timeStamp.length;
                // ushort computorIndex // 2
                txView.setUint16(offset, computorIndex, true);
                offset += 2;
                // padding //6
                const padding = 6;
                for (let i = 0; i < padding; i++) {
                  proposal[offset + i] = 0;
                }
                offset += padding;
                // Start ComputorProposal
                // byte uriSize // 1
                proposal[offset] = uriSize;
                offset++;
                // byte[255] uri // 255
                for (let i = 0; i < uriSize; i++) {
                  proposal[offset + i] = uri[i];
                }
                offset += 255;
                // Start ComputorBallot
                // not used for this request therefore we let it empty
                offset += 256;
                const digest = new Uint8Array(this.DIGEST_LENGTH);
                const toSign = proposal.slice(this.REQUEST_RESPONSE_HEADER_SIZE, offset);
                K12(toSign, digest, this.DIGEST_LENGTH);
                const signatur = schnorrq.sign(operatorPrivateKey, operatorPublicKey, digest);
                proposal.set(signatur, offset);
                offset += this.SIGNATURE_LENGTH;
                return proposal;
              });
            }
            VotesToByteArray(votes) {
              var bitArray = [];
              for (var computorIndex = 0; computorIndex < votes.length; computorIndex++) {
                var vote = votes[computorIndex];
                for (var i = 0; i < 3; i++) {
                  var bit = (vote >> i) & 1;
                  bitArray.push(bit);
                }
              }
              var output = new Uint8Array(Math.ceil(bitArray.length / 8));
              for (var k = 0; k < bitArray.length; k += 8) {
                var byteIndex = Math.floor(k / 8);
                var byteValue = 0;
                for (var j = 0; j < 8; j++) {
                  var bit = bitArray[k + j] || 0; // Use 0 for padding if bitArray is exhausted
                  byteValue |= (bit << j);
                }
                output[byteIndex] = byteValue;
              }
              return output;
            }
            async createBallotRequests(protocol, operatorSeed, computorIndices, votes) {
              return crypto_1.default.then(({ schnorrq, K12 }) => {
                const output = [];
                // operator
                const operatorPrivateKey = this.privateKey(operatorSeed, 0, K12);
                const operatorPublicKey = this.createPublicKey(operatorPrivateKey, schnorrq, K12);
                for (let index = 0; index < computorIndices.length; index++) {
                  const proposal = new Uint8Array(this.SET_PROPOSAL_AND_BALLOT_REQUEST_SIZE + this.REQUEST_RESPONSE_HEADER_SIZE).fill(0);
                  const txView = new DataView(proposal.buffer);
                  let offset = 0;
                  // header
                  // byte[3] size
                  const size = 600;
                  proposal[0] = size;
                  proposal[1] = (size >> 8);
                  proposal[2] = (size >> 16);
                  offset += 3;
                  // byte type
                  proposal[offset] = this.PROCESS_SPECIAL_COMMAND;
                  offset++;
                  // byte[3] dejavu (we let it empty)
                  proposal[offset++] = Math.floor(Math.random() * 255);
                  proposal[offset++] = Math.floor(Math.random() * 255);
                  proposal[offset++] = Math.floor(Math.random() * 255);
                  // byte type (depcrecated)
                  proposal[offset] = this.PROCESS_SPECIAL_COMMAND;
                  offset++;
                  // ulong everIncreasingNonceAndCommandType // 8
                  var timeStamp = this.getIncreasingNonceAndCommandType(this.SPECIAL_COMMAND_SET_PROPOSAL_AND_BALLOT_REQUEST);
                  for (let i = 0; i < timeStamp.length; i++) {
                    proposal[offset + i] = timeStamp[i];
                  }
                  offset += timeStamp.length;
                  // ushort computorIndex // 2
                  txView.setUint16(offset, computorIndices[index], true);
                  offset += 2;
                  // padding //6
                  const padding = 6;
                  for (let i = 0; i < padding; i++) {
                    proposal[offset + i] = 0;
                  }
                  offset += padding;
                  // Start ComputorProposal
                  // byte uriSize // 1
                  proposal[offset] = 0;
                  offset++;
                  // byte[255] uri // 255 // => ignore for ballot request
                  // not used for this request therefore we let it empty
                  offset += 255;
                  // Start ComputorBallot
                  offset++; // zero
                  // map votes
                  var voteBytes = this.VotesToByteArray(votes);
                  for (let i = 0; i < voteBytes.length; i++) {
                    proposal[offset++] = voteBytes[i];
                  }
                  offset++; // quasirandomnumber
                  const digest = new Uint8Array(this.DIGEST_LENGTH);
                  const toSign = proposal.slice(this.REQUEST_RESPONSE_HEADER_SIZE, offset);
                  K12(toSign, digest, this.DIGEST_LENGTH);
                  const signatur = schnorrq.sign(operatorPrivateKey, operatorPublicKey, digest);
                  proposal.set(signatur, offset);
                  offset += this.SIGNATURE_LENGTH;
                  output.push(proposal);
                }
                return output;
              });
            }
            downloadBlob(fileName, blob) {
              if (window.navigator.msSaveOrOpenBlob) {
                window.navigator.msSaveBlob(blob, fileName);
              }
              else {
                const anchor = window.document.createElement('a');
                anchor.href = window.URL.createObjectURL(blob);
                anchor.download = fileName;
                document.body.appendChild(anchor);
                anchor.click();
                document.body.removeChild(anchor);
                window.URL.revokeObjectURL(anchor.href);
              }
            }
          }
          exports.QubicHelper = QubicHelper;


          /***/
}),

/***/ "./src/converter/converter.js":
/*!************************************!*\
  !*** ./src/converter/converter.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

          "use strict";
          __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bytes32ToString: () => (/* binding */ bytes32ToString),
/* harmony export */   bytesToShiftedHex: () => (/* binding */ bytesToShiftedHex),
/* harmony export */   digestBytesToString: () => (/* binding */ digestBytesToString),
/* harmony export */   publicKeyBytesToString: () => (/* binding */ publicKeyBytesToString),
/* harmony export */   publicKeyStringToBytes: () => (/* binding */ publicKeyStringToBytes),
/* harmony export */   seedStringToBytes: () => (/* binding */ seedStringToBytes)
            /* harmony export */
});
          /*
          
          Permission is hereby granted, perpetual, worldwide, non-exclusive, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), 
          to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, 
          and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
          
          
            1. The Software cannot be used in any form or in any substantial portions for development, maintenance and for any other purposes, in the military sphere and in relation to military products, 
            including, but not limited to:
          
              a. any kind of armored force vehicles, missile weapons, warships, artillery weapons, air military vehicles (including military aircrafts, combat helicopters, military drones aircrafts), 
              air defense systems, rifle armaments, small arms, firearms and side arms, melee weapons, chemical weapons, weapons of mass destruction;
          
              b. any special software for development technical documentation for military purposes;
          
              c. any special equipment for tests of prototypes of any subjects with military purpose of use;
          
              d. any means of protection for conduction of acts of a military nature;
          
              e. any software or hardware for determining strategies, reconnaissance, troop positioning, conducting military actions, conducting special operations;
          
              f. any dual-use products with possibility to use the product in military purposes;
          
              g. any other products, software or services connected to military activities;
          
              h. any auxiliary means related to abovementioned spheres and products.
          
          
            2. The Software cannot be used as described herein in any connection to the military activities. A person, a company, or any other entity, which wants to use the Software, 
            shall take all reasonable actions to make sure that the purpose of use of the Software cannot be possibly connected to military purposes.
          
          
            3. The Software cannot be used by a person, a company, or any other entity, activities of which are connected to military sphere in any means. If a person, a company, or any other entity, 
            during the period of time for the usage of Software, would engage in activities, connected to military purposes, such person, company, or any other entity shall immediately stop the usage 
            of Software and any its modifications or alterations.
          
          
            4. Abovementioned restrictions should apply to all modification, alteration, merge, and to other actions, related to the Software, regardless of how the Software was changed due to the 
            abovementioned actions.
          
          
          The above copyright notice and this permission notice shall be included in all copies or substantial portions, modifications and alterations of the Software.
          
          
          THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
          IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH 
          THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
          
          */



          const SHIFTED_HEX_CHARS = 'abcdefghijklmnop';
          const ALPHABET = 'abcdefghijklmnopqrstuvwxyz';

          const bytesToShiftedHex = function (bytes) {
            let hex = '';
            for (let i = 0; i < bytes.length; i++) {
              hex += SHIFTED_HEX_CHARS[bytes[i] >> 4] + SHIFTED_HEX_CHARS[bytes[i] & 15];
            }

            return hex.toUpperCase();
          };

          const publicKeyStringToBytes = function (s) {
            const publicKeyBytes = new Uint8Array(32);
            const view = new DataView(publicKeyBytes.buffer, 0);

            for (let i = 0; i < 4; i++) {
              view.setBigUint64(i * 8, 0n, true);
              for (let j = 14; j-- > 0;) {
                view.setBigUint64(i * 8, view.getBigUint64(i * 8, true) * 26n + BigInt(s.charCodeAt(i * 14 + j)) - BigInt('A'.charCodeAt(0)), true);
              }
            }

            return publicKeyBytes;
          };

          const bytes32ToString = function (bytes) {
            const hex = bytesToShiftedHex(bytes);
            const buffer = new Uint8Array(32);
            const view = new DataView(buffer.buffer, 0);
            let s = '';

            for (let i = 0; i < bytes.length; i++) {
              view.setUint8(
                i,
                ((hex.charCodeAt(i << 1) - 'A'.charCodeAt(0)) << 4) |
                (hex.charCodeAt((i << 1) + 1) - 'A'.charCodeAt(0)),
                true
              );
            }
            for (let i = 0; i < 4; i++) {
              for (let j = 0; j < 14; j++) {
                s += String.fromCharCode(
                  Number((view.getBigUint64(i * 8, true) % 26n) + BigInt('A'.charCodeAt(0)))
                );
                view.setBigUint64(i * 8, view.getBigUint64(i * 8, true) / 26n, true);
              }
            }

            return s.toLowerCase();
          };

          const digestBytesToString = bytes32ToString;

          const publicKeyBytesToString = function (bytes) {
            if (bytes.length === 32) {
              return bytes32ToString(bytes).toUpperCase();
            }

            const hex = bytesToShiftedHex(bytes);
            const buffer = new Uint8Array(40);
            const view = new DataView(buffer.buffer, 0);
            let s = '';

            for (let i = 0; i < bytes.length; i++) {
              view.setUint8(
                i,
                ((hex.charCodeAt(i << 1) - 'A'.charCodeAt(0)) << 4) |
                (hex.charCodeAt((i << 1) + 1) - 'A'.charCodeAt(0)),
                true
              );
            }
            for (let i = 0; i < 4; i++) {
              for (let j = 0; j < 14; j++) {
                s += String.fromCharCode(
                  Number((view.getBigUint64(i * 8, true) % 26n) + BigInt('A'.charCodeAt(0)))
                );
                view.setBigUint64(i * 8, view.getBigUint64(i * 8, true) / 26n, true);
              }
            }

            view.setBigUint64(32, view.getBigUint64(32, true) & 0x3ffffn, true);

            for (let i = 0; i < 4; i++) {
              s += String.fromCharCode(
                Number((view.getBigUint64(32, true) % 26n) + BigInt('A'.charCodeAt(0)))
              );
              view.setBigUint64(32, view.getBigUint64(32, true) / 26n, true);
            }

            return s.toUpperCase();
          };

          const seedStringToBytes = function (seed) {
            const bytes = new Uint8Array(seed.length);
            for (let i = 0; i < seed.length; i++) {
              bytes[i] = ALPHABET.indexOf(seed[i]);
            }
            return bytes;
          };

          /***/
}),

/***/ "./src/crypto/index.js":
/*!*****************************!*\
  !*** ./src/crypto/index.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

          "use strict";
          __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CHECKSUM_LENGTH: () => (/* binding */ CHECKSUM_LENGTH),
/* harmony export */   DIGEST_LENGTH: () => (/* binding */ DIGEST_LENGTH),
/* harmony export */   KECCAK_STATE_LENGTH: () => (/* binding */ KECCAK_STATE_LENGTH),
/* harmony export */   NONCE_LENGTH: () => (/* binding */ NONCE_LENGTH),
/* harmony export */   PRIVATE_KEY_LENGTH: () => (/* binding */ PRIVATE_KEY_LENGTH),
/* harmony export */   PUBLIC_KEY_LENGTH: () => (/* binding */ PUBLIC_KEY_LENGTH),
/* harmony export */   SIGNATURE_LENGTH: () => (/* binding */ SIGNATURE_LENGTH),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
            /* harmony export */
});
/* harmony import */ var _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libFourQ_K12.js */ "./src/crypto/libFourQ_K12.js");
/* harmony import */ var _keccakp_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keccakp.js */ "./src/crypto/keccakp.js");






          const allocU8 = function (l, v) {
            let ptr = _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._malloc(l);
            let chunk = _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"].HEAPU8.subarray(ptr, ptr + l);
            if (v) {
              chunk.set(v);
            }
            return chunk;
          };

          const allocU16 = function (l, v) {
            let ptr = _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._malloc(l);
            let chunk = _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"].HEAPU16.subarray(ptr, ptr + l);
            chunk.set(v);
            return chunk;
          };

          /**
           * @namespace Crypto
           */

          /**
           * A promise which always resolves to object with crypto functions.
           *
           * @constant {Promise<Crypto>}
           * @memberof module:qubic
           */
          const crypto = new Promise(function (resolve) {
            _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"].onRuntimeInitialized = function () {
              /**
               * @memberof Crypto.schnorrq
               * @param {Uint8Array} secretKey
               * @returns {Uint8Array}
               */
              const generatePublicKey = function (secretKey) {
                const sk = allocU8(secretKey.length, secretKey);
                const pk = allocU8(32);

                const free = function () {
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(sk.byteOffset);
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(pk.byteOffset);
                };

                _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._SchnorrQ_KeyGeneration(sk.byteOffset, pk.byteOffset);
                const key = pk.slice();
                free();
                return key;
              };

              /**
               * @memberof Crypto.schnorrq
               * @param {Uint8Array} secretKey
               * @param {Uint8Array} publicKey
               * @param {Uint8Array} message
               * @returns {Uint8Array}
               */
              const sign = function (secretKey, publicKey, message) {
                const sk = allocU8(secretKey.length, secretKey);
                const pk = allocU8(publicKey.length, publicKey);
                const m = allocU8(message.length, message);
                const s = allocU8(64);

                const free = function () {
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(sk.byteOffset);
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(pk.byteOffset);
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(m.byteOffset);
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(s.byteOffset);
                };

                _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._SchnorrQ_Sign(
                  sk.byteOffset,
                  pk.byteOffset,
                  m.byteOffset,
                  message.length,
                  s.byteOffset
                );
                const sig = s.slice();
                free();
                return sig;
              };

              /**
               * @memberof Crypto.schnorrq
               * @param {Uint8Array} publicKey
               * @param {Uint8Array} message
               * @param {Uint8Array} signature
               * @returns {number} 1 if valid, 0 if invalid
               */
              const verify = function (publicKey, message, signature) {
                const pk = allocU8(publicKey.length, publicKey);
                const m = allocU8(message.length, message);
                const s = allocU8(signature.length, signature);
                const v = allocU16(1, new Uint16Array(1));

                const free = function () {
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(pk.byteOffset);
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(m.byteOffset);
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(s.byteOffset);
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(v.byteOffset);
                };

                _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._SchnorrQ_Verify(
                  pk.byteOffset,
                  m.byteOffset,
                  message.length,
                  s.byteOffset,
                  v.byteOffset
                );
                const ver = v[0];
                free();
                return ver;
              };

              /**
               * @memberof Crypto.kex
               * @param {Uint8Array} secretKey
               * @returns {Uint8Array} Public key
               */
              const generateCompressedPublicKey = function (secretKey) {
                const sk = allocU8(secretKey.length, secretKey);
                const pk = allocU8(32);

                const free = function () {
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(sk.byteOffset);
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(pk.byteOffset);
                };

                _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._CompressedPublicKeyGeneration(sk.byteOffset, pk.byteOffset);
                const key = pk.slice();
                free();
                return key;
              };

              /**
               * @memberof Crypto.kex
               * @param {Uint8Array} secretKey
               * @param {Uint8Array} publicKey
               * @returns {Uint8Array} Shared key
               */
              const compressedSecretAgreement = function (secretKey, publicKey) {
                const sk = allocU8(secretKey.length, secretKey);
                const pk = allocU8(publicKey.length, publicKey);
                const shk = allocU8(32);

                const free = function () {
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(sk.byteOffset);
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(pk.byteOffset);
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(shk.byteOffset);
                };

                _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._CompressedSecretAgreement(sk.byteOffset, pk.byteOffset, shk.byteOffset);
                const key = shk.slice();
                free();
                return key;
              };

              /**
               * @memberof Crypto
               * @param {Uint8Array} input
               * @param {Uint8Array} output
               * @param {number} outputLength
               * @param {number} outputOffset
               */
              const K12 = function (input, output, outputLength, outputOffset = 0) {
                const i = allocU8(input.length, input);
                const o = allocU8(outputLength, new Uint8Array(outputLength));

                const free = function () {
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(i.byteOffset);
                  _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._free(o.byteOffset);
                };

                _libFourQ_K12_js__WEBPACK_IMPORTED_MODULE_0__["default"]._KangarooTwelve(i.byteOffset, input.length, o.byteOffset, outputLength, 0, 0);
                output.set(o.slice(), outputOffset);
                free();
              };

              resolve({
                /**
                 * @namespace Crypto.schnorrq
                 */
                schnorrq: {
                  generatePublicKey,
                  sign,
                  verify,
                },
                /**
                 * @namespace Crypto.kex
                 */
                kex: {
                  generateCompressedPublicKey,
                  compressedSecretAgreement,
                },
                K12,
                keccakP160012: _keccakp_js__WEBPACK_IMPORTED_MODULE_1__.keccakP160012,
                KECCAK_STATE_LENGTH: 200,
              });
            };
          });

          crypto.keccakP160012 = _keccakp_js__WEBPACK_IMPORTED_MODULE_1__.keccakP160012;
          const KECCAK_STATE_LENGTH = 200;
          const SIGNATURE_LENGTH = 64;
          const PRIVATE_KEY_LENGTH = 32;
          const PUBLIC_KEY_LENGTH = 32;
          const DIGEST_LENGTH = 32;
          const NONCE_LENGTH = 32;
          const CHECKSUM_LENGTH = 3;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (crypto);


          /***/
}),

/***/ "./src/crypto/keccakp.js":
/*!*******************************!*\
  !*** ./src/crypto/keccakp.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

          "use strict";
          __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   keccakP160012: () => (/* binding */ keccakP160012)
            /* harmony export */
});

          // Source: https://github.com/paulmillr/noble-hashes/blob/299905c98bdf1a197023198c8fe678923483896d/src/sha3.ts

          /*
          The MIT License (MIT)
          
          Copyright (c) 2022 Paul Miller (https://paulmillr.com)
          
          Permission is hereby granted, free of charge, to any person obtaining a copy
          of this software and associated documentation files (the “Software”), to deal
          in the Software without restriction, including without limitation the rights
          to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
          copies of the Software, and to permit persons to whom the Software is
          furnished to do so, subject to the following conditions:
          
          The above copyright notice and this permission notice shall be included in
          all copies or substantial portions of the Software.
          
          THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
          IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
          FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
          AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
          LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
          OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
          THE SOFTWARE.
          */

          const U32_MASK64 = BigInt(2 ** 32 - 1);
          const _32n = BigInt(32);

          // We are not using BigUint64Array, because they are extremely slow as per 2022
          function fromBig(n, le = false) {
            if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
            return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
          }

          function split(lst, le = false) {
            let Ah = new Uint32Array(lst.length);
            let Al = new Uint32Array(lst.length);
            for (let i = 0; i < lst.length; i++) {
              const { h, l } = fromBig(lst[i], le);
              [Ah[i], Al[i]] = [h, l];
            }
            return [Ah, Al];
          }

          const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
          // for Shift in [0, 32)
          const shrSH = (h, l, s) => h >>> s;
          const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
          // Right rotate for Shift in [1, 32)
          const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
          const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
          // Right rotate for Shift in (32, 64), NOTE: 32 is special case.
          const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
          const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
          // Right rotate for shift===32 (just swaps l&h)
          const rotr32H = (h, l) => l;
          const rotr32L = (h, l) => h;
          // Left rotate for Shift in [1, 32)
          const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
          const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
          // Left rotate for Shift in (32, 64), NOTE: 32 is special case.
          const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
          const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));

          // JS uses 32-bit signed integers for bitwise operations which means we cannot
          // simple take carry out of low bit sum by shift, we need to use division.
          // Removing "export" has 5% perf penalty -_-
          function add(Ah, Al, Bh, Bl) {
            const l = (Al >>> 0) + (Bl >>> 0);
            return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
          }
          // Addition with more than 2 elements
          const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
          const add3H = (low, Ah, Bh, Ch) =>
            (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
          const add4L = (Al, Bl, Cl, Dl) =>
            (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
          const add4H = (low, Ah, Bh, Ch, Dh) =>
            (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
          const add5L = (Al, Bl, Cl, Dl, El) =>
            (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
          const add5H = (low, Ah, Bh, Ch, Dh, Eh) =>
            (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;

          // prettier-ignore
          const u64 = {
            fromBig, split, toBig,
            shrSH, shrSL,
            rotrSH, rotrSL, rotrBH, rotrBL,
            rotr32H, rotr32L,
            rotlSH, rotlSL, rotlBH, rotlBL,
            add, add3L, add3H, add4L, add4H, add5H, add5L,
          };

          const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];

          const _0n = BigInt(0);
          const _1n = BigInt(1);
          const _2n = BigInt(2);
          const _7n = BigInt(7);
          const _256n = BigInt(256);
          const _0x71n = BigInt(0x71);
          for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
            // Pi
            [x, y] = [y, (2 * x + 3 * y) % 5];
            SHA3_PI.push(2 * (5 * y + x));
            // Rotational
            SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
            // Iota
            let t = _0n;
            for (let j = 0; j < 7; j++) {
              R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
              if (R & _2n) t ^= _1n << ((_1n << BigInt(j)) - _1n);
            }
            _SHA3_IOTA.push(t);
          }
          const [SHA3_IOTA_H, SHA3_IOTA_L] = u64.split(_SHA3_IOTA, true);

          const rotlH = (h, l, s) =>
            s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);
          const rotlL = (h, l, s) =>
            s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s);

          function keccakP160012(s1) {
            const s = new Uint32Array(s1.buffer);
            const rounds = 12;
            const B = new Uint32Array(5 * 2);
            for (let round = 24 - rounds; round < 24; round++) {
              // Theta θ
              for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
              for (let x = 0; x < 10; x += 2) {
                const idx1 = (x + 8) % 10;
                const idx0 = (x + 2) % 10;
                const B0 = B[idx0];
                const B1 = B[idx0 + 1];
                const Th = rotlH(B0, B1, 1) ^ B[idx1];
                const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
                for (let y = 0; y < 50; y += 10) {
                  s[x + y] ^= Th;
                  s[x + y + 1] ^= Tl;
                }
              }
              // Rho (ρ) and Pi (π)
              let curH = s[2];
              let curL = s[3];
              for (let t = 0; t < 24; t++) {
                const shift = SHA3_ROTL[t];
                const Th = rotlH(curH, curL, shift);
                const Tl = rotlL(curH, curL, shift);
                const PI = SHA3_PI[t];
                curH = s[PI];
                curL = s[PI + 1];
                s[PI] = Th;
                s[PI + 1] = Tl;
              }
              // Chi (χ)
              for (let y = 0; y < 50; y += 10) {
                for (let x = 0; x < 10; x++) B[x] = s[y + x];
                for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
              }
              // Iota (ι)
              s[0] ^= SHA3_IOTA_H[round];
              s[1] ^= SHA3_IOTA_L[round];
            }
            B.fill(0);
          }


          /***/
}),

/***/ "./src/crypto/libFourQ_K12.js":
/*!************************************!*\
  !*** ./src/crypto/libFourQ_K12.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

          "use strict";
          __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
            /* harmony export */
});
          var encodedWasmFile = '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aiIAaiIGIABzIAAgDXNyIAZzIAkgAEF/c3FyQR92aiIAaiIJIABzIAAgDHNyIAlzIAEgAEF/c3FyQR92aiIAQR92IARqIgE2AiAgAyAEIAFBf3NxQR92IAZqIgE2AiQgAyAGIAFBf3NxQR92IAlqIgE2AiggAyAAQf////8HcSAJIAFBf3NxQR92ajYCLCACIA8gAkGAAWoiABANIAIgDyACQeAAaiIBEAcgACADIAIQBiATIAMgEhAGIAEgEyAPEAYgA0FAayQAC1UBAn8gAEHgAGoiAiACIAFB4ABqIgIQByAAIABBIGoiAyABEAcgAyAAIAFBIGoQDSACIABBgAFqIAIQBiAAQUBrIgAgACABQUBrEAcgAkHgCCACEAYL5AMBA38gACACaiEDAkACQAJAIAAgAXNBA3FFBEAgAEEDcUUNASACQQBMDQEgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgJBA3FFDQMgAiADSQ0ACwwCCwJAIANBBEkNACADQQRrIgQgAEkNACAAIQIDQCACIAEtAAA6AAAgAiABLQABOgABIAIgAS0AAjoAAiACIAEtAAM6AAMgAUEEaiEBIAJBBGoiAiAETQ0ACwwDCyAAIQIMAgsgACECCwJAIANBfHEiBEHAAEkNACACIARBQGoiBUsNAANAIAIgASgCADYCACACIAEoAgQ2AgQgAiABKAIINgIIIAIgASgCDDYCDCACIAEoAhA2AhAgAiABKAIUNgIUIAIgASgCGDYCGCACIAEoAhw2AhwgAiABKAIgNgIgIAIgASgCJDYCJCACIAEoAig2AiggAiABKAIsNgIsIAIgASgCMDYCMCACIAEoAjQ2AjQgAiABKAI4NgI4IAIgASgCPDYCPCABQUBrIQEgAkFAayICIAVNDQALCyACIARPDQADQCACIAEoAgA2AgAgAUEEaiEBIAJBBGoiAiAESQ0ACwsgAiADSQRAA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA0cNAAsLIAAL4gEBA38gAC0AyQFFBEAgAgRAA0AgAiAFayEDAkACQCAALQDIASIEDQAgBUGoAWogAksNACADQagBTwRAA0AgACABQQBBqAEQQAJAIAAQFQsgAUGoAWohASADQagBayIDQacBSw0ACwsgAiADayEFDAELIAAgASAEQagBIARr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QQF2aiAMIARBf3NxIAQgCnMgAyAEc3IgCnNyQR92ajYCDCABIAkgE2sgBkEBdmogCyACQX9zcSAAIAJzIAIgBnNyIABzckEfdmo2AhwgASABKAIgIgJBAWoiA0F+IAEoAiQiAGsgAEF/c3IgAHNBH3ZBfiACayACQX9zciACc0EfdiIGIABBAWoiBSAASXFyIgcgASgCKCIAQQFqIgkgAElxQX4gAGsgAEF/c3IgAHNBH3ZyIgggASgCLCIAQf////8HayICRXEgAiAAQX9zcUEfdnIiAGsiBDYCICABIAIgCGtBACAAayICQQF2aiAJIAdrIgcgBSAGayIGIAMgBHMgAiADc3IgBHNBH3ZqIgMgAGsiBCADcyACIANzciAEcyAGIANBf3NxckEfdmoiAyAAayIAIANzIAIgA3NyIABzIAcgA0F/c3FyQR92ajYCLCABIAA2AiggASAENgIkIAEgASgCMCICQQFqIgNBfiABKAI0IgBrIABBf3NyIABzQR92QX4gAmsgAkF/c3IgAnNBH3YiAiAAQQFqIgUgAElxciIHIAEoAjgiAEEBaiIJIABJcUF+IABrIABBf3NyIABzQR92ciIIIAEoAjwiAEH/////B2siBEVxIAQgAEF/c3FBH3ZyIgBrIgY2AjAgASAFIAJrIgUgBiADIAZzIANBACAAayICc3JzQR92aiIDIABrIgY2AjQgASAJIAdrIgcgBSADQX9zcSADIAZzIAIgA3NyIAZzckEfdmoiAyAAayIANgI4IAEgBCAIayACQQF2aiAHIANBf3NxIAAgA3MgAiADc3IgAHNyQR92ajYCPAuWAgEJfyAAIAAoAgAiAUEBaiIEQX4gACgCCCICayACQX9zciACc0EfdkF+IAAoAgQiA2sgA0F/c3IgA3NBH3ZBfiABayABQX9zciABc0EfdiIBIANBAWoiBSADSXFyIgYgAkEBaiIIIAJJcXIiCSAAKAIMIgJB/////wdrIgdFcSAHIAJBf3NxQR92ciICayIDNgIAIAAgBSABayIFIAMgAyAEcyAEQQAgAmsiA3Nyc0EfdmoiASACayIENgIEIAAgCCAGayIGIAUgAUF/c3EgASAEcyABIANzciAEc3JBH3ZqIgEgAmsiAjYCCCAAIAYgAUF/c3EgASACcyABIANzciACc3JBH3YgA0EBdmogByAJa2o2AgwL4QEBCX8gAiAAKAIAIgMgASgCACIEayIHNgIAIAIgACgCBCIFIAEoAgQiBmsiCCADIAQgB3MgAyAEc3JzQR92IgtrIgM2AgQgAiAAKAIIIgQgASgCCCIJayIKIAsgCEVxIAUgBiAIcyAFIAZzcnNBH3ZyIgZrIgU2AgggAiAHIAAoAgwgASgCDCAGIApFcSAEIAkgCnMgBCAJc3JzQR92cmprIgBBH3YiAWs2AgAgAiADIAEgB0VxIgFrNgIEIAIgBSABIANFcSIBazYCCCACIABB/////wdxIAEgBUVxazYCDAtZAQF/IAAgACgCSCIBQQFrIAFyNgJIIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAutCQEjfyAAKAJ8IQogACgCeCEYIAAoAnQhGSAAKAJwIRogACgCbCELIAAoAmghGyAAKAJkIRwgACgCYCEdIAAoAlwhHiAAKAJYIR8gACgCVCEgIAAoAlAhISAAKAJMISIgACgCSCEjIAAoAkQhJCAAQUBrKAIAISUgACgCPCEMIAAoAjghDSAAKAI0IQ4gACgCMCEPIAAoAiwhECAAKAIoIREgACgCJCESIAAoAiAhEyAAKAIcIQYgACgCGCEHIAAoAhQhCCAAKAIQIQkgACgCDCEUIAAoAgghFSAAKAIEIRYgACgCACEXQQEhJgNAIAJBAWsiAkEfdkEBayIEIAAgJkEHdGoiBSgCACAXc3EgF3MhFyAFKAJ8IApzIARxIApzIQogBSgCbCALcyAEcSALcyELIAUoAlwgHnMgBHEgHnMhHiAFKAJMICJzIARxICJzISIgBSgCPCAMcyAEcSAMcyEMIAUoAiwgEHMgBHEgEHMhECAFKAIcIAZzIARxIAZzIQYgBSgCDCAUcyAEcSAUcyEUIAUoAnggGHMgBHEgGHMhGCAFKAJoIBtzIARxIBtzIRsgBSgCWCAfcyAEcSAfcyEfIAUoAkggI3MgBHEgI3MhIyAFKAI4IA1zIARxIA1zIQ0gBSgCKCARcyAEcSARcyERIAUoAhggB3MgBHEgB3MhByAFKAIIIBVzIARxIBVzIRUgBSgCdCAZcyAEcSAZcyEZIAUoAmQgHHMgBHEgHHMhHCAFKAJUICBzIARxICBzISAgBSgCRCAkcyAEcSAkcyEkIAUoAjQgDnMgBHEgDnMhDiAFKAIkIBJzIARxIBJzIRIgBSgCFCAIcyAEcSAIcyEIIAUoAgQgFnMgBHEgFnMhFiAFKAJwIBpzIARxIBpzIRogBSgCYCAdcyAEcSAdcyEdIAUoAlAgIXMgBHEgIXMhISAFQUBrKAIAICVzIARxICVzISUgBSgCMCAPcyAEcSAPcyEPIAUoAiAgE3MgBHEgE3MhEyAFKAIQIAlzIARxIAlzIQkgJkEBaiImQQhHDQALIAEgHjYCXCABIB82AlggASAgNgJUIAEgITYCUCABICI2AkwgASAjNgJIIAEgJDYCRCABQUBrICU2AgAgASADIBhzQX9zNgJ4IAEgAyAZc0F/czYCdCABIAMgGnNBf3M2AnAgASADIBtzQX9zNgJoIAEgAyAcc0F/czYCZCABIAMgHXNBf3M2AmAgASAGIAxzIANxIgAgBnM2AjwgASAHIA1zIANxIgIgB3M2AjggASAIIA5zIANxIgQgCHM2AjQgASAJIA9zIANxIgUgCXM2AjAgASAQIBRzIANxIgYgFHM2AiwgASARIBVzIANxIgcgFXM2AiggASASIBZzIANxIgggFnM2AiQgASATIBdzIANxIgkgF3M2AiAgASAAIAxzNgIcIAEgAiANczYCGCABIAQgDnM2AhQgASAFIA9zNgIQIAEgBiAQczYCDCABIAcgEXM2AgggASAIIBJzNgIEIAEgCSATczYCACABQf////8HIAprIgAgCnMgA3EgAHM2AnwgAUH/////ByALayIAIAtzIANxIABzNgJsC7wCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACQQYRAAALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACAB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AkEBNgKgASAAKQAIIQwgACkAECENIAApAAAhDiABIAApABg3ADggASANNwAwIAEgDDcAKCABQSBqIgMgDjcAACAALQAfIQsgASABKAI8Qf////8HcTYCPCADIAJB4AFqIgUQCCAFQYCFAiACQcABaiIGEAYgBSACQaABaiIAIAUQDSAGIAAgBhAHIAYgAkHAAmoiABAcIAJB0AFqIgMgAkGwAmoiBxAcIAAgByAAECMgBSAGIAcQBSACQfABaiIAIAMgAkGgAmoiBBAFIAcgBCAHECMgACAGIAQQBSAFIAMgAkGQAmoiAxAFIAQgAyAEEDMgByADEBwgBCACQYACaiIAEBwgAyAAIAMQI0EAIQADQCACQZACaiIDIAMQHCAAQQFqIgBB/QBHDQALIAJBsAJqIAJBkAJqIAJB0AJqIgAQIyAAEDIgAigC3AIgAigC2AIgAigC1AIgAigC0AJycnJFBEAgAkGwAmogAkGQAmogAkHQAmoQMwsgAkHQAmoiCSAJIAkQIyACQcACaiIDIAJBkAJqIggQHCADIAggCBAFIAkgCCAIEAUgCCACQeACaiIAEEogAyAAIAgQBSAJIAggARAFIAEgAkGwAmoiChAcIAMgCiAKEAUgASABKAIEIgMgASgCACIAQQAgAEEBcSIEayIFcyAAc0EfdiAEayIGaiIHQR90IABBAXZyNgIAIAEgASgCCCIAIAUgBkF/c3EgBiAHcyADIAZzciAHc3JBH3YgBGsiBGoiA0EfdCAHQQF2cjYCBCABIAEoAgwgBSAEQX9zcSADIARzIAAgBHNyIANzckEfdiAFQQF2amoiAEEBdjYCDCABIABBH3QgA0EBdnI2AgggAkGgAmogCCABQRBqIgMQBSAJIAogCRAzIAkQMiACKALcAiACKALYAiACKALUAiACKALQAnJycgRAIAJBwAJqIgAgASgCADYCACAAIAEoAgQ2AgQgACABKAIINgIIIAAgASgCDDYCDCABIAMoAgA2AgAgASADKAIENgIEIAEgAygCCDYCCCABIAMoAgw2AgwgAyAAKAIANgIAIAMgACgCBDYCBCADIAAoAgg2AgggAyAAKAIMNgIMCyABEDIgAUEMQRwgASgCDCABKAIIIAEoAgQgASgCAHJychtqKAIAQR52IAtBB3ZHBEAgARBHCyABIAIQRQJ/IAIQKEUE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AhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAyACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiADIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAQgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSACIAIgAhAFIAUgAiACEAUgAiACIAIQBSACIAIgAhAFIAIgAiACEAUgAiACIAIQBSAGIAIgAhAFIAIgAiACEAUgACACIAEQBSAEQdAAaiQAC48FAgZ+AX8gASABKAIAQQdqQXhxIgFBEGo2AgAgAAJ8IAEpAwAhAyABKQMIIQYjAEEgayIIJAACQCAGQv///////////wCDIgRCgICAgICAwIA8fSAEQoCAgICAgMD/wwB9VARAIAZCBIYgA0I8iIQhBCADQv//////////D4MiA0KBgICAgICAgAhaBEAgBEKBgICAgICAgMAAfCECDAILIARCgICAgICAgIBAfSECIANCgICAgICAgIAIhUIAUg0BIAIgBEIBg3whAgwBCyADUCAEQoCAgICAgMD//wBUIARCgICAgICAwP//AFEbRQRAIAZCBIYgA0I8iIRC/////////wODQoCAgICAgID8/wCEIQIMAQtCgICAgICAgPj/ACECIARC////////v//DAFYNAEIAIQIgBEIwiKciAEGR9wBJDQAgAyECIAZC////////P4NCgICAgICAwACEIgUhBwJAIABBgfcAayIBQcAAcQRAIAIgAUFAaq2GIQdCACECDAELIAFFDQAgByABrSIEhiACQcAAIAFrrYiEIQcgAiAEhiECCyAIIAI3AxAgCCAHNwMYAkBBgfgAIABrIgBBwABxBEAgBSAAQUBqrYghA0IAIQUMAQsgAEUNACAFQcAAIABrrYYgAyAArSICiIQhAyAFIAKIIQULIAggAzcDACAIIAU3AwggCCkDCEIEhiAIKQMAIgNCPIiEIQIgCCkDECAIKQMYhEIAUq0gA0L//////////w+DhCIDQoGAgICAgICACFoEQCACQgF8IQIMAQsgA0KAgICAgICAgAiFQgBSDQAgAkIBgyACfCECCyAIQSBqJAAgAiAGQoCAgICAgICAgH+DhL8LOQMAC74YAxJ/AXwCfiMAQbAEayILJAAgC0EANgIsAkAgAb0iGUIAUwRAQQEhEEGOhwIhEyABmiIBvSEZDAELIARBgBBxBEBBASEQQZGHAiETDAELQZSHAkGPhwIgBEEBcSIQGyETIBBFIRQLAkAgGUKAgICAgICA+P8Ag0KAgICAgICA+P8AUQRAIABBICACIBBBA2oiAyAEQf//e3EQCiAAIBMgEBAJIABB54cCQamIAiAFQSBxIgUbQfiHAkGtiAIgBRsgASABYhtBAxAJIABBICACIAMgBEGAwABzEAogAiADIAIgA0obIQkMAQsgC0EQaiERAkACfwJAIAEgC0EsahA5IgEgAaAiAUQAAAAAAAAAAGIEQCALIAsoAiwiBkEBazYCLCAFQSByIg5B4QBHDQEMAwsgBUEgciIOQeEARg0CIAsoAiwhCkEGIAMgA0EASBsMAQsgCyAGQR1rIgo2AiwgAUQAAAAAAACwQaIhAUEGIAMgA0EASBsLIQwgC0EwaiALQdACaiAKQQBIGyINIQcDQCAHAn8gAUQAAAAAAADwQWMgAUQAAAAAAAAAAGZxBEAgAasMAQtBAAsiAzYCACAHQQRqIQcgASADuKFEAAAAAGXNzUGiIgFEAAAAAAAAAABiDQALAkAgCkEATARAIAohAyAHIQYgDSEIDAELIA0hCCAKIQMDQCADQR0gA0EdSRshAwJAIAdBBGsi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';

          var Module = typeof Module !== 'undefined' ? Module : {};
          var moduleOverrides = {};
          var key;
          for (key in Module) {
            if (Module.hasOwnProperty(key)) {
              moduleOverrides[key] = Module[key];
            }
          }
          var arguments_ = [];
          var thisProgram = './this.program';
          var quit_ = function (status, toThrow) {
            throw toThrow;
          };
          var ENVIRONMENT_IS_WEB = typeof window === 'object';
          var ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
          var ENVIRONMENT_IS_NODE =
            typeof process === 'object' &&
            typeof process.versions === 'object' &&
            typeof process.versions.node === 'string';
          var scriptDirectory = '';
          /**
           * @param path
           */
          function locateFile(path) {
            if (Module['locateFile']) {
              return Module['locateFile'](path, scriptDirectory);
            }
            return scriptDirectory + path;
          }
          var read_, readAsync, readBinary, setWindowTitle;

          /**
           * @param e
           */
          function logExceptionOnExit(e) {
            if (e instanceof ExitStatus) return;
            var toLog = e;
            err('exiting due to exception: ' + toLog);
          }
          var nodeFS;
          var nodePath;
          // if (ENVIRONMENT_IS_NODE) {
          //   if (ENVIRONMENT_IS_WORKER) {
          //     scriptDirectory = require('path').dirname(scriptDirectory) + '/';
          //   } else {
          //     scriptDirectory = '/';
          //   }
          //   read_ = function shell_read(filename, binary) {
          //     if (!nodeFS) nodeFS = require('fs');
          //     if (!nodePath) nodePath = require('path');
          //     filename = nodePath['normalize'](filename);
          //     return nodeFS['readFileSync'](filename, binary ? null : 'utf8');
          //   };
          //   readBinary = function readBinary(filename) {
          //     var ret = read_(filename, true);
          //     if (!ret.buffer) {
          //       ret = new Uint8Array(ret);
          //     }
          //     assert(ret.buffer);
          //     return ret;
          //   };
          //   readAsync = function readAsync(filename, onload, onerror) {
          //     if (!nodeFS) nodeFS = require('fs');
          //     if (!nodePath) nodePath = require('path');
          //     filename = nodePath['normalize'](filename);
          //     nodeFS['readFile'](filename, function (err, data) {
          //       if (err) onerror(err);
          //       else onload(data.buffer);
          //     });
          //   };
          //   if (process['argv'].length > 1) {
          //     thisProgram = process['argv'][1].replace(/\\/g, '/');
          //   }
          //   arguments_ = process['argv'].slice(2);
          //   if (typeof module !== 'undefined') {
          //     module['exports'] = Module;
          //   }
          //   process['on']('uncaughtException', function (ex) {
          //     if (!(ex instanceof ExitStatus)) {
          //       throw ex;
          //     }
          //   });
          //   process['on']('unhandledRejection', function (reason) {
          //     throw reason;
          //   });
          //   quit_ = function (status, toThrow) {
          //     if (keepRuntimeAlive()) {
          //       process['exitCode'] = status;
          //       throw toThrow;
          //     }
          //     logExceptionOnExit(toThrow);
          //     process['exit'](status);
          //   };
          //   Module['inspect'] = function () {
          //     return '[Emscripten Module object]';
          //   };
          // } else
          if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) {
              scriptDirectory = self.location.href;
            } else if (typeof document !== 'undefined' && document.currentScript) {
              scriptDirectory = document.currentScript.src;
            }
            if (scriptDirectory.indexOf('blob:') !== 0) {
              scriptDirectory = scriptDirectory.substr(
                0,
                scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1
              );
            } else {
              scriptDirectory = '';
            }
            {
              read_ = function (url) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, false);
                xhr.send(null);
                return xhr.responseText;
              };
              if (ENVIRONMENT_IS_WORKER) {
                readBinary = function (url) {
                  var xhr = new XMLHttpRequest();
                  xhr.open('GET', url, false);
                  xhr.responseType = 'arraybuffer';
                  xhr.send(null);
                  return new Uint8Array(xhr.response);
                };
              }
              readAsync = function (url, onload, onerror) {
                var xhr = new XMLHttpRequest();
                xhr.open('GET', url, true);
                xhr.responseType = 'arraybuffer';
                xhr.onload = function () {
                  if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {
                    onload(xhr.response);
                    return;
                  }
                  onerror();
                };
                xhr.onerror = onerror;
                xhr.send(null);
              };
            }
            setWindowTitle = function (title) {
              document.title = title;
            };
          } else {
          }
          var out = Module['print'] || console.log.bind(console);
          var err = Module['printErr'] || console.warn.bind(console);
          for (key in moduleOverrides) {
            if (moduleOverrides.hasOwnProperty(key)) {
              Module[key] = moduleOverrides[key];
            }
          }
          moduleOverrides = null;
          if (Module['arguments']) arguments_ = Module['arguments'];
          if (Module['thisProgram']) thisProgram = Module['thisProgram'];
          if (Module['quit']) quit_ = Module['quit'];
          var wasmBinary;
          if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
          var noExitRuntime = Module['noExitRuntime'] || true;
          if (typeof WebAssembly !== 'object') {
            abort('no native wasm support detected');
          }
          var wasmMemory;
          var ABORT = false;
          var EXITSTATUS;

          /**
           * @param condition
           * @param text
           */
          function assert(condition, text) {
            if (!condition) {
              abort('Assertion failed: ' + text);
            }
          }
          var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

          /**
           * @param heap
           * @param idx
           * @param maxBytesToRead
           */
          function UTF8ArrayToString(heap, idx, maxBytesToRead) {
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;
            if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
              return UTF8Decoder.decode(heap.subarray(idx, endPtr));
            } else {
              var str = '';
              while (idx < endPtr) {
                var u0 = heap[idx++];
                if (!(u0 & 128)) {
                  str += String.fromCharCode(u0);
                  continue;
                }
                var u1 = heap[idx++] & 63;
                if ((u0 & 224) == 192) {
                  str += String.fromCharCode(((u0 & 31) << 6) | u1);
                  continue;
                }
                var u2 = heap[idx++] & 63;
                if ((u0 & 240) == 224) {
                  u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
                } else {
                  u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);
                }
                if (u0 < 65536) {
                  str += String.fromCharCode(u0);
                } else {
                  var ch = u0 - 65536;
                  str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));
                }
              }
            }
            return str;
          }

          /**
           * @param ptr
           * @param maxBytesToRead
           */
          function UTF8ToString(ptr, maxBytesToRead) {
            return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
          }

          /**
           * @param str
           * @param heap
           * @param outIdx
           * @param maxBytesToWrite
           */
          function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
            if (!(maxBytesToWrite > 0)) return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1;
            for (var i = 0; i < str.length; ++i) {
              var u = str.charCodeAt(i);
              if (u >= 55296 && u <= 57343) {
                var u1 = str.charCodeAt(++i);
                u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);
              }
              if (u <= 127) {
                if (outIdx >= endIdx) break;
                heap[outIdx++] = u;
              } else if (u <= 2047) {
                if (outIdx + 1 >= endIdx) break;
                heap[outIdx++] = 192 | (u >> 6);
                heap[outIdx++] = 128 | (u & 63);
              } else if (u <= 65535) {
                if (outIdx + 2 >= endIdx) break;
                heap[outIdx++] = 224 | (u >> 12);
                heap[outIdx++] = 128 | ((u >> 6) & 63);
                heap[outIdx++] = 128 | (u & 63);
              } else {
                if (outIdx + 3 >= endIdx) break;
                heap[outIdx++] = 240 | (u >> 18);
                heap[outIdx++] = 128 | ((u >> 12) & 63);
                heap[outIdx++] = 128 | ((u >> 6) & 63);
                heap[outIdx++] = 128 | (u & 63);
              }
            }
            heap[outIdx] = 0;
            return outIdx - startIdx;
          }

          /**
           * @param str
           * @param outPtr
           * @param maxBytesToWrite
           */
          function stringToUTF8(str, outPtr, maxBytesToWrite) {
            return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
          }

          /**
           * @param str
           */
          function lengthBytesUTF8(str) {
            var len = 0;
            for (var i = 0; i < str.length; ++i) {
              var u = str.charCodeAt(i);
              if (u >= 55296 && u <= 57343) u = (65536 + ((u & 1023) << 10)) | (str.charCodeAt(++i) & 1023);
              if (u <= 127) ++len;
              else if (u <= 2047) len += 2;
              else if (u <= 65535) len += 3;
              else len += 4;
            }
            return len;
          }
          var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

          /**
           * @param buf
           */
          function updateGlobalBufferAndViews(buf) {
            buffer = buf;
            Module['HEAP8'] = HEAP8 = new Int8Array(buf);
            Module['HEAP16'] = HEAP16 = new Int16Array(buf);
            Module['HEAP32'] = HEAP32 = new Int32Array(buf);
            Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
            Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
            Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
            Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
            Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
          }
          var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;
          var wasmTable;
          var __ATPRERUN__ = [];
          var __ATINIT__ = [];
          var __ATMAIN__ = [];
          var __ATPOSTRUN__ = [];
          var runtimeInitialized = false;
          var runtimeExited = false;
          var runtimeKeepaliveCounter = 0;

          /**
           *
           */
          function keepRuntimeAlive() {
            return noExitRuntime || runtimeKeepaliveCounter > 0;
          }

          /**
           *
           */
          function preRun() {
            if (Module['preRun']) {
              if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
              while (Module['preRun'].length) {
                addOnPreRun(Module['preRun'].shift());
              }
            }
            callRuntimeCallbacks(__ATPRERUN__);
          }

          /**
           *
           */
          function initRuntime() {
            runtimeInitialized = true;
            if (!Module['noFSInit'] && !FS.init.initialized) FS.init();
            FS.ignorePermissions = false;
            TTY.init();
            callRuntimeCallbacks(__ATINIT__);
          }

          /**
           *
           */
          function preMain() {
            callRuntimeCallbacks(__ATMAIN__);
          }

          /**
           *
           */
          function exitRuntime() {
            runtimeExited = true;
          }

          /**
           *
           */
          function postRun() {
            if (Module['postRun']) {
              if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
              while (Module['postRun'].length) {
                addOnPostRun(Module['postRun'].shift());
              }
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
          }

          /**
           * @param cb
           */
          function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
          }

          /**
           * @param cb
           */
          function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
          }
          var runDependencies = 0;
          var runDependencyWatcher = null;
          var dependenciesFulfilled = null;

          /**
           * @param id
           */
          function getUniqueRunDependency(id) {
            return id;
          }

          /**
           * @param id
           */
          function addRunDependency(id) {
            runDependencies++;
            if (Module['monitorRunDependencies']) {
              Module['monitorRunDependencies'](runDependencies);
            }
          }

          /**
           * @param id
           */
          function removeRunDependency(id) {
            runDependencies--;
            if (Module['monitorRunDependencies']) {
              Module['monitorRunDependencies'](runDependencies);
            }
            if (runDependencies == 0) {
              if (runDependencyWatcher !== null) {
                clearInterval(runDependencyWatcher);
                runDependencyWatcher = null;
              }
              if (dependenciesFulfilled) {
                var callback = dependenciesFulfilled;
                dependenciesFulfilled = null;
                callback();
              }
            }
          }
          Module['preloadedImages'] = {};
          Module['preloadedAudios'] = {};

          /**
           * @param what
           */
          function abort(what) {
            {
              if (Module['onAbort']) {
                Module['onAbort'](what);
              }
            }
            what = 'Aborted(' + what + ')';
            err(what);
            ABORT = true;
            EXITSTATUS = 1;
            what += '. Build with -s ASSERTIONS=1 for more info.';
            var e = new WebAssembly.RuntimeError(what);
            throw e;
          }
          var dataURIPrefix = 'data:application/octet-stream;base64,';

          /**
           * @param filename
           */
          function isDataURI(filename) {
            return filename.startsWith(dataURIPrefix);
          }

          /**
           * @param filename
           */
          function isFileURI(filename) {
            return filename.startsWith('file://');
          }
          var wasmBinaryFile;
          wasmBinaryFile = 'libFourQ.wasm';
          if (!isDataURI(wasmBinaryFile)) {
            wasmBinaryFile = locateFile(wasmBinaryFile);
          }

          /**
           * @param file
           */
          function getBinary(file) {
            try {
              if (file == wasmBinaryFile && wasmBinary) {
                return new Uint8Array(wasmBinary);
              }
              if (readBinary) {
                return readBinary(file);
              } else {
                throw 'both async and sync fetching of the wasm failed';
              }
            } catch (err) {
              abort(err);
            }
          }

          /**
           *
           */
          function getBinaryPromise() {
            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
              if (typeof fetch === 'function' && !isFileURI(wasmBinaryFile)) {
                return fetch(wasmBinaryFile, { credentials: 'same-origin' })
                  .then(function (response) {
                    if (!response['ok']) {
                      throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                    }
                    return response['arrayBuffer']();
                  })
                  .catch(function () {
                    return getBinary(wasmBinaryFile);
                  });
              } else {
                if (readAsync) {
                  return new Promise(function (resolve, reject) {
                    readAsync(
                      wasmBinaryFile,
                      function (response) {
                        resolve(new Uint8Array(response));
                      },
                      reject
                    );
                  });
                }
              }
            }
            return Promise.resolve().then(function () {
              return getBinary(wasmBinaryFile);
            });
          }

          function asciiToBinary(str) {
            if (typeof atob === 'function') {
              return atob(str)
            } else {
              return Buffer.from(str, 'base64').toString('binary');
            }
          }

          function decode(encoded) {
            var binaryString = asciiToBinary(encoded);
            var bytes = new Uint8Array(binaryString.length);
            for (var i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
          }

          /**
           *
           */
          function createWasm() {
            var info = { env: asmLibraryArg, wasi_snapshot_preview1: asmLibraryArg };

            /**
             * @param instance
             * @param module
             */
            function receiveInstance(instance, module) {
              var exports = instance.exports;
              Module['asm'] = exports;
              wasmMemory = Module['asm']['memory'];
              updateGlobalBufferAndViews(wasmMemory.buffer);
              wasmTable = Module['asm']['__indirect_function_table'];
              removeRunDependency('wasm-instantiate');
            }
            addRunDependency('wasm-instantiate');

            /**
             * @param result
             */
            function receiveInstantiationResult(result) {
              receiveInstance(result['instance']);
            }

            /**
             * @param receiver
             */
            function instantiateArrayBuffer(receiver) {
              return WebAssembly.instantiate(decode(encodedWasmFile), info)
                .then(function (instance) {
                  return instance;
                })
                .then(receiver, function (reason) {
                  err('failed to asynchronously prepare wasm: ' + reason);
                  abort(reason);
                });
            }

            /**
             *
             */
            function instantiateAsync() {
              return instantiateArrayBuffer(receiveInstantiationResult);
            }
            if (Module['instantiateWasm']) {
              try {
                var exports = Module['instantiateWasm'](info, receiveInstance);
                return exports;
              } catch (e) {
                err('Module.instantiateWasm callback failed with error: ' + e);
                return false;
              }
            }
            instantiateAsync();
            return {};
          }
          var tempDouble;
          var tempI64;

          /**
           * @param callbacks
           */
          function callRuntimeCallbacks(callbacks) {
            while (callbacks.length > 0) {
              var callback = callbacks.shift();
              if (typeof callback == 'function') {
                callback(Module);
                continue;
              }
              var func = callback.func;
              if (typeof func === 'number') {
                if (callback.arg === undefined) {
                  getWasmTableEntry(func)();
                } else {
                  getWasmTableEntry(func)(callback.arg);
                }
              } else {
                func(callback.arg === undefined ? null : callback.arg);
              }
            }
          }
          var wasmTableMirror = [];

          /**
           * @param funcPtr
           */
          function getWasmTableEntry(funcPtr) {
            var func = wasmTableMirror[funcPtr];
            if (!func) {
              if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
              wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
            }
            return func;
          }

          /**
           * @param e
           */
          function handleException(e) {
            if (e instanceof ExitStatus || e == 'unwind') {
              return EXITSTATUS;
            }
            quit_(1, e);
          }
          var PATH = {
            splitPath: function (filename) {
              var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
              return splitPathRe.exec(filename).slice(1);
            },
            normalizeArray: function (parts, allowAboveRoot) {
              var up = 0;
              for (var i = parts.length - 1; i >= 0; i--) {
                var last = parts[i];
                if (last === '.') {
                  parts.splice(i, 1);
                } else if (last === '..') {
                  parts.splice(i, 1);
                  up++;
                } else if (up) {
                  parts.splice(i, 1);
                  up--;
                }
              }
              if (allowAboveRoot) {
                for (; up; up--) {
                  parts.unshift('..');
                }
              }
              return parts;
            },
            normalize: function (path) {
              var isAbsolute = path.charAt(0) === '/',
                trailingSlash = path.substr(-1) === '/';
              path = PATH.normalizeArray(
                path.split('/').filter(function (p) {
                  return !!p;
                }),
                !isAbsolute
              ).join('/');
              if (!path && !isAbsolute) {
                path = '.';
              }
              if (path && trailingSlash) {
                path += '/';
              }
              return (isAbsolute ? '/' : '') + path;
            },
            dirname: function (path) {
              var result = PATH.splitPath(path),
                root = result[0],
                dir = result[1];
              if (!root && !dir) {
                return '.';
              }
              if (dir) {
                dir = dir.substr(0, dir.length - 1);
              }
              return root + dir;
            },
            basename: function (path) {
              if (path === '/') return '/';
              path = PATH.normalize(path);
              path = path.replace(/\/$/, '');
              var lastSlash = path.lastIndexOf('/');
              if (lastSlash === -1) return path;
              return path.substr(lastSlash + 1);
            },
            extname: function (path) {
              return PATH.splitPath(path)[3];
            },
            join: function () {
              var paths = Array.prototype.slice.call(arguments, 0);
              return PATH.normalize(paths.join('/'));
            },
            join2: function (l, r) {
              return PATH.normalize(l + '/' + r);
            },
          };

          /**
           *
           */
          function getRandomDevice() {
            if (typeof crypto === 'object' && typeof crypto['getRandomValues'] === 'function') {
              var randomBuffer = new Uint8Array(1);
              return function () {
                crypto.getRandomValues(randomBuffer);
                return randomBuffer[0];
              };
            }
            // else if (ENVIRONMENT_IS_NODE) {
            //   try {
            //     var crypto_module = require('crypto');
            //     return function () {
            //       return crypto_module['randomBytes'](1)[0];
            //     };
            //   } catch (e) {}
            // }
            return function () {
              abort('randomDevice');
            };
          }
          var PATH_FS = {
            resolve: function () {
              var resolvedPath = '',
                resolvedAbsolute = false;
              for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                var path = i >= 0 ? arguments[i] : FS.cwd();
                if (typeof path !== 'string') {
                  throw new TypeError('Arguments to path.resolve must be strings');
                } else if (!path) {
                  return '';
                }
                resolvedPath = path + '/' + resolvedPath;
                resolvedAbsolute = path.charAt(0) === '/';
              }
              resolvedPath = PATH.normalizeArray(
                resolvedPath.split('/').filter(function (p) {
                  return !!p;
                }),
                !resolvedAbsolute
              ).join('/');
              return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
            },
            relative: function (from, to) {
              from = PATH_FS.resolve(from).substr(1);
              to = PATH_FS.resolve(to).substr(1);

              /**
               * @param arr
               */
              function trim(arr) {
                var start = 0;
                for (; start < arr.length; start++) {
                  if (arr[start] !== '') break;
                }
                var end = arr.length - 1;
                for (; end >= 0; end--) {
                  if (arr[end] !== '') break;
                }
                if (start > end) return [];
                return arr.slice(start, end - start + 1);
              }
              var fromParts = trim(from.split('/'));
              var toParts = trim(to.split('/'));
              var length = Math.min(fromParts.length, toParts.length);
              var samePartsLength = length;
              for (var i = 0; i < length; i++) {
                if (fromParts[i] !== toParts[i]) {
                  samePartsLength = i;
                  break;
                }
              }
              var outputParts = [];
              for (var i = samePartsLength; i < fromParts.length; i++) {
                outputParts.push('..');
              }
              outputParts = outputParts.concat(toParts.slice(samePartsLength));
              return outputParts.join('/');
            },
          };
          var TTY = {
            ttys: [],
            init: function () { },
            shutdown: function () { },
            register: function (dev, ops) {
              TTY.ttys[dev] = { input: [], output: [], ops: ops };
              FS.registerDevice(dev, TTY.stream_ops);
            },
            stream_ops: {
              open: function (stream) {
                var tty = TTY.ttys[stream.node.rdev];
                if (!tty) {
                  throw new FS.ErrnoError(43);
                }
                stream.tty = tty;
                stream.seekable = false;
              },
              close: function (stream) {
                stream.tty.ops.flush(stream.tty);
              },
              flush: function (stream) {
                stream.tty.ops.flush(stream.tty);
              },
              read: function (stream, buffer, offset, length, pos) {
                if (!stream.tty || !stream.tty.ops.get_char) {
                  throw new FS.ErrnoError(60);
                }
                var bytesRead = 0;
                for (var i = 0; i < length; i++) {
                  var result;
                  try {
                    result = stream.tty.ops.get_char(stream.tty);
                  } catch (e) {
                    throw new FS.ErrnoError(29);
                  }
                  if (result === undefined && bytesRead === 0) {
                    throw new FS.ErrnoError(6);
                  }
                  if (result === null || result === undefined) break;
                  bytesRead++;
                  buffer[offset + i] = result;
                }
                if (bytesRead) {
                  stream.node.timestamp = Date.now();
                }
                return bytesRead;
              },
              write: function (stream, buffer, offset, length, pos) {
                if (!stream.tty || !stream.tty.ops.put_char) {
                  throw new FS.ErrnoError(60);
                }
                try {
                  for (var i = 0; i < length; i++) {
                    stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
                  }
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
                if (length) {
                  stream.node.timestamp = Date.now();
                }
                return i;
              },
            },
            default_tty_ops: {
              get_char: function (tty) {
                if (!tty.input.length) {
                  var result = null;
                  if (ENVIRONMENT_IS_NODE) {
                    var BUFSIZE = 256;
                    var buf = Buffer.alloc(BUFSIZE);
                    var bytesRead = 0;
                    try {
                      bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
                    } catch (e) {
                      if (e.toString().includes('EOF')) bytesRead = 0;
                      else throw e;
                    }
                    if (bytesRead > 0) {
                      result = buf.slice(0, bytesRead).toString('utf-8');
                    } else {
                      result = null;
                    }
                  } else if (typeof window != 'undefined' && typeof window.prompt == 'function') {
                    result = window.prompt('Input: ');
                    if (result !== null) {
                      result += '\n';
                    }
                  } else if (typeof readline == 'function') {
                    result = readline();
                    if (result !== null) {
                      result += '\n';
                    }
                  }
                  if (!result) {
                    return null;
                  }
                  tty.input = intArrayFromString(result, true);
                }
                return tty.input.shift();
              },
              put_char: function (tty, val) {
                if (val === null || val === 10) {
                  out(UTF8ArrayToString(tty.output, 0));
                  tty.output = [];
                } else {
                  if (val != 0) tty.output.push(val);
                }
              },
              flush: function (tty) {
                if (tty.output && tty.output.length > 0) {
                  out(UTF8ArrayToString(tty.output, 0));
                  tty.output = [];
                }
              },
            },
            default_tty1_ops: {
              put_char: function (tty, val) {
                if (val === null || val === 10) {
                  err(UTF8ArrayToString(tty.output, 0));
                  tty.output = [];
                } else {
                  if (val != 0) tty.output.push(val);
                }
              },
              flush: function (tty) {
                if (tty.output && tty.output.length > 0) {
                  err(UTF8ArrayToString(tty.output, 0));
                  tty.output = [];
                }
              },
            },
          };
          /**
           * @param size
           */
          function mmapAlloc(size) {
            abort();
          }
          var MEMFS = {
            ops_table: null,
            mount: function (mount) {
              return MEMFS.createNode(null, '/', 16384 | 511, 0);
            },
            createNode: function (parent, name, mode, dev) {
              if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
                throw new FS.ErrnoError(63);
              }
              if (!MEMFS.ops_table) {
                MEMFS.ops_table = {
                  dir: {
                    node: {
                      getattr: MEMFS.node_ops.getattr,
                      setattr: MEMFS.node_ops.setattr,
                      lookup: MEMFS.node_ops.lookup,
                      mknod: MEMFS.node_ops.mknod,
                      rename: MEMFS.node_ops.rename,
                      unlink: MEMFS.node_ops.unlink,
                      rmdir: MEMFS.node_ops.rmdir,
                      readdir: MEMFS.node_ops.readdir,
                      symlink: MEMFS.node_ops.symlink,
                    },
                    stream: { llseek: MEMFS.stream_ops.llseek },
                  },
                  file: {
                    node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr },
                    stream: {
                      llseek: MEMFS.stream_ops.llseek,
                      read: MEMFS.stream_ops.read,
                      write: MEMFS.stream_ops.write,
                      allocate: MEMFS.stream_ops.allocate,
                      mmap: MEMFS.stream_ops.mmap,
                      msync: MEMFS.stream_ops.msync,
                    },
                  },
                  link: {
                    node: {
                      getattr: MEMFS.node_ops.getattr,
                      setattr: MEMFS.node_ops.setattr,
                      readlink: MEMFS.node_ops.readlink,
                    },
                    stream: {},
                  },
                  chrdev: {
                    node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr },
                    stream: FS.chrdev_stream_ops,
                  },
                };
              }
              var node = FS.createNode(parent, name, mode, dev);
              if (FS.isDir(node.mode)) {
                node.node_ops = MEMFS.ops_table.dir.node;
                node.stream_ops = MEMFS.ops_table.dir.stream;
                node.contents = {};
              } else if (FS.isFile(node.mode)) {
                node.node_ops = MEMFS.ops_table.file.node;
                node.stream_ops = MEMFS.ops_table.file.stream;
                node.usedBytes = 0;
                node.contents = null;
              } else if (FS.isLink(node.mode)) {
                node.node_ops = MEMFS.ops_table.link.node;
                node.stream_ops = MEMFS.ops_table.link.stream;
              } else if (FS.isChrdev(node.mode)) {
                node.node_ops = MEMFS.ops_table.chrdev.node;
                node.stream_ops = MEMFS.ops_table.chrdev.stream;
              }
              node.timestamp = Date.now();
              if (parent) {
                parent.contents[name] = node;
                parent.timestamp = node.timestamp;
              }
              return node;
            },
            getFileDataAsTypedArray: function (node) {
              if (!node.contents) return new Uint8Array(0);
              if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);
              return new Uint8Array(node.contents);
            },
            expandFileStorage: function (node, newCapacity) {
              var prevCapacity = node.contents ? node.contents.length : 0;
              if (prevCapacity >= newCapacity) return;
              var CAPACITY_DOUBLING_MAX = 1024 * 1024;
              newCapacity = Math.max(
                newCapacity,
                (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125)) >>> 0
              );
              if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
              var oldContents = node.contents;
              node.contents = new Uint8Array(newCapacity);
              if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
            },
            resizeFileStorage: function (node, newSize) {
              if (node.usedBytes == newSize) return;
              if (newSize == 0) {
                node.contents = null;
                node.usedBytes = 0;
              } else {
                var oldContents = node.contents;
                node.contents = new Uint8Array(newSize);
                if (oldContents) {
                  node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
                }
                node.usedBytes = newSize;
              }
            },
            node_ops: {
              getattr: function (node) {
                var attr = {};
                attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
                attr.ino = node.id;
                attr.mode = node.mode;
                attr.nlink = 1;
                attr.uid = 0;
                attr.gid = 0;
                attr.rdev = node.rdev;
                if (FS.isDir(node.mode)) {
                  attr.size = 4096;
                } else if (FS.isFile(node.mode)) {
                  attr.size = node.usedBytes;
                } else if (FS.isLink(node.mode)) {
                  attr.size = node.link.length;
                } else {
                  attr.size = 0;
                }
                attr.atime = new Date(node.timestamp);
                attr.mtime = new Date(node.timestamp);
                attr.ctime = new Date(node.timestamp);
                attr.blksize = 4096;
                attr.blocks = Math.ceil(attr.size / attr.blksize);
                return attr;
              },
              setattr: function (node, attr) {
                if (attr.mode !== undefined) {
                  node.mode = attr.mode;
                }
                if (attr.timestamp !== undefined) {
                  node.timestamp = attr.timestamp;
                }
                if (attr.size !== undefined) {
                  MEMFS.resizeFileStorage(node, attr.size);
                }
              },
              lookup: function (parent, name) {
                throw FS.genericErrors[44];
              },
              mknod: function (parent, name, mode, dev) {
                return MEMFS.createNode(parent, name, mode, dev);
              },
              rename: function (old_node, new_dir, new_name) {
                if (FS.isDir(old_node.mode)) {
                  var new_node;
                  try {
                    new_node = FS.lookupNode(new_dir, new_name);
                  } catch (e) { }
                  if (new_node) {
                    for (var i in new_node.contents) {
                      throw new FS.ErrnoError(55);
                    }
                  }
                }
                delete old_node.parent.contents[old_node.name];
                old_node.parent.timestamp = Date.now();
                old_node.name = new_name;
                new_dir.contents[new_name] = old_node;
                new_dir.timestamp = old_node.parent.timestamp;
                old_node.parent = new_dir;
              },
              unlink: function (parent, name) {
                delete parent.contents[name];
                parent.timestamp = Date.now();
              },
              rmdir: function (parent, name) {
                var node = FS.lookupNode(parent, name);
                for (var i in node.contents) {
                  throw new FS.ErrnoError(55);
                }
                delete parent.contents[name];
                parent.timestamp = Date.now();
              },
              readdir: function (node) {
                var entries = ['.', '..'];
                for (var key in node.contents) {
                  if (!node.contents.hasOwnProperty(key)) {
                    continue;
                  }
                  entries.push(key);
                }
                return entries;
              },
              symlink: function (parent, newname, oldpath) {
                var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
                node.link = oldpath;
                return node;
              },
              readlink: function (node) {
                if (!FS.isLink(node.mode)) {
                  throw new FS.ErrnoError(28);
                }
                return node.link;
              },
            },
            stream_ops: {
              read: function (stream, buffer, offset, length, position) {
                var contents = stream.node.contents;
                if (position >= stream.node.usedBytes) return 0;
                var size = Math.min(stream.node.usedBytes - position, length);
                if (size > 8 && contents.subarray) {
                  buffer.set(contents.subarray(position, position + size), offset);
                } else {
                  for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
                }
                return size;
              },
              write: function (stream, buffer, offset, length, position, canOwn) {
                if (!length) return 0;
                var node = stream.node;
                node.timestamp = Date.now();
                if (buffer.subarray && (!node.contents || node.contents.subarray)) {
                  if (canOwn) {
                    node.contents = buffer.subarray(offset, offset + length);
                    node.usedBytes = length;
                    return length;
                  } else if (node.usedBytes === 0 && position === 0) {
                    node.contents = buffer.slice(offset, offset + length);
                    node.usedBytes = length;
                    return length;
                  } else if (position + length <= node.usedBytes) {
                    node.contents.set(buffer.subarray(offset, offset + length), position);
                    return length;
                  }
                }
                MEMFS.expandFileStorage(node, position + length);
                if (node.contents.subarray && buffer.subarray) {
                  node.contents.set(buffer.subarray(offset, offset + length), position);
                } else {
                  for (var i = 0; i < length; i++) {
                    node.contents[position + i] = buffer[offset + i];
                  }
                }
                node.usedBytes = Math.max(node.usedBytes, position + length);
                return length;
              },
              llseek: function (stream, offset, whence) {
                var position = offset;
                if (whence === 1) {
                  position += stream.position;
                } else if (whence === 2) {
                  if (FS.isFile(stream.node.mode)) {
                    position += stream.node.usedBytes;
                  }
                }
                if (position < 0) {
                  throw new FS.ErrnoError(28);
                }
                return position;
              },
              allocate: function (stream, offset, length) {
                MEMFS.expandFileStorage(stream.node, offset + length);
                stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
              },
              mmap: function (stream, address, length, position, prot, flags) {
                if (address !== 0) {
                  throw new FS.ErrnoError(28);
                }
                if (!FS.isFile(stream.node.mode)) {
                  throw new FS.ErrnoError(43);
                }
                var ptr;
                var allocated;
                var contents = stream.node.contents;
                if (!(flags & 2) && contents.buffer === buffer) {
                  allocated = false;
                  ptr = contents.byteOffset;
                } else {
                  if (position > 0 || position + length < contents.length) {
                    if (contents.subarray) {
                      contents = contents.subarray(position, position + length);
                    } else {
                      contents = Array.prototype.slice.call(contents, position, position + length);
                    }
                  }
                  allocated = true;
                  ptr = mmapAlloc(length);
                  if (!ptr) {
                    throw new FS.ErrnoError(48);
                  }
                  HEAP8.set(contents, ptr);
                }
                return { ptr: ptr, allocated: allocated };
              },
              msync: function (stream, buffer, offset, length, mmapFlags) {
                if (!FS.isFile(stream.node.mode)) {
                  throw new FS.ErrnoError(43);
                }
                if (mmapFlags & 2) {
                  return 0;
                }
                var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
                return 0;
              },
            },
          };

          /**
           * @param url
           * @param onload
           * @param onerror
           * @param noRunDep
           */
          function asyncLoad(url, onload, onerror, noRunDep) {
            var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
            readAsync(
              url,
              function (arrayBuffer) {
                assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
                onload(new Uint8Array(arrayBuffer));
                if (dep) removeRunDependency(dep);
              },
              function (event) {
                if (onerror) {
                  onerror();
                } else {
                  throw 'Loading data file "' + url + '" failed.';
                }
              }
            );
            if (dep) addRunDependency(dep);
          }
          var FS = {
            root: null,
            mounts: [],
            devices: {},
            streams: [],
            nextInode: 1,
            nameTable: null,
            currentPath: '/',
            initialized: false,
            ignorePermissions: true,
            ErrnoError: null,
            genericErrors: {},
            filesystems: null,
            syncFSRequests: 0,
            lookupPath: function (path, opts) {
              path = PATH_FS.resolve(FS.cwd(), path);
              opts = opts || {};
              if (!path) return { path: '', node: null };
              var defaults = { follow_mount: true, recurse_count: 0 };
              for (var key in defaults) {
                if (opts[key] === undefined) {
                  opts[key] = defaults[key];
                }
              }
              if (opts.recurse_count > 8) {
                throw new FS.ErrnoError(32);
              }
              var parts = PATH.normalizeArray(
                path.split('/').filter(function (p) {
                  return !!p;
                }),
                false
              );
              var current = FS.root;
              var current_path = '/';
              for (var i = 0; i < parts.length; i++) {
                var islast = i === parts.length - 1;
                if (islast && opts.parent) {
                  break;
                }
                current = FS.lookupNode(current, parts[i]);
                current_path = PATH.join2(current_path, parts[i]);
                if (FS.isMountpoint(current)) {
                  if (!islast || (islast && opts.follow_mount)) {
                    current = current.mounted.root;
                  }
                }
                if (!islast || opts.follow) {
                  var count = 0;
                  while (FS.isLink(current.mode)) {
                    var link = FS.readlink(current_path);
                    current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                    var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
                    current = lookup.node;
                    if (count++ > 40) {
                      throw new FS.ErrnoError(32);
                    }
                  }
                }
              }
              return { path: current_path, node: current };
            },
            getPath: function (node) {
              var path;
              while (true) {
                if (FS.isRoot(node)) {
                  var mount = node.mount.mountpoint;
                  if (!path) return mount;
                  return mount[mount.length - 1] !== '/' ? mount + '/' + path : mount + path;
                }
                path = path ? node.name + '/' + path : node.name;
                node = node.parent;
              }
            },
            hashName: function (parentid, name) {
              var hash = 0;
              for (var i = 0; i < name.length; i++) {
                hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
              }
              return ((parentid + hash) >>> 0) % FS.nameTable.length;
            },
            hashAddNode: function (node) {
              var hash = FS.hashName(node.parent.id, node.name);
              node.name_next = FS.nameTable[hash];
              FS.nameTable[hash] = node;
            },
            hashRemoveNode: function (node) {
              var hash = FS.hashName(node.parent.id, node.name);
              if (FS.nameTable[hash] === node) {
                FS.nameTable[hash] = node.name_next;
              } else {
                var current = FS.nameTable[hash];
                while (current) {
                  if (current.name_next === node) {
                    current.name_next = node.name_next;
                    break;
                  }
                  current = current.name_next;
                }
              }
            },
            lookupNode: function (parent, name) {
              var errCode = FS.mayLookup(parent);
              if (errCode) {
                throw new FS.ErrnoError(errCode, parent);
              }
              var hash = FS.hashName(parent.id, name);
              for (var node = FS.nameTable[hash]; node; node = node.name_next) {
                var nodeName = node.name;
                if (node.parent.id === parent.id && nodeName === name) {
                  return node;
                }
              }
              return FS.lookup(parent, name);
            },
            createNode: function (parent, name, mode, rdev) {
              var node = new FS.FSNode(parent, name, mode, rdev);
              FS.hashAddNode(node);
              return node;
            },
            destroyNode: function (node) {
              FS.hashRemoveNode(node);
            },
            isRoot: function (node) {
              return node === node.parent;
            },
            isMountpoint: function (node) {
              return !!node.mounted;
            },
            isFile: function (mode) {
              return (mode & 61440) === 32768;
            },
            isDir: function (mode) {
              return (mode & 61440) === 16384;
            },
            isLink: function (mode) {
              return (mode & 61440) === 40960;
            },
            isChrdev: function (mode) {
              return (mode & 61440) === 8192;
            },
            isBlkdev: function (mode) {
              return (mode & 61440) === 24576;
            },
            isFIFO: function (mode) {
              return (mode & 61440) === 4096;
            },
            isSocket: function (mode) {
              return (mode & 49152) === 49152;
            },
            flagModes: { r: 0, 'r+': 2, w: 577, 'w+': 578, a: 1089, 'a+': 1090 },
            modeStringToFlags: function (str) {
              var flags = FS.flagModes[str];
              if (typeof flags === 'undefined') {
                throw new Error('Unknown file open mode: ' + str);
              }
              return flags;
            },
            flagsToPermissionString: function (flag) {
              var perms = ['r', 'w', 'rw'][flag & 3];
              if (flag & 512) {
                perms += 'w';
              }
              return perms;
            },
            nodePermissions: function (node, perms) {
              if (FS.ignorePermissions) {
                return 0;
              }
              if (perms.includes('r') && !(node.mode & 292)) {
                return 2;
              } else if (perms.includes('w') && !(node.mode & 146)) {
                return 2;
              } else if (perms.includes('x') && !(node.mode & 73)) {
                return 2;
              }
              return 0;
            },
            mayLookup: function (dir) {
              var errCode = FS.nodePermissions(dir, 'x');
              if (errCode) return errCode;
              if (!dir.node_ops.lookup) return 2;
              return 0;
            },
            mayCreate: function (dir, name) {
              try {
                var node = FS.lookupNode(dir, name);
                return 20;
              } catch (e) { }
              return FS.nodePermissions(dir, 'wx');
            },
            mayDelete: function (dir, name, isdir) {
              var node;
              try {
                node = FS.lookupNode(dir, name);
              } catch (e) {
                return e.errno;
              }
              var errCode = FS.nodePermissions(dir, 'wx');
              if (errCode) {
                return errCode;
              }
              if (isdir) {
                if (!FS.isDir(node.mode)) {
                  return 54;
                }
                if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                  return 10;
                }
              } else {
                if (FS.isDir(node.mode)) {
                  return 31;
                }
              }
              return 0;
            },
            mayOpen: function (node, flags) {
              if (!node) {
                return 44;
              }
              if (FS.isLink(node.mode)) {
                return 32;
              } else if (FS.isDir(node.mode)) {
                if (FS.flagsToPermissionString(flags) !== 'r' || flags & 512) {
                  return 31;
                }
              }
              return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
            },
            MAX_OPEN_FDS: 4096,
            nextfd: function (fd_start, fd_end) {
              fd_start = fd_start || 0;
              fd_end = fd_end || FS.MAX_OPEN_FDS;
              for (var fd = fd_start; fd <= fd_end; fd++) {
                if (!FS.streams[fd]) {
                  return fd;
                }
              }
              throw new FS.ErrnoError(33);
            },
            getStream: function (fd) {
              return FS.streams[fd];
            },
            createStream: function (stream, fd_start, fd_end) {
              if (!FS.FSStream) {
                FS.FSStream = function () { };
                FS.FSStream.prototype = {
                  object: {
                    get: function () {
                      return this.node;
                    },
                    set: function (val) {
                      this.node = val;
                    },
                  },
                  isRead: {
                    get: function () {
                      return (this.flags & 2097155) !== 1;
                    },
                  },
                  isWrite: {
                    get: function () {
                      return (this.flags & 2097155) !== 0;
                    },
                  },
                  isAppend: {
                    get: function () {
                      return this.flags & 1024;
                    },
                  },
                };
              }
              var newStream = new FS.FSStream();
              for (var p in stream) {
                newStream[p] = stream[p];
              }
              stream = newStream;
              var fd = FS.nextfd(fd_start, fd_end);
              stream.fd = fd;
              FS.streams[fd] = stream;
              return stream;
            },
            closeStream: function (fd) {
              FS.streams[fd] = null;
            },
            chrdev_stream_ops: {
              open: function (stream) {
                var device = FS.getDevice(stream.node.rdev);
                stream.stream_ops = device.stream_ops;
                if (stream.stream_ops.open) {
                  stream.stream_ops.open(stream);
                }
              },
              llseek: function () {
                throw new FS.ErrnoError(70);
              },
            },
            major: function (dev) {
              return dev >> 8;
            },
            minor: function (dev) {
              return dev & 255;
            },
            makedev: function (ma, mi) {
              return (ma << 8) | mi;
            },
            registerDevice: function (dev, ops) {
              FS.devices[dev] = { stream_ops: ops };
            },
            getDevice: function (dev) {
              return FS.devices[dev];
            },
            getMounts: function (mount) {
              var mounts = [];
              var check = [mount];
              while (check.length) {
                var m = check.pop();
                mounts.push(m);
                check.push.apply(check, m.mounts);
              }
              return mounts;
            },
            syncfs: function (populate, callback) {
              if (typeof populate === 'function') {
                callback = populate;
                populate = false;
              }
              FS.syncFSRequests++;
              if (FS.syncFSRequests > 1) {
                err(
                  'warning: ' +
                  FS.syncFSRequests +
                  ' FS.syncfs operations in flight at once, probably just doing extra work'
                );
              }
              var mounts = FS.getMounts(FS.root.mount);
              var completed = 0;

              /**
               * @param errCode
               */
              function doCallback(errCode) {
                FS.syncFSRequests--;
                return callback(errCode);
              }

              /**
               * @param errCode
               */
              function done(errCode) {
                if (errCode) {
                  if (!done.errored) {
                    done.errored = true;
                    return doCallback(errCode);
                  }
                  return;
                }
                if (++completed >= mounts.length) {
                  doCallback(null);
                }
              }
              mounts.forEach(function (mount) {
                if (!mount.type.syncfs) {
                  return done(null);
                }
                mount.type.syncfs(mount, populate, done);
              });
            },
            mount: function (type, opts, mountpoint) {
              var root = mountpoint === '/';
              var pseudo = !mountpoint;
              var node;
              if (root && FS.root) {
                throw new FS.ErrnoError(10);
              } else if (!root && !pseudo) {
                var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
                mountpoint = lookup.path;
                node = lookup.node;
                if (FS.isMountpoint(node)) {
                  throw new FS.ErrnoError(10);
                }
                if (!FS.isDir(node.mode)) {
                  throw new FS.ErrnoError(54);
                }
              }
              var mount = { type: type, opts: opts, mountpoint: mountpoint, mounts: [] };
              var mountRoot = type.mount(mount);
              mountRoot.mount = mount;
              mount.root = mountRoot;
              if (root) {
                FS.root = mountRoot;
              } else if (node) {
                node.mounted = mount;
                if (node.mount) {
                  node.mount.mounts.push(mount);
                }
              }
              return mountRoot;
            },
            unmount: function (mountpoint) {
              var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
              if (!FS.isMountpoint(lookup.node)) {
                throw new FS.ErrnoError(28);
              }
              var node = lookup.node;
              var mount = node.mounted;
              var mounts = FS.getMounts(mount);
              Object.keys(FS.nameTable).forEach(function (hash) {
                var current = FS.nameTable[hash];
                while (current) {
                  var next = current.name_next;
                  if (mounts.includes(current.mount)) {
                    FS.destroyNode(current);
                  }
                  current = next;
                }
              });
              node.mounted = null;
              var idx = node.mount.mounts.indexOf(mount);
              node.mount.mounts.splice(idx, 1);
            },
            lookup: function (parent, name) {
              return parent.node_ops.lookup(parent, name);
            },
            mknod: function (path, mode, dev) {
              var lookup = FS.lookupPath(path, { parent: true });
              var parent = lookup.node;
              var name = PATH.basename(path);
              if (!name || name === '.' || name === '..') {
                throw new FS.ErrnoError(28);
              }
              var errCode = FS.mayCreate(parent, name);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              if (!parent.node_ops.mknod) {
                throw new FS.ErrnoError(63);
              }
              return parent.node_ops.mknod(parent, name, mode, dev);
            },
            create: function (path, mode) {
              mode = mode !== undefined ? mode : 438;
              mode &= 4095;
              mode |= 32768;
              return FS.mknod(path, mode, 0);
            },
            mkdir: function (path, mode) {
              mode = mode !== undefined ? mode : 511;
              mode &= 511 | 512;
              mode |= 16384;
              return FS.mknod(path, mode, 0);
            },
            mkdirTree: function (path, mode) {
              var dirs = path.split('/');
              var d = '';
              for (var i = 0; i < dirs.length; ++i) {
                if (!dirs[i]) continue;
                d += '/' + dirs[i];
                try {
                  FS.mkdir(d, mode);
                } catch (e) {
                  if (e.errno != 20) throw e;
                }
              }
            },
            mkdev: function (path, mode, dev) {
              if (typeof dev === 'undefined') {
                dev = mode;
                mode = 438;
              }
              mode |= 8192;
              return FS.mknod(path, mode, dev);
            },
            symlink: function (oldpath, newpath) {
              if (!PATH_FS.resolve(oldpath)) {
                throw new FS.ErrnoError(44);
              }
              var lookup = FS.lookupPath(newpath, { parent: true });
              var parent = lookup.node;
              if (!parent) {
                throw new FS.ErrnoError(44);
              }
              var newname = PATH.basename(newpath);
              var errCode = FS.mayCreate(parent, newname);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              if (!parent.node_ops.symlink) {
                throw new FS.ErrnoError(63);
              }
              return parent.node_ops.symlink(parent, newname, oldpath);
            },
            rename: function (old_path, new_path) {
              var old_dirname = PATH.dirname(old_path);
              var new_dirname = PATH.dirname(new_path);
              var old_name = PATH.basename(old_path);
              var new_name = PATH.basename(new_path);
              var lookup, old_dir, new_dir;
              lookup = FS.lookupPath(old_path, { parent: true });
              old_dir = lookup.node;
              lookup = FS.lookupPath(new_path, { parent: true });
              new_dir = lookup.node;
              if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
              if (old_dir.mount !== new_dir.mount) {
                throw new FS.ErrnoError(75);
              }
              var old_node = FS.lookupNode(old_dir, old_name);
              var relative = PATH_FS.relative(old_path, new_dirname);
              if (relative.charAt(0) !== '.') {
                throw new FS.ErrnoError(28);
              }
              relative = PATH_FS.relative(new_path, old_dirname);
              if (relative.charAt(0) !== '.') {
                throw new FS.ErrnoError(55);
              }
              var new_node;
              try {
                new_node = FS.lookupNode(new_dir, new_name);
              } catch (e) { }
              if (old_node === new_node) {
                return;
              }
              var isdir = FS.isDir(old_node.mode);
              var errCode = FS.mayDelete(old_dir, old_name, isdir);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              if (!old_dir.node_ops.rename) {
                throw new FS.ErrnoError(63);
              }
              if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
                throw new FS.ErrnoError(10);
              }
              if (new_dir !== old_dir) {
                errCode = FS.nodePermissions(old_dir, 'w');
                if (errCode) {
                  throw new FS.ErrnoError(errCode);
                }
              }
              FS.hashRemoveNode(old_node);
              try {
                old_dir.node_ops.rename(old_node, new_dir, new_name);
              } catch (e) {
                throw e;
              } finally {
                FS.hashAddNode(old_node);
              }
            },
            rmdir: function (path) {
              var lookup = FS.lookupPath(path, { parent: true });
              var parent = lookup.node;
              var name = PATH.basename(path);
              var node = FS.lookupNode(parent, name);
              var errCode = FS.mayDelete(parent, name, true);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              if (!parent.node_ops.rmdir) {
                throw new FS.ErrnoError(63);
              }
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              parent.node_ops.rmdir(parent, name);
              FS.destroyNode(node);
            },
            readdir: function (path) {
              var lookup = FS.lookupPath(path, { follow: true });
              var node = lookup.node;
              if (!node.node_ops.readdir) {
                throw new FS.ErrnoError(54);
              }
              return node.node_ops.readdir(node);
            },
            unlink: function (path) {
              var lookup = FS.lookupPath(path, { parent: true });
              var parent = lookup.node;
              var name = PATH.basename(path);
              var node = FS.lookupNode(parent, name);
              var errCode = FS.mayDelete(parent, name, false);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              if (!parent.node_ops.unlink) {
                throw new FS.ErrnoError(63);
              }
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              parent.node_ops.unlink(parent, name);
              FS.destroyNode(node);
            },
            readlink: function (path) {
              var lookup = FS.lookupPath(path);
              var link = lookup.node;
              if (!link) {
                throw new FS.ErrnoError(44);
              }
              if (!link.node_ops.readlink) {
                throw new FS.ErrnoError(28);
              }
              return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
            },
            stat: function (path, dontFollow) {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              var node = lookup.node;
              if (!node) {
                throw new FS.ErrnoError(44);
              }
              if (!node.node_ops.getattr) {
                throw new FS.ErrnoError(63);
              }
              return node.node_ops.getattr(node);
            },
            lstat: function (path) {
              return FS.stat(path, true);
            },
            chmod: function (path, mode, dontFollow) {
              var node;
              if (typeof path === 'string') {
                var lookup = FS.lookupPath(path, { follow: !dontFollow });
                node = lookup.node;
              } else {
                node = path;
              }
              if (!node.node_ops.setattr) {
                throw new FS.ErrnoError(63);
              }
              node.node_ops.setattr(node, {
                mode: (mode & 4095) | (node.mode & ~4095),
                timestamp: Date.now(),
              });
            },
            lchmod: function (path, mode) {
              FS.chmod(path, mode, true);
            },
            fchmod: function (fd, mode) {
              var stream = FS.getStream(fd);
              if (!stream) {
                throw new FS.ErrnoError(8);
              }
              FS.chmod(stream.node, mode);
            },
            chown: function (path, uid, gid, dontFollow) {
              var node;
              if (typeof path === 'string') {
                var lookup = FS.lookupPath(path, { follow: !dontFollow });
                node = lookup.node;
              } else {
                node = path;
              }
              if (!node.node_ops.setattr) {
                throw new FS.ErrnoError(63);
              }
              node.node_ops.setattr(node, { timestamp: Date.now() });
            },
            lchown: function (path, uid, gid) {
              FS.chown(path, uid, gid, true);
            },
            fchown: function (fd, uid, gid) {
              var stream = FS.getStream(fd);
              if (!stream) {
                throw new FS.ErrnoError(8);
              }
              FS.chown(stream.node, uid, gid);
            },
            truncate: function (path, len) {
              if (len < 0) {
                throw new FS.ErrnoError(28);
              }
              var node;
              if (typeof path === 'string') {
                var lookup = FS.lookupPath(path, { follow: true });
                node = lookup.node;
              } else {
                node = path;
              }
              if (!node.node_ops.setattr) {
                throw new FS.ErrnoError(63);
              }
              if (FS.isDir(node.mode)) {
                throw new FS.ErrnoError(31);
              }
              if (!FS.isFile(node.mode)) {
                throw new FS.ErrnoError(28);
              }
              var errCode = FS.nodePermissions(node, 'w');
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
            },
            ftruncate: function (fd, len) {
              var stream = FS.getStream(fd);
              if (!stream) {
                throw new FS.ErrnoError(8);
              }
              if ((stream.flags & 2097155) === 0) {
                throw new FS.ErrnoError(28);
              }
              FS.truncate(stream.node, len);
            },
            utime: function (path, atime, mtime) {
              var lookup = FS.lookupPath(path, { follow: true });
              var node = lookup.node;
              node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
            },
            open: function (path, flags, mode, fd_start, fd_end) {
              if (path === '') {
                throw new FS.ErrnoError(44);
              }
              flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
              mode = typeof mode === 'undefined' ? 438 : mode;
              if (flags & 64) {
                mode = (mode & 4095) | 32768;
              } else {
                mode = 0;
              }
              var node;
              if (typeof path === 'object') {
                node = path;
              } else {
                path = PATH.normalize(path);
                try {
                  var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
                  node = lookup.node;
                } catch (e) { }
              }
              var created = false;
              if (flags & 64) {
                if (node) {
                  if (flags & 128) {
                    throw new FS.ErrnoError(20);
                  }
                } else {
                  node = FS.mknod(path, mode, 0);
                  created = true;
                }
              }
              if (!node) {
                throw new FS.ErrnoError(44);
              }
              if (FS.isChrdev(node.mode)) {
                flags &= ~512;
              }
              if (flags & 65536 && !FS.isDir(node.mode)) {
                throw new FS.ErrnoError(54);
              }
              if (!created) {
                var errCode = FS.mayOpen(node, flags);
                if (errCode) {
                  throw new FS.ErrnoError(errCode);
                }
              }
              if (flags & 512) {
                FS.truncate(node, 0);
              }
              flags &= ~(128 | 512 | 131072);
              var stream = FS.createStream(
                {
                  node: node,
                  path: FS.getPath(node),
                  id: node.id,
                  flags: flags,
                  mode: node.mode,
                  seekable: true,
                  position: 0,
                  stream_ops: node.stream_ops,
                  node_ops: node.node_ops,
                  ungotten: [],
                  error: false,
                },
                fd_start,
                fd_end
              );
              if (stream.stream_ops.open) {
                stream.stream_ops.open(stream);
              }
              if (Module['logReadFiles'] && !(flags & 1)) {
                if (!FS.readFiles) FS.readFiles = {};
                if (!(path in FS.readFiles)) {
                  FS.readFiles[path] = 1;
                }
              }
              return stream;
            },
            close: function (stream) {
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
              }
              if (stream.getdents) stream.getdents = null;
              try {
                if (stream.stream_ops.close) {
                  stream.stream_ops.close(stream);
                }
              } catch (e) {
                throw e;
              } finally {
                FS.closeStream(stream.fd);
              }
              stream.fd = null;
            },
            isClosed: function (stream) {
              return stream.fd === null;
            },
            llseek: function (stream, offset, whence) {
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
              }
              if (!stream.seekable || !stream.stream_ops.llseek) {
                throw new FS.ErrnoError(70);
              }
              if (whence != 0 && whence != 1 && whence != 2) {
                throw new FS.ErrnoError(28);
              }
              stream.position = stream.stream_ops.llseek(stream, offset, whence);
              stream.ungotten = [];
              return stream.position;
            },
            read: function (stream, buffer, offset, length, position) {
              if (length < 0 || position < 0) {
                throw new FS.ErrnoError(28);
              }
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
              }
              if ((stream.flags & 2097155) === 1) {
                throw new FS.ErrnoError(8);
              }
              if (FS.isDir(stream.node.mode)) {
                throw new FS.ErrnoError(31);
              }
              if (!stream.stream_ops.read) {
                throw new FS.ErrnoError(28);
              }
              var seeking = typeof position !== 'undefined';
              if (!seeking) {
                position = stream.position;
              } else if (!stream.seekable) {
                throw new FS.ErrnoError(70);
              }
              var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
              if (!seeking) stream.position += bytesRead;
              return bytesRead;
            },
            write: function (stream, buffer, offset, length, position, canOwn) {
              if (length < 0 || position < 0) {
                throw new FS.ErrnoError(28);
              }
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
              }
              if ((stream.flags & 2097155) === 0) {
                throw new FS.ErrnoError(8);
              }
              if (FS.isDir(stream.node.mode)) {
                throw new FS.ErrnoError(31);
              }
              if (!stream.stream_ops.write) {
                throw new FS.ErrnoError(28);
              }
              if (stream.seekable && stream.flags & 1024) {
                FS.llseek(stream, 0, 2);
              }
              var seeking = typeof position !== 'undefined';
              if (!seeking) {
                position = stream.position;
              } else if (!stream.seekable) {
                throw new FS.ErrnoError(70);
              }
              var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
              if (!seeking) stream.position += bytesWritten;
              return bytesWritten;
            },
            allocate: function (stream, offset, length) {
              if (FS.isClosed(stream)) {
                throw new FS.ErrnoError(8);
              }
              if (offset < 0 || length <= 0) {
                throw new FS.ErrnoError(28);
              }
              if ((stream.flags & 2097155) === 0) {
                throw new FS.ErrnoError(8);
              }
              if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
                throw new FS.ErrnoError(43);
              }
              if (!stream.stream_ops.allocate) {
                throw new FS.ErrnoError(138);
              }
              stream.stream_ops.allocate(stream, offset, length);
            },
            mmap: function (stream, address, length, position, prot, flags) {
              if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
                throw new FS.ErrnoError(2);
              }
              if ((stream.flags & 2097155) === 1) {
                throw new FS.ErrnoError(2);
              }
              if (!stream.stream_ops.mmap) {
                throw new FS.ErrnoError(43);
              }
              return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
            },
            msync: function (stream, buffer, offset, length, mmapFlags) {
              if (!stream || !stream.stream_ops.msync) {
                return 0;
              }
              return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
            },
            munmap: function (stream) {
              return 0;
            },
            ioctl: function (stream, cmd, arg) {
              if (!stream.stream_ops.ioctl) {
                throw new FS.ErrnoError(59);
              }
              return stream.stream_ops.ioctl(stream, cmd, arg);
            },
            readFile: function (path, opts) {
              opts = opts || {};
              opts.flags = opts.flags || 0;
              opts.encoding = opts.encoding || 'binary';
              if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
                throw new Error('Invalid encoding type "' + opts.encoding + '"');
              }
              var ret;
              var stream = FS.open(path, opts.flags);
              var stat = FS.stat(path);
              var length = stat.size;
              var buf = new Uint8Array(length);
              FS.read(stream, buf, 0, length, 0);
              if (opts.encoding === 'utf8') {
                ret = UTF8ArrayToString(buf, 0);
              } else if (opts.encoding === 'binary') {
                ret = buf;
              }
              FS.close(stream);
              return ret;
            },
            writeFile: function (path, data, opts) {
              opts = opts || {};
              opts.flags = opts.flags || 577;
              var stream = FS.open(path, opts.flags, opts.mode);
              if (typeof data === 'string') {
                var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
                var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
                FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
              } else if (ArrayBuffer.isView(data)) {
                FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
              } else {
                throw new Error('Unsupported data type');
              }
              FS.close(stream);
            },
            cwd: function () {
              return FS.currentPath;
            },
            chdir: function (path) {
              var lookup = FS.lookupPath(path, { follow: true });
              if (lookup.node === null) {
                throw new FS.ErrnoError(44);
              }
              if (!FS.isDir(lookup.node.mode)) {
                throw new FS.ErrnoError(54);
              }
              var errCode = FS.nodePermissions(lookup.node, 'x');
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
              FS.currentPath = lookup.path;
            },
            createDefaultDirectories: function () {
              FS.mkdir('/tmp');
              FS.mkdir('/home');
              FS.mkdir('/home/web_user');
            },
            createDefaultDevices: function () {
              FS.mkdir('/dev');
              FS.registerDevice(FS.makedev(1, 3), {
                read: function () {
                  return 0;
                },
                write: function (stream, buffer, offset, length, pos) {
                  return length;
                },
              });
              FS.mkdev('/dev/null', FS.makedev(1, 3));
              TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
              TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
              FS.mkdev('/dev/tty', FS.makedev(5, 0));
              FS.mkdev('/dev/tty1', FS.makedev(6, 0));
              var random_device = getRandomDevice();
              FS.createDevice('/dev', 'random', random_device);
              FS.createDevice('/dev', 'urandom', random_device);
              FS.mkdir('/dev/shm');
              FS.mkdir('/dev/shm/tmp');
            },
            createSpecialDirectories: function () {
              FS.mkdir('/proc');
              var proc_self = FS.mkdir('/proc/self');
              FS.mkdir('/proc/self/fd');
              FS.mount(
                {
                  mount: function () {
                    var node = FS.createNode(proc_self, 'fd', 16384 | 511, 73);
                    node.node_ops = {
                      lookup: function (parent, name) {
                        var fd = +name;
                        var stream = FS.getStream(fd);
                        if (!stream) throw new FS.ErrnoError(8);
                        var ret = {
                          parent: null,
                          mount: { mountpoint: 'fake' },
                          node_ops: {
                            readlink: function () {
                              return stream.path;
                            },
                          },
                        };
                        ret.parent = ret;
                        return ret;
                      },
                    };
                    return node;
                  },
                },
                {},
                '/proc/self/fd'
              );
            },
            createStandardStreams: function () {
              if (Module['stdin']) {
                FS.createDevice('/dev', 'stdin', Module['stdin']);
              } else {
                FS.symlink('/dev/tty', '/dev/stdin');
              }
              if (Module['stdout']) {
                FS.createDevice('/dev', 'stdout', null, Module['stdout']);
              } else {
                FS.symlink('/dev/tty', '/dev/stdout');
              }
              if (Module['stderr']) {
                FS.createDevice('/dev', 'stderr', null, Module['stderr']);
              } else {
                FS.symlink('/dev/tty1', '/dev/stderr');
              }
              var stdin = FS.open('/dev/stdin', 0);
              var stdout = FS.open('/dev/stdout', 1);
              var stderr = FS.open('/dev/stderr', 1);
            },
            ensureErrnoError: function () {
              if (FS.ErrnoError) return;
              FS.ErrnoError = function ErrnoError(errno, node) {
                this.node = node;
                this.setErrno = function (errno) {
                  this.errno = errno;
                };
                this.setErrno(errno);
                this.message = 'FS error';
              };
              FS.ErrnoError.prototype = new Error();
              FS.ErrnoError.prototype.constructor = FS.ErrnoError;
              [44].forEach(function (code) {
                FS.genericErrors[code] = new FS.ErrnoError(code);
                FS.genericErrors[code].stack = '<generic error, no stack>';
              });
            },
            staticInit: function () {
              FS.ensureErrnoError();
              FS.nameTable = new Array(4096);
              FS.mount(MEMFS, {}, '/');
              FS.createDefaultDirectories();
              FS.createDefaultDevices();
              FS.createSpecialDirectories();
              FS.filesystems = { MEMFS: MEMFS };
            },
            init: function (input, output, error) {
              FS.init.initialized = true;
              FS.ensureErrnoError();
              Module['stdin'] = input || Module['stdin'];
              Module['stdout'] = output || Module['stdout'];
              Module['stderr'] = error || Module['stderr'];
              FS.createStandardStreams();
            },
            quit: function () {
              FS.init.initialized = false;
              var fflush = Module['_fflush'];
              if (fflush) fflush(0);
              for (var i = 0; i < FS.streams.length; i++) {
                var stream = FS.streams[i];
                if (!stream) {
                  continue;
                }
                FS.close(stream);
              }
            },
            getMode: function (canRead, canWrite) {
              var mode = 0;
              if (canRead) mode |= 292 | 73;
              if (canWrite) mode |= 146;
              return mode;
            },
            findObject: function (path, dontResolveLastLink) {
              var ret = FS.analyzePath(path, dontResolveLastLink);
              if (ret.exists) {
                return ret.object;
              } else {
                return null;
              }
            },
            analyzePath: function (path, dontResolveLastLink) {
              try {
                var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
                path = lookup.path;
              } catch (e) { }
              var ret = {
                isRoot: false,
                exists: false,
                error: 0,
                name: null,
                path: null,
                object: null,
                parentExists: false,
                parentPath: null,
                parentObject: null,
              };
              try {
                var lookup = FS.lookupPath(path, { parent: true });
                ret.parentExists = true;
                ret.parentPath = lookup.path;
                ret.parentObject = lookup.node;
                ret.name = PATH.basename(path);
                lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
                ret.exists = true;
                ret.path = lookup.path;
                ret.object = lookup.node;
                ret.name = lookup.node.name;
                ret.isRoot = lookup.path === '/';
              } catch (e) {
                ret.error = e.errno;
              }
              return ret;
            },
            createPath: function (parent, path, canRead, canWrite) {
              parent = typeof parent === 'string' ? parent : FS.getPath(parent);
              var parts = path.split('/').reverse();
              while (parts.length) {
                var part = parts.pop();
                if (!part) continue;
                var current = PATH.join2(parent, part);
                try {
                  FS.mkdir(current);
                } catch (e) { }
                parent = current;
              }
              return current;
            },
            createFile: function (parent, name, properties, canRead, canWrite) {
              var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
              var mode = FS.getMode(canRead, canWrite);
              return FS.create(path, mode);
            },
            createDataFile: function (parent, name, data, canRead, canWrite, canOwn) {
              var path = name
                ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name)
                : parent;
              var mode = FS.getMode(canRead, canWrite);
              var node = FS.create(path, mode);
              if (data) {
                if (typeof data === 'string') {
                  var arr = new Array(data.length);
                  for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
                  data = arr;
                }
                FS.chmod(node, mode | 146);
                var stream = FS.open(node, 577);
                FS.write(stream, data, 0, data.length, 0, canOwn);
                FS.close(stream);
                FS.chmod(node, mode);
              }
              return node;
            },
            createDevice: function (parent, name, input, output) {
              var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
              var mode = FS.getMode(!!input, !!output);
              if (!FS.createDevice.major) FS.createDevice.major = 64;
              var dev = FS.makedev(FS.createDevice.major++, 0);
              FS.registerDevice(dev, {
                open: function (stream) {
                  stream.seekable = false;
                },
                close: function (stream) {
                  if (output && output.buffer && output.buffer.length) {
                    output(10);
                  }
                },
                read: function (stream, buffer, offset, length, pos) {
                  var bytesRead = 0;
                  for (var i = 0; i < length; i++) {
                    var result;
                    try {
                      result = input();
                    } catch (e) {
                      throw new FS.ErrnoError(29);
                    }
                    if (result === undefined && bytesRead === 0) {
                      throw new FS.ErrnoError(6);
                    }
                    if (result === null || result === undefined) break;
                    bytesRead++;
                    buffer[offset + i] = result;
                  }
                  if (bytesRead) {
                    stream.node.timestamp = Date.now();
                  }
                  return bytesRead;
                },
                write: function (stream, buffer, offset, length, pos) {
                  for (var i = 0; i < length; i++) {
                    try {
                      output(buffer[offset + i]);
                    } catch (e) {
                      throw new FS.ErrnoError(29);
                    }
                  }
                  if (length) {
                    stream.node.timestamp = Date.now();
                  }
                  return i;
                },
              });
              return FS.mkdev(path, mode, dev);
            },
            forceLoadFile: function (obj) {
              if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
              if (typeof XMLHttpRequest !== 'undefined') {
                throw new Error(
                  'Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.'
                );
              } else if (read_) {
                try {
                  obj.contents = intArrayFromString(read_(obj.url), true);
                  obj.usedBytes = obj.contents.length;
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
              } else {
                throw new Error('Cannot load without read() or XMLHttpRequest.');
              }
            },
            createLazyFile: function (parent, name, url, canRead, canWrite) {

              function LazyUint8Array() {
                this.lengthKnown = false;
                this.chunks = [];
              }
              LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
                if (idx > this.length - 1 || idx < 0) {
                  return undefined;
                }
                var chunkOffset = idx % this.chunkSize;
                var chunkNum = (idx / this.chunkSize) | 0;
                return this.getter(chunkNum)[chunkOffset];
              };
              LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
                this.getter = getter;
              };
              LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
                var xhr = new XMLHttpRequest();
                xhr.open('HEAD', url, false);
                xhr.send(null);
                if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))
                  throw new Error("Couldn't load " + url + '. Status: ' + xhr.status);
                var datalength = Number(xhr.getResponseHeader('Content-length'));
                var header;
                var hasByteServing = (header = xhr.getResponseHeader('Accept-Ranges')) && header === 'bytes';
                var usesGzip = (header = xhr.getResponseHeader('Content-Encoding')) && header === 'gzip';
                var chunkSize = 1024 * 1024;
                if (!hasByteServing) chunkSize = datalength;
                var doXHR = function (from, to) {
                  if (from > to)
                    throw new Error('invalid range (' + from + ', ' + to + ') or no bytes requested!');
                  if (to > datalength - 1)
                    throw new Error('only ' + datalength + ' bytes available! programmer error!');
                  var xhr = new XMLHttpRequest();
                  xhr.open('GET', url, false);
                  if (datalength !== chunkSize) xhr.setRequestHeader('Range', 'bytes=' + from + '-' + to);
                  if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
                  if (xhr.overrideMimeType) {
                    xhr.overrideMimeType('text/plain; charset=x-user-defined');
                  }
                  xhr.send(null);
                  if (!((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304))
                    throw new Error("Couldn't load " + url + '. Status: ' + xhr.status);
                  if (xhr.response !== undefined) {
                    return new Uint8Array(xhr.response || []);
                  } else {
                    return intArrayFromString(xhr.responseText || '', true);
                  }
                };
                var lazyArray = this;
                lazyArray.setDataGetter(function (chunkNum) {
                  var start = chunkNum * chunkSize;
                  var end = (chunkNum + 1) * chunkSize - 1;
                  end = Math.min(end, datalength - 1);
                  if (typeof lazyArray.chunks[chunkNum] === 'undefined') {
                    lazyArray.chunks[chunkNum] = doXHR(start, end);
                  }
                  if (typeof lazyArray.chunks[chunkNum] === 'undefined') throw new Error('doXHR failed!');
                  return lazyArray.chunks[chunkNum];
                });
                if (usesGzip || !datalength) {
                  chunkSize = datalength = 1;
                  datalength = this.getter(0).length;
                  chunkSize = datalength;
                  out('LazyFiles on gzip forces download of the whole file when length is accessed');
                }
                this._length = datalength;
                this._chunkSize = chunkSize;
                this.lengthKnown = true;
              };
              if (typeof XMLHttpRequest !== 'undefined') {
                if (!ENVIRONMENT_IS_WORKER)
                  throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
                var lazyArray = new LazyUint8Array();
                Object.defineProperties(lazyArray, {
                  length: {
                    get: function () {
                      if (!this.lengthKnown) {
                        this.cacheLength();
                      }
                      return this._length;
                    },
                  },
                  chunkSize: {
                    get: function () {
                      if (!this.lengthKnown) {
                        this.cacheLength();
                      }
                      return this._chunkSize;
                    },
                  },
                });
                var properties = { isDevice: false, contents: lazyArray };
              } else {
                var properties = { isDevice: false, url: url };
              }
              var node = FS.createFile(parent, name, properties, canRead, canWrite);
              if (properties.contents) {
                node.contents = properties.contents;
              } else if (properties.url) {
                node.contents = null;
                node.url = properties.url;
              }
              Object.defineProperties(node, {
                usedBytes: {
                  get: function () {
                    return this.contents.length;
                  },
                },
              });
              var stream_ops = {};
              var keys = Object.keys(node.stream_ops);
              keys.forEach(function (key) {
                var fn = node.stream_ops[key];
                stream_ops[key] = function forceLoadLazyFile() {
                  FS.forceLoadFile(node);
                  return fn.apply(null, arguments);
                };
              });
              stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
                FS.forceLoadFile(node);
                var contents = stream.node.contents;
                if (position >= contents.length) return 0;
                var size = Math.min(contents.length - position, length);
                if (contents.slice) {
                  for (var i = 0; i < size; i++) {
                    buffer[offset + i] = contents[position + i];
                  }
                } else {
                  for (var i = 0; i < size; i++) {
                    buffer[offset + i] = contents.get(position + i);
                  }
                }
                return size;
              };
              node.stream_ops = stream_ops;
              return node;
            },
            createPreloadedFile: function (
              parent,
              name,
              url,
              canRead,
              canWrite,
              onload,
              onerror,
              dontCreateFile,
              canOwn,
              preFinish
            ) {
              Browser.init();
              var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
              var dep = getUniqueRunDependency('cp ' + fullname);

              function processData(byteArray) {

                function finish(byteArray) {
                  if (preFinish) preFinish();
                  if (!dontCreateFile) {
                    FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
                  }
                  if (onload) onload();
                  removeRunDependency(dep);
                }
                var handled = false;
                Module['preloadPlugins'].forEach(function (plugin) {
                  if (handled) return;
                  if (plugin['canHandle'](fullname)) {
                    plugin['handle'](byteArray, fullname, finish, function () {
                      if (onerror) onerror();
                      removeRunDependency(dep);
                    });
                    handled = true;
                  }
                });
                if (!handled) finish(byteArray);
              }
              addRunDependency(dep);
              if (typeof url == 'string') {
                asyncLoad(
                  url,
                  function (byteArray) {
                    processData(byteArray);
                  },
                  onerror
                );
              } else {
                processData(url);
              }
            },
            indexedDB: function () {
              return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
            },
            DB_NAME: function () {
              return 'EM_FS_' + window.location.pathname;
            },
            DB_VERSION: 20,
            DB_STORE_NAME: 'FILE_DATA',
            saveFilesToDB: function (paths, onload, onerror) {
              onload = onload || function () { };
              onerror = onerror || function () { };
              var indexedDB = FS.indexedDB();
              try {
                var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
              } catch (e) {
                return onerror(e);
              }
              openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
                out('creating db');
                var db = openRequest.result;
                db.createObjectStore(FS.DB_STORE_NAME);
              };
              openRequest.onsuccess = function openRequest_onsuccess() {
                var db = openRequest.result;
                var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
                var files = transaction.objectStore(FS.DB_STORE_NAME);
                var ok = 0,
                  fail = 0,
                  total = paths.length;

                function finish() {
                  if (fail == 0) onload();
                  else onerror();
                }
                paths.forEach(function (path) {
                  var putRequest = files.put(FS.analyzePath(path).object.contents, path);
                  putRequest.onsuccess = function putRequest_onsuccess() {
                    ok++;
                    if (ok + fail == total) finish();
                  };
                  putRequest.onerror = function putRequest_onerror() {
                    fail++;
                    if (ok + fail == total) finish();
                  };
                });
                transaction.onerror = onerror;
              };
              openRequest.onerror = onerror;
            },
            loadFilesFromDB: function (paths, onload, onerror) {
              onload = onload || function () { };
              onerror = onerror || function () { };
              var indexedDB = FS.indexedDB();
              try {
                var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
              } catch (e) {
                return onerror(e);
              }
              openRequest.onupgradeneeded = onerror;
              openRequest.onsuccess = function openRequest_onsuccess() {
                var db = openRequest.result;
                try {
                  var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
                } catch (e) {
                  onerror(e);
                  return;
                }
                var files = transaction.objectStore(FS.DB_STORE_NAME);
                var ok = 0,
                  fail = 0,
                  total = paths.length;

                function finish() {
                  if (fail == 0) onload();
                  else onerror();
                }
                paths.forEach(function (path) {
                  var getRequest = files.get(path);
                  getRequest.onsuccess = function getRequest_onsuccess() {
                    if (FS.analyzePath(path).exists) {
                      FS.unlink(path);
                    }
                    FS.createDataFile(
                      PATH.dirname(path),
                      PATH.basename(path),
                      getRequest.result,
                      true,
                      true,
                      true
                    );
                    ok++;
                    if (ok + fail == total) finish();
                  };
                  getRequest.onerror = function getRequest_onerror() {
                    fail++;
                    if (ok + fail == total) finish();
                  };
                });
                transaction.onerror = onerror;
              };
              openRequest.onerror = onerror;
            },
          };
          var SYSCALLS = {
            mappings: {},
            DEFAULT_POLLMASK: 5,
            calculateAt: function (dirfd, path, allowEmpty) {
              if (path[0] === '/') {
                return path;
              }
              var dir;
              if (dirfd === -100) {
                dir = FS.cwd();
              } else {
                var dirstream = FS.getStream(dirfd);
                if (!dirstream) throw new FS.ErrnoError(8);
                dir = dirstream.path;
              }
              if (path.length == 0) {
                if (!allowEmpty) {
                  throw new FS.ErrnoError(44);
                }
                return dir;
              }
              return PATH.join2(dir, path);
            },
            doStat: function (func, path, buf) {
              try {
                var stat = func(path);
              } catch (e) {
                if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
                  return -54;
                }
                throw e;
              }
              HEAP32[buf >> 2] = stat.dev;
              HEAP32[(buf + 4) >> 2] = 0;
              HEAP32[(buf + 8) >> 2] = stat.ino;
              HEAP32[(buf + 12) >> 2] = stat.mode;
              HEAP32[(buf + 16) >> 2] = stat.nlink;
              HEAP32[(buf + 20) >> 2] = stat.uid;
              HEAP32[(buf + 24) >> 2] = stat.gid;
              HEAP32[(buf + 28) >> 2] = stat.rdev;
              HEAP32[(buf + 32) >> 2] = 0;
              (tempI64 = [
                stat.size >>> 0,
                ((tempDouble = stat.size),
                  +Math.abs(tempDouble) >= 1
                    ? tempDouble > 0
                      ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0
                      : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0
                    : 0),
              ]),
                (HEAP32[(buf + 40) >> 2] = tempI64[0]),
                (HEAP32[(buf + 44) >> 2] = tempI64[1]);
              HEAP32[(buf + 48) >> 2] = 4096;
              HEAP32[(buf + 52) >> 2] = stat.blocks;
              HEAP32[(buf + 56) >> 2] = (stat.atime.getTime() / 1e3) | 0;
              HEAP32[(buf + 60) >> 2] = 0;
              HEAP32[(buf + 64) >> 2] = (stat.mtime.getTime() / 1e3) | 0;
              HEAP32[(buf + 68) >> 2] = 0;
              HEAP32[(buf + 72) >> 2] = (stat.ctime.getTime() / 1e3) | 0;
              HEAP32[(buf + 76) >> 2] = 0;
              (tempI64 = [
                stat.ino >>> 0,
                ((tempDouble = stat.ino),
                  +Math.abs(tempDouble) >= 1
                    ? tempDouble > 0
                      ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0
                      : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0
                    : 0),
              ]),
                (HEAP32[(buf + 80) >> 2] = tempI64[0]),
                (HEAP32[(buf + 84) >> 2] = tempI64[1]);
              return 0;
            },
            doMsync: function (addr, stream, len, flags, offset) {
              var buffer = HEAPU8.slice(addr, addr + len);
              FS.msync(stream, buffer, offset, len, flags);
            },
            doMkdir: function (path, mode) {
              path = PATH.normalize(path);
              if (path[path.length - 1] === '/') path = path.substr(0, path.length - 1);
              FS.mkdir(path, mode, 0);
              return 0;
            },
            doMknod: function (path, mode, dev) {
              switch (mode & 61440) {
                case 32768:
                case 8192:
                case 24576:
                case 4096:
                case 49152:
                  break;
                default:
                  return -28;
              }
              FS.mknod(path, mode, dev);
              return 0;
            },
            doReadlink: function (path, buf, bufsize) {
              if (bufsize <= 0) return -28;
              var ret = FS.readlink(path);
              var len = Math.min(bufsize, lengthBytesUTF8(ret));
              var endChar = HEAP8[buf + len];
              stringToUTF8(ret, buf, bufsize + 1);
              HEAP8[buf + len] = endChar;
              return len;
            },
            doAccess: function (path, amode) {
              if (amode & ~7) {
                return -28;
              }
              var lookup = FS.lookupPath(path, { follow: true });
              var node = lookup.node;
              if (!node) {
                return -44;
              }
              var perms = '';
              if (amode & 4) perms += 'r';
              if (amode & 2) perms += 'w';
              if (amode & 1) perms += 'x';
              if (perms && FS.nodePermissions(node, perms)) {
                return -2;
              }
              return 0;
            },
            doDup: function (path, flags, suggestFD) {
              var suggest = FS.getStream(suggestFD);
              if (suggest) FS.close(suggest);
              return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
            },
            doReadv: function (stream, iov, iovcnt, offset) {
              var ret = 0;
              for (var i = 0; i < iovcnt; i++) {
                var ptr = HEAP32[(iov + i * 8) >> 2];
                var len = HEAP32[(iov + (i * 8 + 4)) >> 2];
                var curr = FS.read(stream, HEAP8, ptr, len, offset);
                if (curr < 0) return -1;
                ret += curr;
                if (curr < len) break;
              }
              return ret;
            },
            doWritev: function (stream, iov, iovcnt, offset) {
              var ret = 0;
              for (var i = 0; i < iovcnt; i++) {
                var ptr = HEAP32[(iov + i * 8) >> 2];
                var len = HEAP32[(iov + (i * 8 + 4)) >> 2];
                var curr = FS.write(stream, HEAP8, ptr, len, offset);
                if (curr < 0) return -1;
                ret += curr;
              }
              return ret;
            },
            varargs: undefined,
            get: function () {
              SYSCALLS.varargs += 4;
              var ret = HEAP32[(SYSCALLS.varargs - 4) >> 2];
              return ret;
            },
            getStr: function (ptr) {
              var ret = UTF8ToString(ptr);
              return ret;
            },
            getStreamFromFD: function (fd) {
              var stream = FS.getStream(fd);
              if (!stream) throw new FS.ErrnoError(8);
              return stream;
            },
            get64: function (low, high) {
              return low;
            },
          };

          function _fd_close(fd) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              FS.close(stream);
              return 0;
            } catch (e) {
              if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
              return e.errno;
            }
          }

          function _fd_read(fd, iov, iovcnt, pnum) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = SYSCALLS.doReadv(stream, iov, iovcnt);
              HEAP32[pnum >> 2] = num;
              return 0;
            } catch (e) {
              if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
              return e.errno;
            }
          }

          function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var HIGH_OFFSET = 4294967296;
              var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
              var DOUBLE_LIMIT = 9007199254740992;
              if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
                return -61;
              }
              FS.llseek(stream, offset, whence);
              (tempI64 = [
                stream.position >>> 0,
                ((tempDouble = stream.position),
                  +Math.abs(tempDouble) >= 1
                    ? tempDouble > 0
                      ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0
                      : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0
                    : 0),
              ]),
                (HEAP32[newOffset >> 2] = tempI64[0]),
                (HEAP32[(newOffset + 4) >> 2] = tempI64[1]);
              if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
              return 0;
            } catch (e) {
              if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
              return e.errno;
            }
          }

          function _fd_write(fd, iov, iovcnt, pnum) {
            try {
              var stream = SYSCALLS.getStreamFromFD(fd);
              var num = SYSCALLS.doWritev(stream, iov, iovcnt);
              HEAP32[pnum >> 2] = num;
              return 0;
            } catch (e) {
              if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) throw e;
              return e.errno;
            }
          }

          function _proc_exit(code) {
            procExit(code);
          }
          var FSNode = function (parent, name, mode, rdev) {
            if (!parent) {
              parent = this;
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = FS.nextInode++;
            this.name = name;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
          };
          var readMode = 292 | 73;
          var writeMode = 146;
          Object.defineProperties(FSNode.prototype, {
            read: {
              get: function () {
                return (this.mode & readMode) === readMode;
              },
              set: function (val) {
                val ? (this.mode |= readMode) : (this.mode &= ~readMode);
              },
            },
            write: {
              get: function () {
                return (this.mode & writeMode) === writeMode;
              },
              set: function (val) {
                val ? (this.mode |= writeMode) : (this.mode &= ~writeMode);
              },
            },
            isFolder: {
              get: function () {
                return FS.isDir(this.mode);
              },
            },
            isDevice: {
              get: function () {
                return FS.isChrdev(this.mode);
              },
            },
          });
          FS.FSNode = FSNode;
          FS.staticInit();

          function intArrayFromString(stringy, dontAddNull, length) {
            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
            var u8array = new Array(len);
            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
            if (dontAddNull) u8array.length = numBytesWritten;
            return u8array;
          }
          var asmLibraryArg = {
            fd_close: _fd_close,
            fd_read: _fd_read,
            fd_seek: _fd_seek,
            fd_write: _fd_write,
            proc_exit: _proc_exit,
          };
          var asm = createWasm();
          var _SchnorrQ_KeyGeneration = (Module['_SchnorrQ_KeyGeneration'] = function () {
            return (_SchnorrQ_KeyGeneration = Module['_SchnorrQ_KeyGeneration'] =
              Module['asm']['SchnorrQ_KeyGeneration']).apply(null, arguments);
          });
          var _KangarooTwelve = (Module['_KangarooTwelve'] = function () {
            return (_KangarooTwelve = Module['_KangarooTwelve'] = Module['asm']['KangarooTwelve']).apply(
              null,
              arguments
            );
          });
          var _SchnorrQ_Sign = (Module['_SchnorrQ_Sign'] = function () {
            return (_SchnorrQ_Sign = Module['_SchnorrQ_Sign'] = Module['asm']['SchnorrQ_Sign']).apply(
              null,
              arguments
            );
          });
          var _free = (Module['_free'] = function () {
            return (_free = Module['_free'] = Module['asm']['free']).apply(null, arguments);
          });
          var _SchnorrQ_Verify = (Module['_SchnorrQ_Verify'] = function () {
            return (_SchnorrQ_Verify = Module['_SchnorrQ_Verify'] = Module['asm']['SchnorrQ_Verify']).apply(
              null,
              arguments
            );
          });
          var _CompressedPublicKeyGeneration = (Module['_CompressedPublicKeyGeneration'] = function () {
            return (_CompressedPublicKeyGeneration = Module['_CompressedPublicKeyGeneration'] =
              Module['asm']['CompressedPublicKeyGeneration']).apply(null, arguments);
          });
          var _CompressedKeyGeneration = (Module['_CompressedKeyGeneration'] = function () {
            return (_CompressedKeyGeneration = Module['_CompressedKeyGeneration'] =
              Module['asm']['CompressedKeyGeneration']).apply(null, arguments);
          });
          var _CompressedSecretAgreement = (Module['_CompressedSecretAgreement'] = function () {
            return (_CompressedSecretAgreement = Module['_CompressedSecretAgreement'] =
              Module['asm']['CompressedSecretAgreement']).apply(null, arguments);
          });
          var _PublicKeyGeneration = (Module['_PublicKeyGeneration'] = function () {
            return (_PublicKeyGeneration = Module['_PublicKeyGeneration'] =
              Module['asm']['PublicKeyGeneration']).apply(null, arguments);
          });
          var _KeyGeneration = (Module['_KeyGeneration'] = function () {
            return (_KeyGeneration = Module['_KeyGeneration'] = Module['asm']['KeyGeneration']).apply(
              null,
              arguments
            );
          });
          var _SecretAgreement = (Module['_SecretAgreement'] = function () {
            return (_SecretAgreement = Module['_SecretAgreement'] = Module['asm']['SecretAgreement']).apply(
              null,
              arguments
            );
          });
          var __initialize = (Module['__initialize'] = function () {
            return (__initialize = Module['__initialize'] = Module['asm']['_initialize']).apply(
              null,
              arguments
            );
          });
          var _malloc = (Module['_malloc'] = function () {
            return (_malloc = Module['_malloc'] = Module['asm']['malloc']).apply(null, arguments);
          });
          var calledRun;

          function ExitStatus(status) {
            this.name = 'ExitStatus';
            this.message = 'Program terminated with exit(' + status + ')';
            this.status = status;
          }
          var calledMain = false;
          var mainArgs = undefined;
          dependenciesFulfilled = function runCaller() {
            if (!calledRun) run();
            if (!calledRun) dependenciesFulfilled = runCaller;
          };

          function callMain(args) {
            var entryFunction = Module['__initialize'];
            mainArgs = [thisProgram].concat(args);
            try {
              entryFunction();
              var ret = 0;
              exit(ret, true);
              return ret;
            } catch (e) {
              return handleException(e);
            } finally {
              calledMain = true;
            }
          }

          function run(args) {
            args = args || arguments_;
            if (runDependencies > 0) {
              return;
            }
            preRun();
            if (runDependencies > 0) {
              return;
            }

            function doRun() {
              if (calledRun) return;
              calledRun = true;
              Module['calledRun'] = true;
              if (ABORT) return;
              initRuntime();
              preMain();
              if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();
              if (shouldRunNow) callMain(args);
              postRun();
            }
            if (Module['setStatus']) {
              Module['setStatus']('Running...');
              setTimeout(function () {
                setTimeout(function () {
                  Module['setStatus']('');
                }, 1);
                doRun();
              }, 1);
            } else {
              doRun();
            }
          }
          Module['run'] = run;

          function exit(status, implicit) {
            EXITSTATUS = status;
            if (keepRuntimeAlive()) {
            } else {
              exitRuntime();
            }
            procExit(status);
          }

          function procExit(code) {
            EXITSTATUS = code;
            if (!keepRuntimeAlive()) {
              if (Module['onExit']) Module['onExit'](code);
              ABORT = true;
            }
            quit_(code, new ExitStatus(code));
          }
          if (Module['preInit']) {
            if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
            while (Module['preInit'].length > 0) {
              Module['preInit'].pop()();
            }
          }
          var shouldRunNow = true;
          if (Module['noInitialRun']) shouldRunNow = false;
          run();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Module);

          /***/
})

      /******/
});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
        /******/
}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
        /******/
};
/******/
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
      /******/
}
/******/
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for (var key in definition) {
/******/ 				if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
            /******/
}
          /******/
}
        /******/
};
      /******/
})();
/******/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function () {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
          /******/
} catch (e) {
/******/ 				if (typeof window === 'object') return window;
          /******/
}
        /******/
})();
      /******/
})();
/******/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
      /******/
})();
/******/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
          /******/
}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
        /******/
};
      /******/
})();
/******/
/************************************************************************/
/******/
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/
/******/ 	return __webpack_exports__;
    /******/
})()
    ;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXViaWMtanMtbGlicmFyeS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTzs7Ozs7Ozs7O0FDVkEsbUNBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHVEQUF1RDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5QkFBeUI7QUFDbkMsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLG9DQUFvQyxtREFBbUQsR0FBRyxFQUFFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0EsNkJBQTZCLDZCQUE2QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixFQUFFO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDLDJCQUEyQixrQkFBa0I7QUFDN0MsMkJBQTJCLGtCQUFrQjtBQUM3QywyQkFBMkIsa0JBQWtCO0FBQzdDLDJCQUEyQixrQkFBa0I7QUFDN0MsMkJBQTJCLGtCQUFrQjtBQUM3Qyw4QkFBOEIsa0JBQWtCO0FBQ2hELDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0NBQXdDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDLGdEQUFnRCxtREFBbUQsR0FBRyxFQUFFO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDLCtDQUErQyxtREFBbUQsR0FBRyxFQUFFO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsZ0RBQWdELG1EQUFtRCxHQUFHLEVBQUU7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSx1Q0FBdUMsa0VBQWtFLEdBQUcsRUFBRTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUIsMkRBQTJELEVBQUU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQyw2Q0FBNkMsbURBQW1ELEdBQUcsRUFBRTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQywrQ0FBK0MsbURBQW1ELEdBQUcsRUFBRTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsdURBQXVELEVBQUU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsOENBQThDLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsR0FBRztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxLQUFLO0FBQy9DLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxvQ0FBb0MsbURBQW1ELEdBQUcsR0FBRztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsS0FBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBLHNCQUFzQixlQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsS0FBSztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FB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QUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsbUNBQW1DO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZUFBZSx1REFBdUQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3QkFBd0I7QUFDeEIsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sK0NBQStDLHFCQUFxQjtBQUNwRTtB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QUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHVDQUF1QyxjQUFjO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsTUFBTTs7Ozs7O1VDOXNHckI7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0EsQ0FBQzs7Ozs7V0NQRDs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7O1VFTkE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9xbGkvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL3FsaS8uL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLmpzIiwid2VicGFjazovL3FsaS8uL25vZGVfbW9kdWxlcy9uZXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcWxpLy4vc3JjL1F1YmljQ29ubmVjdG9yLnRzIiwid2VicGFjazovL3FsaS8uL3NyYy9RdWJpY0RlZmluaXRpb25zLnRzIiwid2VicGFjazovL3FsaS8uL3NyYy9RdWJpY1BhY2thZ2VCdWlsZGVyLnRzIiwid2VicGFjazovL3FsaS8uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly9xbGkvLi9zcmMva2V5SGVscGVyLnRzIiwid2VicGFjazovL3FsaS8uL3NyYy9xdWJpYy1jb21tdW5pY2F0aW9uL1F1YmljRW50aXR5UmVxdWVzdC50cyIsIndlYnBhY2s6Ly9xbGkvLi9zcmMvcXViaWMtY29tbXVuaWNhdGlvbi9RdWJpY0VudGl0eVJlc3BvbnNlLnRzIiwid2VicGFjazovL3FsaS8uL3NyYy9xdWJpYy1jb21tdW5pY2F0aW9uL1F1YmljUGFja2FnZVR5cGUudHMiLCJ3ZWJwYWNrOi8vcWxpLy4vc3JjL3F1YmljLWNvbW11bmljYXRpb24vUmVjZWl2ZWRQYWNrYWdlLnRzIiwid2VicGFjazovL3FsaS8uL3NyYy9xdWJpYy1jb21tdW5pY2F0aW9uL1JlcXVlc3RSZXNwb25zZUhlYWRlci50cyIsIndlYnBhY2s6Ly9xbGkvLi9zcmMvcXViaWMtdHlwZXMvRHluYW1pY1BheWxvYWQudHMiLCJ3ZWJwYWNrOi8vcWxpLy4vc3JjL3F1YmljLXR5cGVzL0xvbmcudHMiLCJ3ZWJwYWNrOi8vcWxpLy4vc3JjL3F1YmljLXR5cGVzL1B1YmxpY0tleS50cyIsIndlYnBhY2s6Ly9xbGkvLi9zcmMvcXViaWMtdHlwZXMvUXViaWNFbnRpdHkudHMiLCJ3ZWJwYWNrOi8vcWxpLy4vc3JjL3F1YmljLXR5cGVzL1F1YmljVGlja0RhdGEudHMiLCJ3ZWJwYWNrOi8vcWxpLy4vc3JjL3F1YmljLXR5cGVzL1F1YmljVGlja0luZm8udHMiLCJ3ZWJwYWNrOi8vcWxpLy4vc3JjL3F1YmljLXR5cGVzL1F1YmljVHJhbnNhY3Rpb24udHMiLCJ3ZWJwYWNrOi8vcWxpLy4vc3JjL3F1YmljLXR5cGVzL1NpZ25hdHVyZS50cyIsIndlYnBhY2s6Ly9xbGkvLi9zcmMvcXViaWMtdHlwZXMvdHJhbnNhY2lvbi1wYXlsb2Fkcy9RdWJpY1RyYW5zZmVyQXNzZXRQYXlsb2FkLnRzIiwid2VicGFjazovL3FsaS8uL3NyYy9xdWJpYy10eXBlcy90cmFuc2FjaW9uLXBheWxvYWRzL1F1YmljVHJhbnNmZXJTZW5kTWFueVBheWxvYWQudHMiLCJ3ZWJwYWNrOi8vcWxpLy4vc3JjL3F1YmljSGVscGVyLnRzIiwid2VicGFjazovL3FsaS8uL3NyYy9jb252ZXJ0ZXIvY29udmVydGVyLmpzIiwid2VicGFjazovL3FsaS8uL3NyYy9jcnlwdG8vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcWxpLy4vc3JjL2NyeXB0by9rZWNjYWtwLmpzIiwid2VicGFjazovL3FsaS8uL3NyYy9jcnlwdG8vbGliRm91clFfSzEyLmpzIiwid2VicGFjazovL3FsaS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9xbGkvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL3FsaS93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3FsaS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3FsaS93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3FsaS93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL3FsaS93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vcWxpL3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcInFsaVwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJxbGlcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicWxpXCJdID0gZmFjdG9yeSgpO1xufSkoc2VsZiwgKCkgPT4ge1xucmV0dXJuICIsIjsoZnVuY3Rpb24gKGdsb2JhbE9iamVjdCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbi8qXHJcbiAqICAgICAgYmlnbnVtYmVyLmpzIHY5LjEuMlxyXG4gKiAgICAgIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGFyaXRobWV0aWMuXHJcbiAqICAgICAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzXHJcbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDIyIE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAqICAgICAgTUlUIExpY2Vuc2VkLlxyXG4gKlxyXG4gKiAgICAgIEJpZ051bWJlci5wcm90b3R5cGUgbWV0aG9kcyAgICAgfCAgQmlnTnVtYmVyIG1ldGhvZHNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBhYnNvbHV0ZVZhbHVlICAgICAgICAgICAgYWJzICAgIHwgIGNsb25lXHJcbiAqICAgICAgY29tcGFyZWRUbyAgICAgICAgICAgICAgICAgICAgICB8ICBjb25maWcgICAgICAgICAgICAgICBzZXRcclxuICogICAgICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgZHAgICAgIHwgICAgICBERUNJTUFMX1BMQUNFU1xyXG4gKiAgICAgIGRpdmlkZWRCeSAgICAgICAgICAgICAgICBkaXYgICAgfCAgICAgIFJPVU5ESU5HX01PREVcclxuICogICAgICBkaXZpZGVkVG9JbnRlZ2VyQnkgICAgICAgaWRpdiAgIHwgICAgICBFWFBPTkVOVElBTF9BVFxyXG4gKiAgICAgIGV4cG9uZW50aWF0ZWRCeSAgICAgICAgICBwb3cgICAgfCAgICAgIFJBTkdFXHJcbiAqICAgICAgaW50ZWdlclZhbHVlICAgICAgICAgICAgICAgICAgICB8ICAgICAgQ1JZUFRPXHJcbiAqICAgICAgaXNFcXVhbFRvICAgICAgICAgICAgICAgIGVxICAgICB8ICAgICAgTU9EVUxPX01PREVcclxuICogICAgICBpc0Zpbml0ZSAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICBQT1dfUFJFQ0lTSU9OXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbiAgICAgICAgICAgIGd0ICAgICB8ICAgICAgRk9STUFUXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyAgIGd0ZSAgICB8ICAgICAgQUxQSEFCRVRcclxuICogICAgICBpc0ludGVnZXIgICAgICAgICAgICAgICAgICAgICAgIHwgIGlzQmlnTnVtYmVyXHJcbiAqICAgICAgaXNMZXNzVGhhbiAgICAgICAgICAgICAgIGx0ICAgICB8ICBtYXhpbXVtICAgICAgICAgICAgICBtYXhcclxuICogICAgICBpc0xlc3NUaGFuT3JFcXVhbFRvICAgICAgbHRlICAgIHwgIG1pbmltdW0gICAgICAgICAgICAgIG1pblxyXG4gKiAgICAgIGlzTmFOICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcmFuZG9tXHJcbiAqICAgICAgaXNOZWdhdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8ICBzdW1cclxuICogICAgICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBpc1plcm8gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtaW51cyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtb2R1bG8gICAgICAgICAgICAgICAgICAgbW9kICAgIHxcclxuICogICAgICBtdWx0aXBsaWVkQnkgICAgICAgICAgICAgdGltZXMgIHxcclxuICogICAgICBuZWdhdGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwbHVzICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwcmVjaXNpb24gICAgICAgICAgICAgICAgc2QgICAgIHxcclxuICogICAgICBzaGlmdGVkQnkgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBzcXVhcmVSb290ICAgICAgICAgICAgICAgc3FydCAgIHxcclxuICogICAgICB0b0V4cG9uZW50aWFsICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZpeGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0Zvcm1hdCAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZyYWN0aW9uICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0pTT04gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b051bWJlciAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1ByZWNpc2lvbiAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1N0cmluZyAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB2YWx1ZU9mICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICpcclxuICovXHJcblxyXG5cclxuICB2YXIgQmlnTnVtYmVyLFxyXG4gICAgaXNOdW1lcmljID0gL14tPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8kL2ksXHJcbiAgICBtYXRoY2VpbCA9IE1hdGguY2VpbCxcclxuICAgIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcblxyXG4gICAgYmlnbnVtYmVyRXJyb3IgPSAnW0JpZ051bWJlciBFcnJvcl0gJyxcclxuICAgIHRvb01hbnlEaWdpdHMgPSBiaWdudW1iZXJFcnJvciArICdOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiAnLFxyXG5cclxuICAgIEJBU0UgPSAxZTE0LFxyXG4gICAgTE9HX0JBU0UgPSAxNCxcclxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXHJcbiAgICAvLyBNQVhfSU5UMzIgPSAweDdmZmZmZmZmLCAgICAgICAgICAgICAgICAgICAvLyAyXjMxIC0gMVxyXG4gICAgUE9XU19URU4gPSBbMSwgMTAsIDEwMCwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLCAxZTEyLCAxZTEzXSxcclxuICAgIFNRUlRfQkFTRSA9IDFlNyxcclxuXHJcbiAgICAvLyBFRElUQUJMRVxyXG4gICAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBERUNJTUFMX1BMQUNFUywgVE9fRVhQX05FRywgVE9fRVhQX1BPUywgTUlOX0VYUCwgTUFYX0VYUCwgYW5kXHJcbiAgICAvLyB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24uXHJcbiAgICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIEJpZ051bWJlciBjb25zdHJ1Y3Rvci5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjbG9uZShjb25maWdPYmplY3QpIHtcclxuICAgIHZhciBkaXYsIGNvbnZlcnRCYXNlLCBwYXJzZU51bWVyaWMsXHJcbiAgICAgIFAgPSBCaWdOdW1iZXIucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQmlnTnVtYmVyLCB0b1N0cmluZzogbnVsbCwgdmFsdWVPZjogbnVsbCB9LFxyXG4gICAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRURJVEFCTEUgQ09ORklHIERFRkFVTFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgc3RhdGVkLlxyXG4gICAgICAvLyBUaGUgdmFsdWVzIGNhbiBhbHNvIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgQmlnTnVtYmVyLnNldC5cclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3Igb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb24uXHJcbiAgICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXHJcbiAgICAgIC8vIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0IGFuZCB0b1ByZWNpc2lvbiwgYW5kIHJvdW5kIChkZWZhdWx0IHZhbHVlKS5cclxuICAgICAgLy8gVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxyXG4gICAgICAvLyBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgICAvLyBDRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgICAgLy8gSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXHJcbiAgICAgIC8vIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIFJPVU5ESU5HX01PREUgPSA0LCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA4XHJcblxyXG4gICAgICAvLyBFWFBPTkVOVElBTF9BVCA6IFtUT19FWFBfTkVHICwgVE9fRVhQX1BPU11cclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTdcclxuICAgICAgVE9fRVhQX05FRyA9IC03LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IDIxXHJcbiAgICAgIFRPX0VYUF9QT1MgPSAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFJBTkdFIDogW01JTl9FWFAsIE1BWF9FWFBdXHJcblxyXG4gICAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgICBNSU5fRVhQID0gLTFlNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IHZhbHVlLCBhYm92ZSB3aGljaCBvdmVyZmxvdyB0byBJbmZpbml0eSBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAgMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXHJcbiAgICAgIC8vIEZvciBNQVhfRVhQID4gMWU3LCBlLmcuIG5ldyBCaWdOdW1iZXIoJzFlMTAwMDAwMDAwJykucGx1cygxKSBtYXkgYmUgc2xvdy5cclxuICAgICAgTUFYX0VYUCA9IDFlNywgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIE1BWFxyXG5cclxuICAgICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICBDUllQVE8gPSBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAgIC8vIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXHJcbiAgICAgIC8vIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgICAvLyBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgICAgLy8gRE9XTiAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoaXMgbW9kdWxvIG1vZGUgaXMgY29tbW9ubHkga25vd24gYXMgJ3RydW5jYXRlZCBkaXZpc2lvbicgYW5kIGlzXHJcbiAgICAgIC8vICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgICAvLyBGTE9PUiAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAgIC8vIEhBTEZfRVZFTiA2IFRoaXMgbW9kdWxvIG1vZGUgaW1wbGVtZW50cyB0aGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgICAvLyBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoZSByZW1haW5kZXIgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxyXG4gICAgICAvLyBtb2RlcyBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBBbHRob3VnaCB0aGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc28gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgdGhlIGV4cG9uZW50aWF0ZWRCeSBvcGVyYXRpb24uXHJcbiAgICAgIC8vIElmIFBPV19QUkVDSVNJT04gaXMgMCwgdGhlcmUgd2lsbCBiZSB1bmxpbWl0ZWQgc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICBQT1dfUFJFQ0lTSU9OID0gMCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZm9ybWF0IHNwZWNpZmljYXRpb24gdXNlZCBieSB0aGUgQmlnTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdCBtZXRob2QuXHJcbiAgICAgIEZPUk1BVCA9IHtcclxuICAgICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAgICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAgIHN1ZmZpeDogJydcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIFRoZSBhbHBoYWJldCB1c2VkIGZvciBiYXNlIGNvbnZlcnNpb24uIEl0IG11c3QgYmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzIGxvbmcsIHdpdGggbm8gJysnLFxyXG4gICAgICAvLyAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAvLyAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXydcclxuICAgICAgQUxQSEFCRVQgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyxcclxuICAgICAgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzID0gdHJ1ZTtcclxuXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1JcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFRoZSBCaWdOdW1iZXIgY29uc3RydWN0b3IgYW5kIGV4cG9ydGVkIGZ1bmN0aW9uLlxyXG4gICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWdOdW1iZXIgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIHYge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICAgKiBbYl0ge251bWJlcn0gVGhlIGJhc2Ugb2Ygdi4gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCaWdOdW1iZXIodiwgYikge1xyXG4gICAgICB2YXIgYWxwaGFiZXQsIGMsIGNhc2VDaGFuZ2VkLCBlLCBpLCBpc051bSwgbGVuLCBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICAvLyBFbmFibGUgY29uc3RydWN0b3IgY2FsbCB3aXRob3V0IGBuZXdgLlxyXG4gICAgICBpZiAoISh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSkgcmV0dXJuIG5ldyBCaWdOdW1iZXIodiwgYik7XHJcblxyXG4gICAgICBpZiAoYiA9PSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh2ICYmIHYuX2lzQmlnTnVtYmVyID09PSB0cnVlKSB7XHJcbiAgICAgICAgICB4LnMgPSB2LnM7XHJcblxyXG4gICAgICAgICAgaWYgKCF2LmMgfHwgdi5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICAgICAgeC5jID0gdi5jLnNsaWNlKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSAmJiB2ICogMCA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gVXNlIGAxIC8gbmAgdG8gaGFuZGxlIG1pbnVzIHplcm8gYWxzby5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/ICh2ID0gLXYsIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBpbnRlZ2Vycywgd2hlcmUgbiA8IDIxNDc0ODM2NDggKDIqKjMxKS5cclxuICAgICAgICAgIGlmICh2ID09PSB+fnYpIHtcclxuICAgICAgICAgICAgZm9yIChlID0gMCwgaSA9IHY7IGkgPj0gMTA7IGkgLz0gMTAsIGUrKyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICAgICAgeC5jID0gW3ZdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgaWYgKCFpc051bWVyaWMudGVzdChzdHIgPSBTdHJpbmcodikpKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0pO1xyXG5cclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgICAgICAgaWYgKChpID0gc3RyLnNlYXJjaCgvZS9pKSkgPiAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgICAgICAgaWYgKGUgPCAwKSBlID0gaTtcclxuICAgICAgICAgIGUgKz0gK3N0ci5zbGljZShpICsgMSk7XHJcbiAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLlxyXG4gICAgICAgICAgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuXHJcbiAgICAgICAgLy8gQWxsb3cgZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYmUgdXNlZCB3aXRoIGJhc2UgMTAgYXJndW1lbnQsIHdoaWxlXHJcbiAgICAgICAgLy8gYWxzbyByb3VuZGluZyB0byBERUNJTUFMX1BMQUNFUyBhcyB3aXRoIG90aGVyIGJhc2VzLlxyXG4gICAgICAgIGlmIChiID09IDEwICYmIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cykge1xyXG4gICAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIodik7XHJcbiAgICAgICAgICByZXR1cm4gcm91bmQoeCwgREVDSU1BTF9QTEFDRVMgKyB4LmUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuXHJcbiAgICAgICAgaWYgKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpIHtcclxuXHJcbiAgICAgICAgICAvLyBBdm9pZCBwb3RlbnRpYWwgaW50ZXJwcmV0YXRpb24gb2YgSW5maW5pdHkgYW5kIE5hTiBhcyBiYXNlIDQ0KyB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAodiAqIDAgIT0gMCkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtLCBiKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHICYmIHN0ci5yZXBsYWNlKC9eMFxcLjAqfFxcLi8sICcnKS5sZW5ndGggPiAxNSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyB2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFscGhhYmV0ID0gQUxQSEFCRVQuc2xpY2UoMCwgYik7XHJcbiAgICAgICAgZSA9IGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGF0IHN0ciBpcyBhIHZhbGlkIGJhc2UgYiBudW1iZXIuXHJcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFJlZ0V4cCwgc28gYWxwaGFiZXQgY2FuIGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzLlxyXG4gICAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoYWxwaGFiZXQuaW5kZXhPZihjID0gc3RyLmNoYXJBdChpKSkgPCAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09ICcuJykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiAnLicgaXMgbm90IHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGl0IGhhcyBub3QgYmUgZm91bmQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgIGlmIChpID4gZSkge1xyXG4gICAgICAgICAgICAgICAgZSA9IGxlbjtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICghY2FzZUNoYW5nZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQWxsb3cgZS5nLiBoZXhhZGVjaW1hbCAnRkYnIGFzIHdlbGwgYXMgJ2ZmJy5cclxuICAgICAgICAgICAgICBpZiAoc3RyID09IHN0ci50b1VwcGVyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICAgICAgICAgICAgc3RyID09IHN0ci50b0xvd2VyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGkgPSAtMTtcclxuICAgICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljKHgsIFN0cmluZyh2KSwgaXNOdW0sIGIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBsYXRlciBjaGVjayBmb3IgbGVuZ3RoIG9uIGNvbnZlcnRlZCBudW1iZXIuXHJcbiAgICAgICAgaXNOdW0gPSBmYWxzZTtcclxuICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZShzdHIsIGIsIDEwLCB4LnMpO1xyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgIGVsc2UgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQoLS1sZW4pID09PSA0ODspO1xyXG5cclxuICAgICAgaWYgKHN0ciA9IHN0ci5zbGljZShpLCArK2xlbikpIHtcclxuICAgICAgICBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICBpZiAoaXNOdW0gJiYgQmlnTnVtYmVyLkRFQlVHICYmXHJcbiAgICAgICAgICBsZW4gPiAxNSAmJiAodiA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdiAhPT0gbWF0aGZsb29yKHYpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyAoeC5zICogdikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICAgIGlmICgoZSA9IGUgLSBpIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFzZVxyXG5cclxuICAgICAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgICAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIHN0ciB0byBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvZWZmaWNpZW50IGFycmF5LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTsgIC8vIGkgPCAxXHJcblxyXG4gICAgICAgICAgaWYgKGkgPCBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKGkpIHguYy5wdXNoKCtzdHIuc2xpY2UoMCwgaSkpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICAgICAgeC5jLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGkgPSBMT0dfQkFTRSAtIChzdHIgPSBzdHIuc2xpY2UoaSkpLmxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgLT0gbGVuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgeC5jLnB1c2goK3N0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUiBQUk9QRVJUSUVTXHJcblxyXG5cclxuICAgIEJpZ051bWJlci5jbG9uZSA9IGNsb25lO1xyXG5cclxuICAgIEJpZ051bWJlci5ST1VORF9VUCA9IDA7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRE9XTiA9IDE7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfQ0VJTCA9IDI7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRkxPT1IgPSAzO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfVVAgPSA0O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTiA9IDU7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0NFSUwgPSA3O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xyXG4gICAgQmlnTnVtYmVyLkVVQ0xJRCA9IDk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDb25maWd1cmUgaW5mcmVxdWVudGx5LWNoYW5naW5nIGxpYnJhcnktd2lkZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBBY2NlcHQgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwcm9wZXJ0aWVzIChpZiB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpc1xyXG4gICAgICogYSBudW1iZXIsIGl0IG11c3QgYmUgYW4gaW50ZWdlciB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZSBzdGF0ZWQpOlxyXG4gICAgICpcclxuICAgICAqICAgREVDSU1BTF9QTEFDRVMgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgUk9VTkRJTkdfTU9ERSAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA4XHJcbiAgICAgKiAgIEVYUE9ORU5USUFMX0FUICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYICBvciAgWy1NQVggdG8gMCwgMCB0byBNQVhdXHJcbiAgICAgKiAgIFJBTkdFICAgICAgICAgICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYIChub3QgemVybykgIG9yICBbLU1BWCB0byAtMSwgMSB0byBNQVhdXHJcbiAgICAgKiAgIENSWVBUTyAgICAgICAgICAge2Jvb2xlYW59ICAgICAgICAgIHRydWUgb3IgZmFsc2VcclxuICAgICAqICAgTU9EVUxPX01PREUgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA5XHJcbiAgICAgKiAgIFBPV19QUkVDSVNJT04gICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIEFMUEhBQkVUICAgICAgICAge3N0cmluZ30gICAgICAgICAgIEEgc3RyaW5nIG9mIHR3byBvciBtb3JlIHVuaXF1ZSBjaGFyYWN0ZXJzIHdoaWNoIGRvZXNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IGNvbnRhaW4gJy4nLlxyXG4gICAgICogICBGT1JNQVQgICAgICAgICAgIHtvYmplY3R9ICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBzb21lIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAqICAgICBwcmVmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZ3JvdXBTaXplICAgICAgICAgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIHNlY29uZGFyeUdyb3VwU2l6ZSAgICAge251bWJlcn1cclxuICAgICAqICAgICBncm91cFNlcGFyYXRvciAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZGVjaW1hbFNlcGFyYXRvciAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTaXplICAgICAge251bWJlcn1cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgc3VmZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICpcclxuICAgICAqIChUaGUgdmFsdWVzIGFzc2lnbmVkIHRvIHRoZSBhYm92ZSBGT1JNQVQgb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdCBjaGVja2VkIGZvciB2YWxpZGl0eS4pXHJcbiAgICAgKlxyXG4gICAgICogRS5nLlxyXG4gICAgICogQmlnTnVtYmVyLmNvbmZpZyh7IERFQ0lNQUxfUExBQ0VTIDogMjAsIFJPVU5ESU5HX01PREUgOiA0IH0pXHJcbiAgICAgKlxyXG4gICAgICogSWdub3JlIHByb3BlcnRpZXMvcGFyYW1ldGVycyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGV4Y2VwdCBmb3IgQUxQSEFCRVQuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGN1cnJlbnQgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuY29uZmlnID0gQmlnTnVtYmVyLnNldCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgdmFyIHAsIHY7XHJcblxyXG4gICAgICBpZiAob2JqICE9IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgICAvLyBERUNJTUFMX1BMQUNFUyB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gREVDSU1BTF9QTEFDRVMge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0RFQ0lNQUxfUExBQ0VTJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgREVDSU1BTF9QTEFDRVMgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJPVU5ESU5HX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBST1VORElOR19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdST1VORElOR19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOCwgcCk7XHJcbiAgICAgICAgICAgIFJPVU5ESU5HX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEVYUE9ORU5USUFMX0FUIHtudW1iZXJ8bnVtYmVyW119XHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRVhQT05FTlRJQUxfQVQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0VYUE9ORU5USUFMX0FUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAwLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9QT1MgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IC0oVE9fRVhQX1BPUyA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJBTkdFIHtudW1iZXJ8bnVtYmVyW119IE5vbi16ZXJvIGludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsdXNpdmUsIGludGVnZXIgMSB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBSQU5HRSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V8Y2Fubm90IGJlIHplcm99OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUkFOR0UnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIC0xLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAxLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIE1JTl9FWFAgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIE1BWF9FWFAgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIE1JTl9FWFAgPSAtKE1BWF9FWFAgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgY2Fubm90IGJlIHplcm86ICcgKyB2KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDUllQVE8ge2Jvb2xlYW59IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQ1JZUFRPIG5vdCB0cnVlIG9yIGZhbHNlOiB7dn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0NSWVBUTycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAhIXYpIHtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvICYmXHJcbiAgICAgICAgICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gIXY7XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCB0cnVlIG9yIGZhbHNlOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBNT0RVTE9fTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDkgaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE1PRFVMT19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdNT0RVTE9fTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDksIHApO1xyXG4gICAgICAgICAgICBNT0RVTE9fTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUE9XX1BSRUNJU0lPTiB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUE9XX1BSRUNJU0lPTiB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUE9XX1BSRUNJU0lPTicpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEZPUk1BVCB7b2JqZWN0fVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEZPUk1BVCBub3QgYW4gb2JqZWN0OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRk9STUFUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdvYmplY3QnKSBGT1JNQVQgPSB2O1xyXG4gICAgICAgICAgICBlbHNlIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgYW4gb2JqZWN0OiAnICsgdik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQUxQSEFCRVQge3N0cmluZ31cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBBTFBIQUJFVCBpbnZhbGlkOiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQUxQSEFCRVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG5cclxuICAgICAgICAgICAgLy8gRGlzYWxsb3cgaWYgbGVzcyB0aGFuIHR3byBjaGFyYWN0ZXJzLFxyXG4gICAgICAgICAgICAvLyBvciBpZiBpdCBjb250YWlucyAnKycsICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciBhIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdzdHJpbmcnICYmICEvXi4/JHxbK1xcLS5cXHNdfCguKS4qXFwxLy50ZXN0KHYpKSB7XHJcbiAgICAgICAgICAgICAgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzID0gdi5zbGljZSgwLCAxMCkgPT0gJzAxMjM0NTY3ODknO1xyXG4gICAgICAgICAgICAgIEFMUEhBQkVUID0gdjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBpbnZhbGlkOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gT2JqZWN0IGV4cGVjdGVkOiB7dn0nXHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdPYmplY3QgZXhwZWN0ZWQ6ICcgKyBvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBERUNJTUFMX1BMQUNFUzogREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgUk9VTkRJTkdfTU9ERTogUk9VTkRJTkdfTU9ERSxcclxuICAgICAgICBFWFBPTkVOVElBTF9BVDogW1RPX0VYUF9ORUcsIFRPX0VYUF9QT1NdLFxyXG4gICAgICAgIFJBTkdFOiBbTUlOX0VYUCwgTUFYX0VYUF0sXHJcbiAgICAgICAgQ1JZUFRPOiBDUllQVE8sXHJcbiAgICAgICAgTU9EVUxPX01PREU6IE1PRFVMT19NT0RFLFxyXG4gICAgICAgIFBPV19QUkVDSVNJT046IFBPV19QUkVDSVNJT04sXHJcbiAgICAgICAgRk9STUFUOiBGT1JNQVQsXHJcbiAgICAgICAgQUxQSEFCRVQ6IEFMUEhBQkVUXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdiBpcyBhIEJpZ051bWJlciBpbnN0YW5jZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBJZiBCaWdOdW1iZXIuREVCVUcgaXMgdHJ1ZSwgdGhyb3cgaWYgYSBCaWdOdW1iZXIgaW5zdGFuY2UgaXMgbm90IHdlbGwtZm9ybWVkLlxyXG4gICAgICpcclxuICAgICAqIHYge2FueX1cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gSW52YWxpZCBCaWdOdW1iZXI6IHt2fSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgaWYgKCF2IHx8IHYuX2lzQmlnTnVtYmVyICE9PSB0cnVlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICghQmlnTnVtYmVyLkRFQlVHKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciBpLCBuLFxyXG4gICAgICAgIGMgPSB2LmMsXHJcbiAgICAgICAgZSA9IHYuZSxcclxuICAgICAgICBzID0gdi5zO1xyXG5cclxuICAgICAgb3V0OiBpZiAoe30udG9TdHJpbmcuY2FsbChjKSA9PSAnW29iamVjdCBBcnJheV0nKSB7XHJcblxyXG4gICAgICAgIGlmICgocyA9PT0gMSB8fCBzID09PSAtMSkgJiYgZSA+PSAtTUFYICYmIGUgPD0gTUFYICYmIGUgPT09IG1hdGhmbG9vcihlKSkge1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBlbGVtZW50IGlzIHplcm8sIHRoZSBCaWdOdW1iZXIgdmFsdWUgbXVzdCBiZSB6ZXJvLlxyXG4gICAgICAgICAgaWYgKGNbMF0gPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGUgPT09IDAgJiYgYy5sZW5ndGggPT09IDEpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgdGhhdCBjWzBdIHNob3VsZCBoYXZlLCBiYXNlZCBvbiB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGkgPCAxKSBpICs9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgICAgICAvL2lmIChNYXRoLmNlaWwoTWF0aC5sb2coY1swXSArIDEpIC8gTWF0aC5MTjEwKSA9PSBpKSB7XHJcbiAgICAgICAgICBpZiAoU3RyaW5nKGNbMF0pLmxlbmd0aCA9PSBpKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIG4gPSBjW2ldO1xyXG4gICAgICAgICAgICAgIGlmIChuIDwgMCB8fCBuID49IEJBU0UgfHwgbiAhPT0gbWF0aGZsb29yKG4pKSBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExhc3QgZWxlbWVudCBjYW5ub3QgYmUgemVybywgdW5sZXNzIGl0IGlzIHRoZSBvbmx5IGVsZW1lbnQuXHJcbiAgICAgICAgICAgIGlmIChuICE9PSAwKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAvLyBJbmZpbml0eS9OYU5cclxuICAgICAgfSBlbHNlIGlmIChjID09PSBudWxsICYmIGUgPT09IG51bGwgJiYgKHMgPT09IG51bGwgfHwgcyA9PT0gMSB8fCBzID09PSAtMSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnSW52YWxpZCBCaWdOdW1iZXI6ICcgKyB2KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1heGltdW0gPSBCaWdOdW1iZXIubWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCAtMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5taW5pbXVtID0gQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcclxuICAgICAqIGFuZCB3aXRoIGRwLCBvciBERUNJTUFMX1BMQUNFUyBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xyXG4gICAgICogemVyb3MgYXJlIHByb2R1Y2VkKS5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcH0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHBvdzJfNTMgPSAweDIwMDAwMDAwMDAwMDAwO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgICAvLyBJZiBpdCBkb2VzLCBhc3N1bWUgYXQgbGVhc3QgNTMgYml0cyBhcmUgcHJvZHVjZWQsIG90aGVyd2lzZSBhc3N1bWUgYXQgbGVhc3QgMzAgYml0cy5cclxuICAgICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhmbG9vcihNYXRoLnJhbmRvbSgpICogcG93Ml81Myk7IH1cclxuICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcclxuICAgICAgICAgKE1hdGgucmFuZG9tKCkgKiAweDgwMDAwMCB8IDApOyB9O1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkcCkge1xyXG4gICAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBjID0gW10sXHJcbiAgICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICBpZiAoZHAgPT0gbnVsbCkgZHAgPSBERUNJTUFMX1BMQUNFUztcclxuICAgICAgICBlbHNlIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG5cclxuICAgICAgICBrID0gbWF0aGNlaWwoZHAgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgIGlmIChDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICAgICAgICBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG5cclxuICAgICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGsgKj0gMikpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDBcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDB4MjAwMDAgaXMgMl4yMS5cclxuICAgICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKTtcclxuICAgICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xyXG4gICAgICAgICAgICAgICAgYVtpICsgMV0gPSBiWzFdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSB2IDw9IDg5OTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xyXG5cclxuICAgICAgICAgICAgLy8gYnVmZmVyXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoayAqPSA3KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwIGlzIDJeMzIsIDB4MTAwMDAwMCBpcyAyXjI0XHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgdiA9ICgoYVtpXSAmIDMxKSAqIDB4MTAwMDAwMDAwMDAwMCkgKyAoYVtpICsgMV0gKiAweDEwMDAwMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDJdICogMHgxMDAwMDAwMDApICsgKGFbaSArIDNdICogMHgxMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDRdIDw8IDE2KSArIChhW2kgKyA1XSA8PCA4KSArIGFbaSArIDZdO1xyXG5cclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShhLCBpKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyA3O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQ1JZUFRPID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2UgTWF0aC5yYW5kb20uXHJcbiAgICAgICAgaWYgKCFDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgICAgICAgIHYgPSByYW5kb201M2JpdEludCgpO1xyXG4gICAgICAgICAgICBpZiAodiA8IDllMTUpIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgayA9IGNbLS1pXTtcclxuICAgICAgICBkcCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxyXG4gICAgICAgIGlmIChrICYmIGRwKSB7XHJcbiAgICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XHJcbiAgICAgICAgICBjW2ldID0gbWF0aGZsb29yKGsgLyB2KSAqIHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgICAgZm9yICg7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICBjID0gW2UgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBmb3IgKGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc3BsaWNlKDAsIDEpLCBlIC09IExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGlmIChpIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmFuZC5lID0gZTtcclxuICAgICAgICByYW5kLmMgPSBjO1xyXG4gICAgICAgIHJldHVybiByYW5kO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnN1bSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgc3VtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDspIHN1bSA9IHN1bS5wbHVzKGFyZ3NbaSsrXSk7XHJcbiAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBQUklWQVRFIEZVTkNUSU9OU1xyXG5cclxuXHJcbiAgICAvLyBDYWxsZWQgYnkgQmlnTnVtYmVyIGFuZCBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nLlxyXG4gICAgY29udmVydEJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgZGVjaW1hbCA9ICcwMTIzNDU2Nzg5JztcclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBhbHBoYWJldCkge1xyXG4gICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgICAgYXJyTCxcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSBiYXNlSW4pO1xyXG5cclxuICAgICAgICAgIGFyclswXSArPSBhbHBoYWJldC5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcblxyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFycltqICsgMV0gPT0gbnVsbCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIHRvU3RyaW5nLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2UgMTAgdG8gYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyBCaWdOdW1iZXIsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZUluIHRvIGJhc2UgMTAuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIHNpZ24sIGNhbGxlcklzVG9TdHJpbmcpIHtcclxuICAgICAgICB2YXIgYWxwaGFiZXQsIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgICAgaSA9IHN0ci5pbmRleE9mKCcuJyksXHJcbiAgICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgICAgcm0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgICAvLyBOb24taW50ZWdlci5cclxuICAgICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgICAvLyBVbmxpbWl0ZWQgcHJlY2lzaW9uLlxyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGJhc2VJbik7XHJcbiAgICAgICAgICB4ID0geS5wb3coc3RyLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IGs7XHJcblxyXG4gICAgICAgICAgLy8gQ29udmVydCBzdHIgYXMgaWYgYW4gaW50ZWdlciwgdGhlbiByZXN0b3JlIHRoZSBmcmFjdGlvbiBwYXJ0IGJ5IGRpdmlkaW5nIHRoZVxyXG4gICAgICAgICAgLy8gcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyLlxyXG5cclxuICAgICAgICAgIHkuYyA9IHRvQmFzZU91dCh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyh4LmMpLCB4LmUsICcwJyksXHJcbiAgICAgICAgICAgMTAsIGJhc2VPdXQsIGRlY2ltYWwpO1xyXG4gICAgICAgICAgeS5lID0geS5jLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIG51bWJlciBhcyBpbnRlZ2VyLlxyXG5cclxuICAgICAgICB4YyA9IHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgY2FsbGVySXNUb1N0cmluZ1xyXG4gICAgICAgICA/IChhbHBoYWJldCA9IEFMUEhBQkVULCBkZWNpbWFsKVxyXG4gICAgICAgICA6IChhbHBoYWJldCA9IGRlY2ltYWwsIEFMUEhBQkVUKSk7XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBhcyBhbiBpbnRlZ2VyIGFuZCBjb252ZXJ0ZWQgdG8gYmFzZU91dC4gZSBpcyB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSkgcmV0dXJuIGFscGhhYmV0LmNoYXJBdCgwKTtcclxuXHJcbiAgICAgICAgLy8gRG9lcyBzdHIgcmVwcmVzZW50IGFuIGludGVnZXI/IElmIHNvLCBubyBuZWVkIGZvciB0aGUgZGl2aXNpb24uXHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAtLWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXHJcbiAgICAgICAgICB4LnMgPSBzaWduO1xyXG4gICAgICAgICAgeCA9IGRpdih4LCB5LCBkcCwgcm0sIGJhc2VPdXQpO1xyXG4gICAgICAgICAgeGMgPSB4LmM7XHJcbiAgICAgICAgICByID0geC5yO1xyXG4gICAgICAgICAgZSA9IHguZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBjb252ZXJ0ZWQgdG8gYmFzZU91dC5cclxuXHJcbiAgICAgICAgLy8gVEhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICBkID0gZSArIGRwICsgMTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0OiB0aGUgZGlnaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIGkgPSB4Y1tkXTtcclxuXHJcbiAgICAgICAgLy8gTG9vayBhdCB0aGUgcm91bmRpbmcgZGlnaXRzIGFuZCBtb2RlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJvdW5kIHVwLlxyXG5cclxuICAgICAgICBrID0gYmFzZU91dCAvIDI7XHJcbiAgICAgICAgciA9IHIgfHwgZCA8IDAgfHwgeGNbZCArIDFdICE9IG51bGw7XHJcblxyXG4gICAgICAgIHIgPSBybSA8IDQgPyAoaSAhPSBudWxsIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG5vdCBncmVhdGVyIHRoYW4gemVybywgb3IgeGMgcmVwcmVzZW50c1xyXG4gICAgICAgIC8vIHplcm8sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgYmFzZSBjb252ZXJzaW9uIGlzIHplcm8gb3IsIGlmIHJvdW5kaW5nIHVwLCBhIHZhbHVlXHJcbiAgICAgICAgLy8gc3VjaCBhcyAwLjAwMDAxLlxyXG4gICAgICAgIGlmIChkIDwgMSB8fCAheGNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyAxXi1kcCBvciAwXHJcbiAgICAgICAgICBzdHIgPSByID8gdG9GaXhlZFBvaW50KGFscGhhYmV0LmNoYXJBdCgxKSwgLWRwLCBhbHBoYWJldC5jaGFyQXQoMCkpIDogYWxwaGFiZXQuY2hhckF0KDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gVHJ1bmNhdGUgeGMgdG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgIHhjLmxlbmd0aCA9IGQ7XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgICAgZm9yICgtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7KSB7XHJcbiAgICAgICAgICAgICAgeGNbZF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIWQpIHtcclxuICAgICAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgICAgIHhjID0gWzFdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChrID0geGMubGVuZ3RoOyAheGNbLS1rXTspO1xyXG5cclxuICAgICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8PSBrOyBzdHIgKz0gYWxwaGFiZXQuY2hhckF0KHhjW2krK10pKTtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvcywgZGVjaW1hbCBwb2ludCBhbmQgdHJhaWxpbmcgemVyb3MgYXMgcmVxdWlyZWQuXHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLy8gUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuIENhbGxlZCBieSBkaXYgYW5kIGNvbnZlcnRCYXNlLlxyXG4gICAgZGl2ID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgICBmdW5jdGlvbiBtdWx0aXBseSh4LCBrLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIG0sIHRlbXAsIHhsbywgeGhpLFxyXG4gICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgICAga2xvID0gayAlIFNRUlRfQkFTRSxcclxuICAgICAgICAgIGtoaSA9IGsgLyBTUVJUX0JBU0UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgICAgIHhsbyA9IHhbaV0gJSBTUVJUX0JBU0U7XHJcbiAgICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcclxuICAgICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgICB0ZW1wID0ga2xvICogeGxvICsgKChtICUgU1FSVF9CQVNFKSAqIFNRUlRfQkFTRSkgKyBjYXJyeTtcclxuICAgICAgICAgIGNhcnJ5ID0gKHRlbXAgLyBiYXNlIHwgMCkgKyAobSAvIFNRUlRfQkFTRSB8IDApICsga2hpICogeGhpO1xyXG4gICAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhcnJ5KSB4ID0gW2NhcnJ5XS5jb25jYXQoeCk7XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgICAgIHZhciBpLCBjbXA7XHJcblxyXG4gICAgICAgIGlmIChhTCAhPSBiTCkge1xyXG4gICAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGZvciAoaSA9IGNtcCA9IDA7IGkgPCBhTDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XHJcbiAgICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgICBmb3IgKDsgYUwtLTspIHtcclxuICAgICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyBhLnNwbGljZSgwLCAxKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHg6IGRpdmlkZW5kLCB5OiBkaXZpc29yLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHksIGRwLCBybSwgYmFzZSkge1xyXG4gICAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcclxuICAgICAgICAgIHlMLCB5eixcclxuICAgICAgICAgIHMgPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cclxuICAgICAgICBpZiAoIXhjIHx8ICF4Y1swXSB8fCAheWMgfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXHJcblxyXG4gICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YykgPyBOYU4gOlxyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIMKxMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgwrEwLlxyXG4gICAgICAgICAgICB4YyAmJiB4Y1swXSA9PSAwIHx8ICF5YyA/IHMgKiAwIDogcyAvIDBcclxuICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHEgPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG4gICAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgICBzID0gZHAgKyBlICsgMTtcclxuXHJcbiAgICAgICAgaWYgKCFiYXNlKSB7XHJcbiAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgLSBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc3VsdCBleHBvbmVudCBtYXkgYmUgb25lIGxlc3MgdGhlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBlLlxyXG4gICAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGkgPSAwOyB5Y1tpXSA9PSAoeGNbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICAgIGlmICh5Y1tpXSA+ICh4Y1tpXSB8fCAwKSkgZS0tO1xyXG5cclxuICAgICAgICBpZiAocyA8IDApIHtcclxuICAgICAgICAgIHFjLnB1c2goMSk7XHJcbiAgICAgICAgICBtb3JlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cclxuXHJcbiAgICAgICAgICBuID0gbWF0aGZsb29yKGJhc2UgLyAoeWNbMF0gKyAxKSk7XHJcblxyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKGJhc2UgLyAyKSAtIDEuXHJcbiAgICAgICAgICAvLyBpZiAobiA+IDEgfHwgbisrID09IDEgJiYgeWNbMF0gPCBiYXNlIC8gMikge1xyXG4gICAgICAgICAgaWYgKG4gPiAxKSB7XHJcbiAgICAgICAgICAgIHljID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB4YyA9IG11bHRpcGx5KHhjLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgICByZW0gPSB4Yy5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwKTtcclxuICAgICAgICAgIHl6ID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgIHl6ID0gWzBdLmNvbmNhdCh5eik7XHJcbiAgICAgICAgICB5YzAgPSB5Y1swXTtcclxuICAgICAgICAgIGlmICh5Y1sxXSA+PSBiYXNlIC8gMikgeWMwKys7XHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gcHJldmVudCB0cmlhbCBkaWdpdCBuID4gYmFzZSwgd2hlbiB1c2luZyBiYXNlIDMuXHJcbiAgICAgICAgICAvLyBlbHNlIGlmIChiYXNlID09IDMgJiYgeWMwID09IDEpIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxyXG5cclxuICAgICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgICAvLyBuIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vcihyZW0wIC8geWMwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgICAvLyAgcHJvZHVjdCA9IGRpdmlzb3IgbXVsdGlwbGllZCBieSB0cmlhbCBkaWdpdCAobikuXHJcbiAgICAgICAgICAgICAgLy8gIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IGlzIGdyZWF0ZXIgdGhhbiByZW1haW5kZXI6XHJcbiAgICAgICAgICAgICAgLy8gICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QsIGRlY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAvLyAgU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCB3YXMgbGVzcyB0aGFuIHJlbWFpbmRlciBhdCB0aGUgbGFzdCBjb21wYXJlOlxyXG4gICAgICAgICAgICAgIC8vICAgIENvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvci5cclxuICAgICAgICAgICAgICAvLyAgICBJZiByZW1haW5kZXIgaXMgZ3JlYXRlciB0aGFuIGRpdmlzb3I6XHJcbiAgICAgICAgICAgICAgLy8gICAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLCBpbmNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcblxyXG4gICAgICAgICAgICAgIGlmIChuID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSkgbiA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlciB0aGVuIHRyaWFsIGRpZ2l0IG4gdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGhpZ2ggYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCBpcyBub3Qga25vd24gdG8gaGF2ZVxyXG4gICAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICBuLS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgY21wID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMCBvciAxLCBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgICAgLy8gc28gY2hhbmdlIGNtcCB0byAxIHRvIGF2b2lkIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxLCBsZWF2ZSBjbXAgYXMgLTEsIHNvIHljIGFuZCByZW0gYXJlIGNvbXBhcmVkIGFnYWluLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gZGl2aXNvciA8IHJlbWFpbmRlciwgc28gbiBtdXN0IGJlIGF0IGxlYXN0IDEuXHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IG4gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yXHJcbiAgICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kID0gWzBdLmNvbmNhdChwcm9kKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBsb3cgYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCB2ZXJ5IHJhcmVseSAyIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4rKztcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgICB9IC8vIGVsc2UgY21wID09PSAxIGFuZCBuIHdpbGwgYmUgMFxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBuLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAocmVtWzBdKSB7XHJcbiAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZW0gPSBbeGNbeGldXTtcclxuICAgICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT0gbnVsbCkgJiYgcy0tKTtcclxuXHJcbiAgICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gTGVhZGluZyB6ZXJvP1xyXG4gICAgICAgICAgaWYgKCFxY1swXSkgcWMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJhc2UgPT0gQkFTRSkge1xyXG5cclxuICAgICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICByb3VuZChxLCBkcCArIChxLmUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgKyAxLCBybSwgbW9yZSk7XHJcblxyXG4gICAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcS5lID0gZTtcclxuICAgICAgICAgIHEuciA9ICttb3JlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcclxuICAgICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgKlxyXG4gICAgICogbjogYSBCaWdOdW1iZXIuXHJcbiAgICAgKiBpOiB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxyXG4gICAgICogcm06IHRoZSByb3VuZGluZyBtb2RlLlxyXG4gICAgICogaWQ6IDEgKHRvRXhwb25lbnRpYWwpIG9yIDIgKHRvUHJlY2lzaW9uKS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0KG4sIGksIHJtLCBpZCkge1xyXG4gICAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcclxuXHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgaWYgKCFuLmMpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBjMCA9IG4uY1swXTtcclxuICAgICAgbmUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoaSA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIHN0ciA9IGlkID09IDEgfHwgaWQgPT0gMiAmJiAobmUgPD0gVE9fRVhQX05FRyB8fCBuZSA+PSBUT19FWFBfUE9TKVxyXG4gICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBuZSlcclxuICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgaSwgcm0pO1xyXG5cclxuICAgICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIHRvUHJlY2lzaW9uIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgaWYgKGlkID09IDEgfHwgaWQgPT0gMiAmJiAoaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRykpIHtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBmb3IgKDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKyspO1xyXG4gICAgICAgICAgc3RyID0gdG9FeHBvbmVudGlhbChzdHIsIGUpO1xyXG5cclxuICAgICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgaWYgKGUgKyAxID4gbGVuKSB7XHJcbiAgICAgICAgICAgIGlmICgtLWkgPiAwKSBmb3IgKHN0ciArPSAnLic7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgIGlmIChlICsgMSA9PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cclxuICAgIC8vIElmIGFueSBudW1iZXIgaXMgTmFOLCByZXR1cm4gTmFOLlxyXG4gICAgZnVuY3Rpb24gbWF4T3JNaW4oYXJncywgbikge1xyXG4gICAgICB2YXIgaywgeSxcclxuICAgICAgICBpID0gMSxcclxuICAgICAgICB4ID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG4gICAgICAgIGlmICgheS5zIHx8IChrID0gY29tcGFyZSh4LCB5KSkgPT09IG4gfHwgayA9PT0gMCAmJiB4LnMgPT09IG4pIHtcclxuICAgICAgICAgIHggPSB5O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBTdHJpcCB0cmFpbGluZyB6ZXJvcywgY2FsY3VsYXRlIGJhc2UgMTAgZXhwb25lbnQgYW5kIGNoZWNrIGFnYWluc3QgTUlOX0VYUCBhbmQgTUFYX0VYUC5cclxuICAgICAqIENhbGxlZCBieSBtaW51cywgcGx1cyBhbmQgdGltZXMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGlzZShuLCBjLCBlKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBqID0gYy5sZW5ndGg7XHJcblxyXG4gICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgIWNbLS1qXTsgYy5wb3AoKSk7XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQuIEZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICBmb3IgKGogPSBjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgIGlmICgoZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgbi5jID0gbi5lID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIG4uYyA9IFtuLmUgPSAwXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuLmUgPSBlO1xyXG4gICAgICAgIG4uYyA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgdmFsdWVzIHRoYXQgZmFpbCB0aGUgdmFsaWRpdHkgdGVzdCBpbiBCaWdOdW1iZXIuXHJcbiAgICBwYXJzZU51bWVyaWMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2ksXHJcbiAgICAgICAgZG90QWZ0ZXIgPSAvXihbXi5dKylcXC4kLyxcclxuICAgICAgICBkb3RCZWZvcmUgPSAvXlxcLihbXi5dKykkLyxcclxuICAgICAgICBpc0luZmluaXR5T3JOYU4gPSAvXi0/KEluZmluaXR5fE5hTikkLyxcclxuICAgICAgICB3aGl0ZXNwYWNlT3JQbHVzID0gL15cXHMqXFwrKD89W1xcdy5dKXxeXFxzK3xcXHMrJC9nO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBzdHIsIGlzTnVtLCBiKSB7XHJcbiAgICAgICAgdmFyIGJhc2UsXHJcbiAgICAgICAgICBzID0gaXNOdW0gPyBzdHIgOiBzdHIucmVwbGFjZSh3aGl0ZXNwYWNlT3JQbHVzLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAgICBpZiAoaXNJbmZpbml0eU9yTmFOLnRlc3QocykpIHtcclxuICAgICAgICAgIHgucyA9IGlzTmFOKHMpID8gbnVsbCA6IHMgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoIWlzTnVtKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaVxyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGJhc2VQcmVmaXgsIGZ1bmN0aW9uIChtLCBwMSwgcDIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gKHAyID0gcDIudG9Mb3dlckNhc2UoKSkgPT0gJ3gnID8gMTYgOiBwMiA9PSAnYicgPyAyIDogODtcclxuICAgICAgICAgICAgICByZXR1cm4gIWIgfHwgYiA9PSBiYXNlID8gcDEgOiBtO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IGI7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEUuZy4gJzEuJyB0byAnMScsICcuMScgdG8gJzAuMSdcclxuICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGRvdEFmdGVyLCAnJDEnKS5yZXBsYWNlKGRvdEJlZm9yZSwgJzAuJDEnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHN0ciAhPSBzKSByZXR1cm4gbmV3IEJpZ051bWJlcihzLCBiYXNlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ05vdCBhJyArIChiID8gJyBiYXNlICcgKyBiIDogJycpICsgJyBudW1iZXI6ICcgKyBzdHIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE5hTlxyXG4gICAgICAgICAgeC5zID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSb3VuZCB4IHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxyXG4gICAgICogSWYgciBpcyB0cnV0aHksIGl0IGlzIGtub3duIHRoYXQgdGhlcmUgYXJlIG1vcmUgZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcm91bmQoeCwgc2QsIHJtLCByKSB7XHJcbiAgICAgIHZhciBkLCBpLCBqLCBrLCBuLCBuaSwgcmQsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgcG93czEwID0gUE9XU19URU47XHJcblxyXG4gICAgICAvLyBpZiB4IGlzIG5vdCBJbmZpbml0eSBvciBOYU4uLi5cclxuICAgICAgaWYgKHhjKSB7XHJcblxyXG4gICAgICAgIC8vIHJkIGlzIHRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgLy8gbiBpcyBhIGJhc2UgMWUxNCBudW1iZXIsIHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCBvZiBhcnJheSB4LmMgY29udGFpbmluZyByZC5cclxuICAgICAgICAvLyBuaSBpcyB0aGUgaW5kZXggb2YgbiB3aXRoaW4geC5jLlxyXG4gICAgICAgIC8vIGQgaXMgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAvLyBpIGlzIHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiBpbmNsdWRpbmcgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAvLyBqIGlzIHRoZSBhY3R1YWwgaW5kZXggb2YgcmQgd2l0aGluIG4gKGlmIDwgMCwgcmQgaXMgYSBsZWFkaW5nIHplcm8pLlxyXG4gICAgICAgIG91dDoge1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy5cclxuICAgICAgICAgIGZvciAoZCA9IDEsIGsgPSB4Y1swXTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuICAgICAgICAgIGkgPSBzZCAtIGQ7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgICAgaSArPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgaiA9IHNkO1xyXG4gICAgICAgICAgICBuID0geGNbbmkgPSAwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICByZCA9IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuaSA9IG1hdGhjZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmkgPj0geGMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgeGMubGVuZ3RoIDw9IG5pOyB4Yy5wdXNoKDApKTtcclxuICAgICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBkID0gMTtcclxuICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBuID0gayA9IHhjW25pXTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgICAgZm9yIChkID0gMTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLCBhZGp1c3RlZCBmb3IgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGQ7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHIgPSByIHx8IHNkIDwgMCB8fFxyXG5cclxuICAgICAgICAgIC8vIEFyZSB0aGVyZSBhbnkgbm9uLXplcm8gZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdD9cclxuICAgICAgICAgIC8vIFRoZSBleHByZXNzaW9uICBuICUgcG93czEwW2QgLSBqIC0gMV0gIHJldHVybnMgYWxsIGRpZ2l0cyBvZiBuIHRvIHRoZSByaWdodFxyXG4gICAgICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IGosIGUuZy4gaWYgbiBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb24gZ2l2ZXMgNzE0LlxyXG4gICAgICAgICAgIHhjW25pICsgMV0gIT0gbnVsbCB8fCAoaiA8IDAgPyBuIDogbiAlIHBvd3MxMFtkIC0gaiAtIDFdKTtcclxuXHJcbiAgICAgICAgICByID0gcm0gPCA0XHJcbiAgICAgICAgICAgPyAocmQgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgOiByZCA+IDUgfHwgcmQgPT0gNSAmJiAocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiZcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAgICgoaSA+IDAgPyBqID4gMCA/IG4gLyBwb3dzMTBbZCAtIGpdIDogMCA6IHhjW25pIC0gMV0pICUgMTApICYgMSB8fFxyXG4gICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAgIGlmIChzZCA8IDEgfHwgIXhjWzBdKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICAgIHNkIC09IHguZSArIDE7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSBwb3dzMTBbKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRV07XHJcbiAgICAgICAgICAgICAgeC5lID0gLXNkIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSB4LmUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgICAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmk7XHJcbiAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICBuaS0tO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmkgKyAxO1xyXG4gICAgICAgICAgICBrID0gcG93czEwW0xPR19CQVNFIC0gaV07XHJcblxyXG4gICAgICAgICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgIC8vIGogPiAwIG1lYW5zIGkgPiBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuLlxyXG4gICAgICAgICAgICB4Y1tuaV0gPSBqID4gMCA/IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqXSAlIHBvd3MxMFtqXSkgKiBrIDogMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgICAgIGlmIChuaSA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaSB3aWxsIGJlIHRoZSBsZW5ndGggb2YgeGNbMF0gYmVmb3JlIGsgaXMgYWRkZWQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcbiAgICAgICAgICAgICAgICBqID0geGNbMF0gKz0gaztcclxuICAgICAgICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTAsIGsrKyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cclxuICAgICAgICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgICAgICAgeC5lKys7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh4Y1swXSA9PSBCQVNFKSB4Y1swXSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHhjW25pXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhjW25pXSAhPSBCQVNFKSBicmVhaztcclxuICAgICAgICAgICAgICAgIHhjW25pLS1dID0gMDtcclxuICAgICAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoaSA9IHhjLmxlbmd0aDsgeGNbLS1pXSA9PT0gMDsgeGMucG9wKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3ZlcmZsb3c/IEluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/IFplcm8uXHJcbiAgICAgICAgfSBlbHNlIGlmICh4LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdmFsdWVPZihuKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChlID09PSBudWxsKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG5cclxuICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIGUpXHJcbiAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFBST1RPVFlQRS9JTlNUQU5DRSBNRVRIT0RTXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlci5cclxuICAgICAqL1xyXG4gICAgUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHgucyA8IDApIHgucyA9IDE7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVyblxyXG4gICAgICogICAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcclxuICAgICAqICAgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIGlzIE5hTi5cclxuICAgICAqL1xyXG4gICAgUC5jb21wYXJlZFRvID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgZHAgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlXHJcbiAgICAgKiB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBkcCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlczogaW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLmRlY2ltYWxQbGFjZXMgPSBQLmRwID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIGRwICsgeC5lICsgMSwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIG4gPSAoKHYgPSBjLmxlbmd0aCAtIDEpIC0gYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBudW1iZXIuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG4gICAgICBpZiAobiA8IDApIG4gPSAwO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLyAwID0gSVxyXG4gICAgICogIG4gLyBOID0gTlxyXG4gICAgICogIG4gLyBJID0gMFxyXG4gICAgICogIDAgLyBuID0gMFxyXG4gICAgICogIDAgLyAwID0gTlxyXG4gICAgICogIDAgLyBOID0gTlxyXG4gICAgICogIDAgLyBJID0gMFxyXG4gICAgICogIE4gLyBuID0gTlxyXG4gICAgICogIE4gLyAwID0gTlxyXG4gICAgICogIE4gLyBOID0gTlxyXG4gICAgICogIE4gLyBJID0gTlxyXG4gICAgICogIEkgLyBuID0gSVxyXG4gICAgICogIEkgLyAwID0gSVxyXG4gICAgICogIEkgLyBOID0gTlxyXG4gICAgICogIEkgLyBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGRpdmlkZWQgYnkgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRCeSA9IFAuZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCBERUNJTUFMX1BMQUNFUywgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgaW50ZWdlciBwYXJ0IG9mIGRpdmlkaW5nIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmlkaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIDAsIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZXhwb25lbnRpYXRlZCBieSBuLlxyXG4gICAgICpcclxuICAgICAqIElmIG0gaXMgcHJlc2VudCwgcmV0dXJuIHRoZSByZXN1bHQgbW9kdWxvIG0uXHJcbiAgICAgKiBJZiBuIGlzIG5lZ2F0aXZlIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqIElmIFBPV19QUkVDSVNJT04gaXMgbm9uLXplcm8gYW5kIG0gaXMgbm90IHByZXNlbnQsIHJvdW5kIHRvIFBPV19QUkVDSVNJT04gdXNpbmcgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbW9kdWxhciBwb3dlciBvcGVyYXRpb24gd29ya3MgZWZmaWNpZW50bHkgd2hlbiB4LCBuLCBhbmQgbSBhcmUgaW50ZWdlcnMsIG90aGVyd2lzZSBpdFxyXG4gICAgICogaXMgZXF1aXZhbGVudCB0byBjYWxjdWxhdGluZyB4LmV4cG9uZW50aWF0ZWRCeShuKS5tb2R1bG8obSkgd2l0aCBhIFBPV19QUkVDSVNJT04gb2YgMC5cclxuICAgICAqXHJcbiAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIGV4cG9uZW50LiBBbiBpbnRlZ2VyLlxyXG4gICAgICogW21dIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIG1vZHVsdXMuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiB7bn0nXHJcbiAgICAgKi9cclxuICAgIFAuZXhwb25lbnRpYXRlZEJ5ID0gUC5wb3cgPSBmdW5jdGlvbiAobiwgbSkge1xyXG4gICAgICB2YXIgaGFsZiwgaXNNb2RFeHAsIGksIGssIG1vcmUsIG5Jc0JpZywgbklzTmVnLCBuSXNPZGQsIHksXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihuKTtcclxuXHJcbiAgICAgIC8vIEFsbG93IE5hTiBhbmQgwrFJbmZpbml0eSwgYnV0IG5vdCBvdGhlciBub24taW50ZWdlcnMuXHJcbiAgICAgIGlmIChuLmMgJiYgIW4uaXNJbnRlZ2VyKCkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0V4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiAnICsgdmFsdWVPZihuKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChtICE9IG51bGwpIG0gPSBuZXcgQmlnTnVtYmVyKG0pO1xyXG5cclxuICAgICAgLy8gRXhwb25lbnQgb2YgTUFYX1NBRkVfSU5URUdFUiBpcyAxNS5cclxuICAgICAgbklzQmlnID0gbi5lID4gMTQ7XHJcblxyXG4gICAgICAvLyBJZiB4IGlzIE5hTiwgwrFJbmZpbml0eSwgwrEwIG9yIMKxMSwgb3IgbiBpcyDCsUluZmluaXR5LCBOYU4gb3IgwrEwLlxyXG4gICAgICBpZiAoIXguYyB8fCAheC5jWzBdIHx8IHguY1swXSA9PSAxICYmICF4LmUgJiYgeC5jLmxlbmd0aCA9PSAxIHx8ICFuLmMgfHwgIW4uY1swXSkge1xyXG5cclxuICAgICAgICAvLyBUaGUgc2lnbiBvZiB0aGUgcmVzdWx0IG9mIHBvdyB3aGVuIHggaXMgbmVnYXRpdmUgZGVwZW5kcyBvbiB0aGUgZXZlbm5lc3Mgb2Ygbi5cclxuICAgICAgICAvLyBJZiArbiBvdmVyZmxvd3MgdG8gwrFJbmZpbml0eSwgdGhlIGV2ZW5uZXNzIG9mIG4gd291bGQgYmUgbm90IGJlIGtub3duLlxyXG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE1hdGgucG93KCt2YWx1ZU9mKHgpLCBuSXNCaWcgPyBuLnMgKiAoMiAtIGlzT2RkKG4pKSA6ICt2YWx1ZU9mKG4pKSk7XHJcbiAgICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG5Jc05lZyA9IG4ucyA8IDA7XHJcblxyXG4gICAgICBpZiAobSkge1xyXG5cclxuICAgICAgICAvLyB4ICUgbSByZXR1cm5zIE5hTiBpZiBhYnMobSkgaXMgemVybywgb3IgbSBpcyBOYU4uXHJcbiAgICAgICAgaWYgKG0uYyA/ICFtLmNbMF0gOiAhbS5zKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgICBpc01vZEV4cCA9ICFuSXNOZWcgJiYgeC5pc0ludGVnZXIoKSAmJiBtLmlzSW50ZWdlcigpO1xyXG5cclxuICAgICAgICBpZiAoaXNNb2RFeHApIHggPSB4Lm1vZChtKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93IHRvIMKxSW5maW5pdHk6ID49MioqMWUxMCBvciA+PTEuMDAwMDAyNCoqMWUxNS5cclxuICAgICAgLy8gVW5kZXJmbG93IHRvIMKxMDogPD0wLjc5KioxZTEwIG9yIDw9MC45OTk5OTc1KioxZTE1LlxyXG4gICAgICB9IGVsc2UgaWYgKG4uZSA+IDkgJiYgKHguZSA+IDAgfHwgeC5lIDwgLTEgfHwgKHguZSA9PSAwXHJcbiAgICAgICAgLy8gWzEsIDI0MDAwMDAwMF1cclxuICAgICAgICA/IHguY1swXSA+IDEgfHwgbklzQmlnICYmIHguY1sxXSA+PSAyNGU3XHJcbiAgICAgICAgLy8gWzgwMDAwMDAwMDAwMDAwXSAgWzk5OTk5NzUwMDAwMDAwXVxyXG4gICAgICAgIDogeC5jWzBdIDwgOGUxMyB8fCBuSXNCaWcgJiYgeC5jWzBdIDw9IDk5OTk5NzVlNykpKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHggaXMgbmVnYXRpdmUgYW5kIG4gaXMgb2RkLCBrID0gLTAsIGVsc2UgayA9IDAuXHJcbiAgICAgICAgayA9IHgucyA8IDAgJiYgaXNPZGQobikgPyAtMCA6IDA7XHJcblxyXG4gICAgICAgIC8vIElmIHggPj0gMSwgayA9IMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IC0xKSBrID0gMSAvIGs7XHJcblxyXG4gICAgICAgIC8vIElmIG4gaXMgbmVnYXRpdmUgcmV0dXJuIMKxMCwgZWxzZSByZXR1cm4gwrFJbmZpbml0eS5cclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihuSXNOZWcgPyAxIC8gayA6IGspO1xyXG5cclxuICAgICAgfSBlbHNlIGlmIChQT1dfUFJFQ0lTSU9OKSB7XHJcblxyXG4gICAgICAgIC8vIFRydW5jYXRpbmcgZWFjaCBjb2VmZmljaWVudCBhcnJheSB0byBhIGxlbmd0aCBvZiBrIGFmdGVyIGVhY2ggbXVsdGlwbGljYXRpb25cclxuICAgICAgICAvLyBlcXVhdGVzIHRvIHRydW5jYXRpbmcgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIFBPV19QUkVDSVNJT04gKyBbMjgsIDQxXSxcclxuICAgICAgICAvLyBpLmUuIHRoZXJlIHdpbGwgYmUgYSBtaW5pbXVtIG9mIDI4IGd1YXJkIGRpZ2l0cyByZXRhaW5lZC5cclxuICAgICAgICBrID0gbWF0aGNlaWwoUE9XX1BSRUNJU0lPTiAvIExPR19CQVNFICsgMik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChuSXNCaWcpIHtcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcigwLjUpO1xyXG4gICAgICAgIGlmIChuSXNOZWcpIG4ucyA9IDE7XHJcbiAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaSA9IE1hdGguYWJzKCt2YWx1ZU9mKG4pKTtcclxuICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgIC8vIFBlcmZvcm1zIDU0IGxvb3AgaXRlcmF0aW9ucyBmb3IgbiBvZiA5MDA3MTk5MjU0NzQwOTkxLlxyXG4gICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICBpZiAobklzT2RkKSB7XHJcbiAgICAgICAgICB5ID0geS50aW1lcyh4KTtcclxuICAgICAgICAgIGlmICgheS5jKSBicmVhaztcclxuXHJcbiAgICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgICBpZiAoeS5jLmxlbmd0aCA+IGspIHkuYy5sZW5ndGggPSBrO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgICB5ID0geS5tb2QobSk7ICAgIC8veSA9IHkubWludXMoZGl2KHksIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaSkge1xyXG4gICAgICAgICAgaSA9IG1hdGhmbG9vcihpIC8gMik7XHJcbiAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IG4udGltZXMoaGFsZik7XHJcbiAgICAgICAgICByb3VuZChuLCBuLmUgKyAxLCAxKTtcclxuXHJcbiAgICAgICAgICBpZiAobi5lID4gMTQpIHtcclxuICAgICAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpID0gK3ZhbHVlT2Yobik7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4ID0geC50aW1lcyh4KTtcclxuXHJcbiAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgIGlmICh4LmMgJiYgeC5jLmxlbmd0aCA+IGspIHguYy5sZW5ndGggPSBrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgIHggPSB4Lm1vZChtKTsgICAgLy94ID0geC5taW51cyhkaXYoeCwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChpc01vZEV4cCkgcmV0dXJuIHk7XHJcbiAgICAgIGlmIChuSXNOZWcpIHkgPSBPTkUuZGl2KHkpO1xyXG5cclxuICAgICAgcmV0dXJuIG0gPyB5Lm1vZChtKSA6IGsgPyByb3VuZCh5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFLCBtb3JlKSA6IHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhbiBpbnRlZ2VyXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvciBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7cm19J1xyXG4gICAgICovXHJcbiAgICBQLmludGVnZXJWYWx1ZSA9IGZ1bmN0aW9uIChybSkge1xyXG4gICAgICB2YXIgbiA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG4gICAgICByZXR1cm4gcm91bmQobiwgbi5lICsgMSwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0VxdWFsVG8gPSBQLmVxID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGEgZmluaXRlIG51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbiA9IFAuZ3QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gMSB8fCBiID09PSAwO1xyXG5cclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYW4gaW50ZWdlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0ludGVnZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkgPiB0aGlzLmMubGVuZ3RoIC0gMjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IC0xIHx8IGIgPT09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIE5hTiwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05hTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICF0aGlzLnM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPCAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBwb3NpdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYyAmJiB0aGlzLmNbMF0gPT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAtIDAgPSBuXHJcbiAgICAgKiAgbiAtIE4gPSBOXHJcbiAgICAgKiAgbiAtIEkgPSAtSVxyXG4gICAgICogIDAgLSBuID0gLW5cclxuICAgICAqICAwIC0gMCA9IDBcclxuICAgICAqICAwIC0gTiA9IE5cclxuICAgICAqICAwIC0gSSA9IC1JXHJcbiAgICAgKiAgTiAtIG4gPSBOXHJcbiAgICAgKiAgTiAtIDAgPSBOXHJcbiAgICAgKiAgTiAtIE4gPSBOXHJcbiAgICAgKiAgTiAtIEkgPSBOXHJcbiAgICAgKiAgSSAtIG4gPSBJXHJcbiAgICAgKiAgSSAtIDAgPSBJXHJcbiAgICAgKiAgSSAtIE4gPSBOXHJcbiAgICAgKiAgSSAtIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbWludXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubWludXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgaSwgaiwgdCwgeExUeSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4geGMgPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih5YyA/IHggOiBOYU4pO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgICAgcmV0dXJuIHljWzBdID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDpcclxuXHJcbiAgICAgICAgICAgLy8gSUVFRSA3NTQgKDIwMDgpIDYuMzogbiAtIG4gPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eVxyXG4gICAgICAgICAgIFJPVU5ESU5HX01PREUgPT0gMyA/IC0wIDogMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBpcyB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcblxyXG4gICAgICAgIGlmICh4TFR5ID0gYSA8IDApIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgICBmb3IgKGIgPSBhOyBiLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50cyBlcXVhbC4gQ2hlY2sgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICAgICAgaiA9ICh4TFR5ID0gKGEgPSB4Yy5sZW5ndGgpIDwgKGIgPSB5Yy5sZW5ndGgpKSA/IGEgOiBiO1xyXG5cclxuICAgICAgICBmb3IgKGEgPSBiID0gMDsgYiA8IGo7IGIrKykge1xyXG5cclxuICAgICAgICAgIGlmICh4Y1tiXSAhPSB5Y1tiXSkge1xyXG4gICAgICAgICAgICB4TFR5ID0geGNbYl0gPCB5Y1tiXTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4IDwgeT8gUG9pbnQgeGMgdG8gdGhlIGFycmF5IG9mIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoeExUeSkge1xyXG4gICAgICAgIHQgPSB4YztcclxuICAgICAgICB4YyA9IHljO1xyXG4gICAgICAgIHljID0gdDtcclxuICAgICAgICB5LnMgPSAteS5zO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBiID0gKGogPSB5Yy5sZW5ndGgpIC0gKGkgPSB4Yy5sZW5ndGgpO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zIHRvIHhjIGlmIHNob3J0ZXIuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gYWRkIHplcm9zIHRvIHljIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Qgb25seSBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXHJcbiAgICAgIGlmIChiID4gMCkgZm9yICg7IGItLTsgeGNbaSsrXSA9IDApO1xyXG4gICAgICBiID0gQkFTRSAtIDE7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB5YyBmcm9tIHhjLlxyXG4gICAgICBmb3IgKDsgaiA+IGE7KSB7XHJcblxyXG4gICAgICAgIGlmICh4Y1stLWpdIDwgeWNbal0pIHtcclxuICAgICAgICAgIGZvciAoaSA9IGo7IGkgJiYgIXhjWy0taV07IHhjW2ldID0gYik7XHJcbiAgICAgICAgICAtLXhjW2ldO1xyXG4gICAgICAgICAgeGNbal0gKz0gQkFTRTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICBmb3IgKDsgeGNbMF0gPT0gMDsgeGMuc3BsaWNlKDAsIDEpLCAtLXllKTtcclxuXHJcbiAgICAgIC8vIFplcm8/XHJcbiAgICAgIGlmICgheGNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gRm9sbG93aW5nIElFRUUgNzU0ICgyMDA4KSA2LjMsXHJcbiAgICAgICAgLy8gbiAtIG4gPSArMCAgYnV0ICBuIC0gbiA9IC0wICB3aGVuIHJvdW5kaW5nIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAgIHkucyA9IFJPVU5ESU5HX01PREUgPT0gMyA/IC0xIDogMTtcclxuICAgICAgICB5LmMgPSBbeS5lID0gMF07XHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIEluZmluaXR5IGFzICt4IC0gK3kgIT0gSW5maW5pdHkgJiYgLXggLSAteSAhPSBJbmZpbml0eVxyXG4gICAgICAvLyBmb3IgZmluaXRlIHggYW5kIHkuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgIG4gJSAwID0gIE5cclxuICAgICAqICAgbiAlIE4gPSAgTlxyXG4gICAgICogICBuICUgSSA9ICBuXHJcbiAgICAgKiAgIDAgJSBuID0gIDBcclxuICAgICAqICAtMCAlIG4gPSAtMFxyXG4gICAgICogICAwICUgMCA9ICBOXHJcbiAgICAgKiAgIDAgJSBOID0gIE5cclxuICAgICAqICAgMCAlIEkgPSAgMFxyXG4gICAgICogICBOICUgbiA9ICBOXHJcbiAgICAgKiAgIE4gJSAwID0gIE5cclxuICAgICAqICAgTiAlIE4gPSAgTlxyXG4gICAgICogICBOICUgSSA9ICBOXHJcbiAgICAgKiAgIEkgJSBuID0gIE5cclxuICAgICAqICAgSSAlIDAgPSAgTlxyXG4gICAgICogICBJICUgTiA9ICBOXHJcbiAgICAgKiAgIEkgJSBJID0gIE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtb2R1bG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuIFRoZSByZXN1bHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgTU9EVUxPX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgcSwgcyxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIEluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgemVyby5cclxuICAgICAgaWYgKCF4LmMgfHwgIXkucyB8fCB5LmMgJiYgIXkuY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4geCBpZiB5IGlzIEluZmluaXR5IG9yIHggaXMgemVyby5cclxuICAgICAgfSBlbHNlIGlmICgheS5jIHx8IHguYyAmJiAheC5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoeCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChNT0RVTE9fTU9ERSA9PSA5KSB7XHJcblxyXG4gICAgICAgIC8vIEV1Y2xpZGlhbiBkaXZpc2lvbjogcSA9IHNpZ24oeSkgKiBmbG9vcih4IC8gYWJzKHkpKVxyXG4gICAgICAgIC8vIHIgPSB4IC0gcXkgICAgd2hlcmUgIDAgPD0gciA8IGFicyh5KVxyXG4gICAgICAgIHMgPSB5LnM7XHJcbiAgICAgICAgeS5zID0gMTtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIDMpO1xyXG4gICAgICAgIHkucyA9IHM7XHJcbiAgICAgICAgcS5zICo9IHM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCBNT0RVTE9fTU9ERSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSB4Lm1pbnVzKHEudGltZXMoeSkpO1xyXG5cclxuICAgICAgLy8gVG8gbWF0Y2ggSmF2YVNjcmlwdCAlLCBlbnN1cmUgc2lnbiBvZiB6ZXJvIGlzIHNpZ24gb2YgZGl2aWRlbmQuXHJcbiAgICAgIGlmICgheS5jWzBdICYmIE1PRFVMT19NT0RFID09IDEpIHkucyA9IHgucztcclxuXHJcbiAgICAgIHJldHVybiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICogMCA9IDBcclxuICAgICAqICBuICogTiA9IE5cclxuICAgICAqICBuICogSSA9IElcclxuICAgICAqICAwICogbiA9IDBcclxuICAgICAqICAwICogMCA9IDBcclxuICAgICAqICAwICogTiA9IE5cclxuICAgICAqICAwICogSSA9IE5cclxuICAgICAqICBOICogbiA9IE5cclxuICAgICAqICBOICogMCA9IE5cclxuICAgICAqICBOICogTiA9IE5cclxuICAgICAqICBOICogSSA9IE5cclxuICAgICAqICBJICogbiA9IElcclxuICAgICAqICBJICogMCA9IE5cclxuICAgICAqICBJICogTiA9IE5cclxuICAgICAqICBJICogSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZVxyXG4gICAgICogb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm11bHRpcGxpZWRCeSA9IFAudGltZXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgYywgZSwgaSwgaiwgaywgbSwgeGNMLCB4bG8sIHhoaSwgeWNMLCB5bG8sIHloaSwgemMsXHJcbiAgICAgICAgYmFzZSwgc3FydEJhc2UsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSAoeSA9IG5ldyBCaWdOdW1iZXIoeSwgYikpLmM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cclxuICAgICAgaWYgKCF4YyB8fCAheWMgfHwgIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4sIG9yIG9uZSBpcyAwIGFuZCB0aGUgb3RoZXIgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4LnMgfHwgIXkucyB8fCB4YyAmJiAheGNbMF0gJiYgIXljIHx8IHljICYmICF5Y1swXSAmJiAheGMpIHtcclxuICAgICAgICAgIHkuYyA9IHkuZSA9IHkucyA9IG51bGw7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIGlzIMKxSW5maW5pdHkuXHJcbiAgICAgICAgICBpZiAoIXhjIHx8ICF5Yykge1xyXG4gICAgICAgICAgICB5LmMgPSB5LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgZWl0aGVyIGlzIMKxMC5cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgICAgeS5lID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICB5LnMgKj0geC5zO1xyXG4gICAgICB4Y0wgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEVuc3VyZSB4YyBwb2ludHMgdG8gbG9uZ2VyIGFycmF5IGFuZCB4Y0wgdG8gaXRzIGxlbmd0aC5cclxuICAgICAgaWYgKHhjTCA8IHljTCkge1xyXG4gICAgICAgIHpjID0geGM7XHJcbiAgICAgICAgeGMgPSB5YztcclxuICAgICAgICB5YyA9IHpjO1xyXG4gICAgICAgIGkgPSB4Y0w7XHJcbiAgICAgICAgeGNMID0geWNMO1xyXG4gICAgICAgIHljTCA9IGk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluaXRpYWxpc2UgdGhlIHJlc3VsdCBhcnJheSB3aXRoIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSB4Y0wgKyB5Y0wsIHpjID0gW107IGktLTsgemMucHVzaCgwKSk7XHJcblxyXG4gICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgc3FydEJhc2UgPSBTUVJUX0JBU0U7XHJcblxyXG4gICAgICBmb3IgKGkgPSB5Y0w7IC0taSA+PSAwOykge1xyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgICAgIHlsbyA9IHljW2ldICUgc3FydEJhc2U7XHJcbiAgICAgICAgeWhpID0geWNbaV0gLyBzcXJ0QmFzZSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoayA9IHhjTCwgaiA9IGkgKyBrOyBqID4gaTspIHtcclxuICAgICAgICAgIHhsbyA9IHhjWy0ta10gJSBzcXJ0QmFzZTtcclxuICAgICAgICAgIHhoaSA9IHhjW2tdIC8gc3FydEJhc2UgfCAwO1xyXG4gICAgICAgICAgbSA9IHloaSAqIHhsbyArIHhoaSAqIHlsbztcclxuICAgICAgICAgIHhsbyA9IHlsbyAqIHhsbyArICgobSAlIHNxcnRCYXNlKSAqIHNxcnRCYXNlKSArIHpjW2pdICsgYztcclxuICAgICAgICAgIGMgPSAoeGxvIC8gYmFzZSB8IDApICsgKG0gLyBzcXJ0QmFzZSB8IDApICsgeWhpICogeGhpO1xyXG4gICAgICAgICAgemNbai0tXSA9IHhsbyAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB6Y1tqXSA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjKSB7XHJcbiAgICAgICAgKytlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHpjLnNwbGljZSgwLCAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB6YywgZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbmVnYXRlZCxcclxuICAgICAqIGkuZS4gbXVsdGlwbGllZCBieSAtMS5cclxuICAgICAqL1xyXG4gICAgUC5uZWdhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIHgucyA9IC14LnMgfHwgbnVsbDtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKyAwID0gblxyXG4gICAgICogIG4gKyBOID0gTlxyXG4gICAgICogIG4gKyBJID0gSVxyXG4gICAgICogIDAgKyBuID0gblxyXG4gICAgICogIDAgKyAwID0gMFxyXG4gICAgICogIDAgKyBOID0gTlxyXG4gICAgICogIDAgKyBJID0gSVxyXG4gICAgICogIE4gKyBuID0gTlxyXG4gICAgICogIE4gKyAwID0gTlxyXG4gICAgICogIE4gKyBOID0gTlxyXG4gICAgICogIE4gKyBJID0gTlxyXG4gICAgICogIEkgKyBuID0gSVxyXG4gICAgICogIEkgKyAwID0gSVxyXG4gICAgICogIEkgKyBOID0gTlxyXG4gICAgICogIEkgKyBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHBsdXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAucGx1cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gbmV3IEJpZ051bWJlcihhIC8gMCk7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOiBhICogMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuIEZhc3RlciB0byB1c2UgcmV2ZXJzZSB0aGVuIGRvIHVuc2hpZnRzLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuICAgICAgICBpZiAoYSA+IDApIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIGZvciAoOyBhLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIGIgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LCBhbmQgYiB0byB0aGUgc2hvcnRlciBsZW5ndGguXHJcbiAgICAgIGlmIChhIC0gYiA8IDApIHtcclxuICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgeWMgPSB4YztcclxuICAgICAgICB4YyA9IHQ7XHJcbiAgICAgICAgYiA9IGE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHljLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhjIGNhbiBiZSBpZ25vcmVkLlxyXG4gICAgICBmb3IgKGEgPSAwOyBiOykge1xyXG4gICAgICAgIGEgPSAoeGNbLS1iXSA9IHhjW2JdICsgeWNbYl0gKyBhKSAvIEJBU0UgfCAwO1xyXG4gICAgICAgIHhjW2JdID0gQkFTRSA9PT0geGNbYl0gPyAwIDogeGNbYl0gJSBCQVNFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYSkge1xyXG4gICAgICAgIHhjID0gW2FdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgKyt5ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gICAgICAvLyB5ZSA9IE1BWF9FWFAgKyAxIHBvc3NpYmxlXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBzZCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2ZcclxuICAgICAqIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKiBJZiBzZCBpcyB0cnVlIGluY2x1ZGUgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zIGluIHRoZSBjb3VudC5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIHNkIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2Ygc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogc2Qge251bWJlcnxib29sZWFufSBudW1iZXI6IHNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBib29sZWFuOiB3aGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSBvciBmYWxzZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChzZCAhPSBudWxsICYmIHNkICE9PSAhIXNkKSB7XHJcbiAgICAgICAgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIHNkLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgdiA9IGMubGVuZ3RoIC0gMTtcclxuICAgICAgbiA9IHYgKiBMT0dfQkFTRSArIDE7XHJcblxyXG4gICAgICBpZiAodiA9IGNbdl0pIHtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAodiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZCAmJiB4LmUgKyAxID4gbikgbiA9IHguZSArIDE7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBzaGlmdGVkIGJ5IGsgcGxhY2VzXHJcbiAgICAgKiAocG93ZXJzIG9mIDEwKS4gU2hpZnQgdG8gdGhlIHJpZ2h0IGlmIG4gPiAwLCBhbmQgdG8gdGhlIGxlZnQgaWYgbiA8IDAuXHJcbiAgICAgKlxyXG4gICAgICogayB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1NBRkVfSU5URUdFUiB0byBNQVhfU0FGRV9JTlRFR0VSIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2t9J1xyXG4gICAgICovXHJcbiAgICBQLnNoaWZ0ZWRCeSA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgIGludENoZWNrKGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgICAgcmV0dXJuIHRoaXMudGltZXMoJzFlJyArIGspO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBzcXJ0KC1uKSA9ICBOXHJcbiAgICAgKiAgc3FydChOKSA9ICBOXHJcbiAgICAgKiAgc3FydCgtSSkgPSAgTlxyXG4gICAgICogIHNxcnQoSSkgPSAgSVxyXG4gICAgICogIHNxcnQoMCkgPSAgMFxyXG4gICAgICogIHNxcnQoLTApID0gLTBcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsXHJcbiAgICAgKiByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbSwgbiwgciwgcmVwLCB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGMgPSB4LmMsXHJcbiAgICAgICAgcyA9IHgucyxcclxuICAgICAgICBlID0geC5lLFxyXG4gICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMgKyA0LFxyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKCcwLjUnKTtcclxuXHJcbiAgICAgIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xyXG4gICAgICBpZiAocyAhPT0gMSB8fCAhYyB8fCAhY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCFzIHx8IHMgPCAwICYmICghYyB8fCBjWzBdKSA/IE5hTiA6IGMgPyB4IDogMSAvIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgICBzID0gTWF0aC5zcXJ0KCt2YWx1ZU9mKHgpKTtcclxuXHJcbiAgICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICAgIGlmIChzID09IDAgfHwgcyA9PSAxIC8gMCkge1xyXG4gICAgICAgIG4gPSBjb2VmZlRvU3RyaW5nKGMpO1xyXG4gICAgICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMCkgbiArPSAnMCc7XHJcbiAgICAgICAgcyA9IE1hdGguc3FydCgrbik7XHJcbiAgICAgICAgZSA9IGJpdEZsb29yKChlICsgMSkgLyAyKSAtIChlIDwgMCB8fCBlICUgMik7XHJcblxyXG4gICAgICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgICAgICBuID0gJzVlJyArIGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIocyArICcnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIHplcm8uXHJcbiAgICAgIC8vIHIgY291bGQgYmUgemVybyBpZiBNSU5fRVhQIGlzIGNoYW5nZWQgYWZ0ZXIgdGhlIHRoaXMgdmFsdWUgd2FzIGNyZWF0ZWQuXHJcbiAgICAgIC8vIFRoaXMgd291bGQgY2F1c2UgYSBkaXZpc2lvbiBieSB6ZXJvICh4L3QpIGFuZCBoZW5jZSBJbmZpbml0eSBiZWxvdywgd2hpY2ggd291bGQgY2F1c2VcclxuICAgICAgLy8gY29lZmZUb1N0cmluZyB0byB0aHJvdy5cclxuICAgICAgaWYgKHIuY1swXSkge1xyXG4gICAgICAgIGUgPSByLmU7XHJcbiAgICAgICAgcyA9IGUgKyBkcDtcclxuICAgICAgICBpZiAocyA8IDMpIHMgPSAwO1xyXG5cclxuICAgICAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICAgICAgZm9yICg7IDspIHtcclxuICAgICAgICAgIHQgPSByO1xyXG4gICAgICAgICAgciA9IGhhbGYudGltZXModC5wbHVzKGRpdih4LCB0LCBkcCwgMSkpKTtcclxuXHJcbiAgICAgICAgICBpZiAoY29lZmZUb1N0cmluZyh0LmMpLnNsaWNlKDAsIHMpID09PSAobiA9IGNvZWZmVG9TdHJpbmcoci5jKSkuc2xpY2UoMCwgcykpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBleHBvbmVudCBvZiByIG1heSBoZXJlIGJlIG9uZSBsZXNzIHRoYW4gdGhlIGZpbmFsIHJlc3VsdCBleHBvbmVudCxcclxuICAgICAgICAgICAgLy8gZS5nIDAuMDAwOTk5OSAoZS00KSAtLT4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICBpZiAoci5lIDwgZSkgLS1zO1xyXG4gICAgICAgICAgICBuID0gbi5zbGljZShzIC0gMywgcyArIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlXHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXHJcbiAgICAgICAgICAgICAgLy8gZXhhY3QgcmVzdWx0IGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgICAgIHJvdW5kKHQsIHQuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgZHAgKz0gNDtcclxuICAgICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGV4YWN0XHJcbiAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMSk7XHJcbiAgICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHArKztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwID0gZHAgKyB0aGlzLmUgKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xyXG4gICAgICogb2YgdGhlIGZvcm1hdCBvciBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLnNldCkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGZvcm1hdHRpbmcgb2JqZWN0IG1heSBjb250YWluIHNvbWUgb3IgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIHNob3duIGJlbG93LlxyXG4gICAgICpcclxuICAgICAqIEZPUk1BVCA9IHtcclxuICAgICAqICAgcHJlZml4OiAnJyxcclxuICAgICAqICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICogICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgKiAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgKiAgIHN1ZmZpeDogJydcclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICogW2Zvcm1hdF0ge29iamVjdH0gRm9ybWF0dGluZyBvcHRpb25zLiBTZWUgRk9STUFUIHBiamVjdCBhYm92ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCBub3QgYW4gb2JqZWN0OiB7Zm9ybWF0fSdcclxuICAgICAqL1xyXG4gICAgUC50b0Zvcm1hdCA9IGZ1bmN0aW9uIChkcCwgcm0sIGZvcm1hdCkge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGRwICE9IG51bGwgJiYgcm0gJiYgdHlwZW9mIHJtID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBybTtcclxuICAgICAgICAgIHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRwICYmIHR5cGVvZiBkcCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gZHA7XHJcbiAgICAgICAgICBkcCA9IHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9ybWF0ID0gRk9STUFUO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCBub3QgYW4gb2JqZWN0OiAnICsgZm9ybWF0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0geC50b0ZpeGVkKGRwLCBybSk7XHJcblxyXG4gICAgICBpZiAoeC5jKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICAgIGcxID0gK2Zvcm1hdC5ncm91cFNpemUsXHJcbiAgICAgICAgICBnMiA9ICtmb3JtYXQuc2Vjb25kYXJ5R3JvdXBTaXplLFxyXG4gICAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBmb3JtYXQuZ3JvdXBTZXBhcmF0b3IgfHwgJycsXHJcbiAgICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxyXG4gICAgICAgICAgZnJhY3Rpb25QYXJ0ID0gYXJyWzFdLFxyXG4gICAgICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcclxuICAgICAgICAgIGxlbiA9IGludERpZ2l0cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChnMikge1xyXG4gICAgICAgICAgaSA9IGcxO1xyXG4gICAgICAgICAgZzEgPSBnMjtcclxuICAgICAgICAgIGcyID0gaTtcclxuICAgICAgICAgIGxlbiAtPSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGcxID4gMCAmJiBsZW4gPiAwKSB7XHJcbiAgICAgICAgICBpID0gbGVuICUgZzEgfHwgZzE7XHJcbiAgICAgICAgICBpbnRQYXJ0ID0gaW50RGlnaXRzLnN1YnN0cigwLCBpKTtcclxuICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IGcxKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnN1YnN0cihpLCBnMSk7XHJcbiAgICAgICAgICBpZiAoZzIgPiAwKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnNsaWNlKGkpO1xyXG4gICAgICAgICAgaWYgKGlzTmVnKSBpbnRQYXJ0ID0gJy0nICsgaW50UGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IGZyYWN0aW9uUGFydFxyXG4gICAgICAgICA/IGludFBhcnQgKyAoZm9ybWF0LmRlY2ltYWxTZXBhcmF0b3IgfHwgJycpICsgKChnMiA9ICtmb3JtYXQuZnJhY3Rpb25Hcm91cFNpemUpXHJcbiAgICAgICAgICA/IGZyYWN0aW9uUGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxkeycgKyBnMiArICd9XFxcXEInLCAnZycpLFxyXG4gICAgICAgICAgICckJicgKyAoZm9ybWF0LmZyYWN0aW9uR3JvdXBTZXBhcmF0b3IgfHwgJycpKVxyXG4gICAgICAgICAgOiBmcmFjdGlvblBhcnQpXHJcbiAgICAgICAgIDogaW50UGFydDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIChmb3JtYXQucHJlZml4IHx8ICcnKSArIHN0ciArIChmb3JtYXQuc3VmZml4IHx8ICcnKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdHdvIEJpZ051bWJlcnMgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBhcyBhIHNpbXBsZVxyXG4gICAgICogZnJhY3Rpb24gd2l0aCBhbiBpbnRlZ2VyIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICAgICAqIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmUgbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWRcclxuICAgICAqIG1heGltdW0gZGVub21pbmF0b3IuIElmIGEgbWF4aW11bSBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZVxyXG4gICAgICogdGhlIGxvd2VzdCB2YWx1ZSBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBudW1iZXIgZXhhY3RseS5cclxuICAgICAqXHJcbiAgICAgKiBbbWRdIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gSW50ZWdlciA+PSAxLCBvciBJbmZpbml0eS4gVGhlIG1heGltdW0gZGVub21pbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9IDoge21kfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1kKSB7XHJcbiAgICAgIHZhciBkLCBkMCwgZDEsIGQyLCBlLCBleHAsIG4sIG4wLCBuMSwgcSwgciwgcyxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYztcclxuXHJcbiAgICAgIGlmIChtZCAhPSBudWxsKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobWQpO1xyXG5cclxuICAgICAgICAvLyBUaHJvdyBpZiBtZCBpcyBsZXNzIHRoYW4gb25lIG9yIGlzIG5vdCBhbiBpbnRlZ2VyLCB1bmxlc3MgaXQgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCFuLmlzSW50ZWdlcigpICYmIChuLmMgfHwgbi5zICE9PSAxKSB8fCBuLmx0KE9ORSkpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCAnICtcclxuICAgICAgICAgICAgICAobi5pc0ludGVnZXIoKSA/ICdvdXQgb2YgcmFuZ2U6ICcgOiAnbm90IGFuIGludGVnZXI6ICcpICsgdmFsdWVPZihuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXhjKSByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuXHJcbiAgICAgIGQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIG4xID0gZDAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIGQxID0gbjAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIHMgPSBjb2VmZlRvU3RyaW5nKHhjKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSBpbml0aWFsIGRlbm9taW5hdG9yLlxyXG4gICAgICAvLyBkIGlzIGEgcG93ZXIgb2YgMTAgYW5kIHRoZSBtaW5pbXVtIG1heCBkZW5vbWluYXRvciB0aGF0IHNwZWNpZmllcyB0aGUgdmFsdWUgZXhhY3RseS5cclxuICAgICAgZSA9IGQuZSA9IHMubGVuZ3RoIC0geC5lIC0gMTtcclxuICAgICAgZC5jWzBdID0gUE9XU19URU5bKGV4cCA9IGUgJSBMT0dfQkFTRSkgPCAwID8gTE9HX0JBU0UgKyBleHAgOiBleHBdO1xyXG4gICAgICBtZCA9ICFtZCB8fCBuLmNvbXBhcmVkVG8oZCkgPiAwID8gKGUgPiAwID8gZCA6IG4xKSA6IG47XHJcblxyXG4gICAgICBleHAgPSBNQVhfRVhQO1xyXG4gICAgICBNQVhfRVhQID0gMSAvIDA7XHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG5cclxuICAgICAgLy8gbjAgPSBkMSA9IDBcclxuICAgICAgbjAuY1swXSA9IDA7XHJcblxyXG4gICAgICBmb3IgKDsgOykgIHtcclxuICAgICAgICBxID0gZGl2KG4sIGQsIDAsIDEpO1xyXG4gICAgICAgIGQyID0gZDAucGx1cyhxLnRpbWVzKGQxKSk7XHJcbiAgICAgICAgaWYgKGQyLmNvbXBhcmVkVG8obWQpID09IDEpIGJyZWFrO1xyXG4gICAgICAgIGQwID0gZDE7XHJcbiAgICAgICAgZDEgPSBkMjtcclxuICAgICAgICBuMSA9IG4wLnBsdXMocS50aW1lcyhkMiA9IG4xKSk7XHJcbiAgICAgICAgbjAgPSBkMjtcclxuICAgICAgICBkID0gbi5taW51cyhxLnRpbWVzKGQyID0gZCkpO1xyXG4gICAgICAgIG4gPSBkMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZDIgPSBkaXYobWQubWludXMoZDApLCBkMSwgMCwgMSk7XHJcbiAgICAgIG4wID0gbjAucGx1cyhkMi50aW1lcyhuMSkpO1xyXG4gICAgICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcclxuICAgICAgbjAucyA9IG4xLnMgPSB4LnM7XHJcbiAgICAgIGUgPSBlICogMjtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAvZDAgb3IgbjEvZDFcclxuICAgICAgciA9IGRpdihuMSwgZDEsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpLmNvbXBhcmVkVG8oXHJcbiAgICAgICAgICBkaXYobjAsIGQwLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKSkgPCAxID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcclxuXHJcbiAgICAgIE1BWF9FWFAgPSBleHA7XHJcblxyXG4gICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAgICAgKi9cclxuICAgIFAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiArdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciBST1VORElOR19NT0RFLiBJZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgICAqIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24sIHRoZW4gdXNlXHJcbiAgICAgKiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICBpZiAoc2QgIT0gbnVsbCkgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgc2QsIHJtLCAyKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBiYXNlIGIsIG9yIGJhc2UgMTAgaWYgYiBpc1xyXG4gICAgICogb21pdHRlZC4gSWYgYSBiYXNlIGlzIHNwZWNpZmllZCwgaW5jbHVkaW5nIGJhc2UgMTAsIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmRcclxuICAgICAqIFJPVU5ESU5HX01PREUuIElmIGEgYmFzZSBpcyBub3Qgc3BlY2lmaWVkLCBhbmQgdGhpcyBCaWdOdW1iZXIgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnRcclxuICAgICAqIHRoYXQgaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIFRPX0VYUF9QT1MsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXHJcbiAgICAgKiBUT19FWFBfTkVHLCByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW2JdIHtudW1iZXJ9IEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgKi9cclxuICAgIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIG4gPSB0aGlzLFxyXG4gICAgICAgIHMgPSBuLnMsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHtcclxuICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgc3RyID0gJ0luZmluaXR5JztcclxuICAgICAgICAgIGlmIChzIDwgMCkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdHIgPSAnTmFOJztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgICAgID8gdG9FeHBvbmVudGlhbChjb2VmZlRvU3RyaW5nKG4uYyksIGUpXHJcbiAgICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMTAgJiYgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzKSB7XHJcbiAgICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgREVDSU1BTF9QTEFDRVMgKyBlICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBuLmUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyksIDEwLCBiLCBzLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCAmJiBuLmNbMF0pIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudCwgYW5kIGluY2x1ZGUgdGhlIG1pbnVzIHNpZ24gZm9yXHJcbiAgICAgKiBuZWdhdGl2ZSB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBQLl9pc0JpZ051bWJlciA9IHRydWU7XHJcblxyXG4gICAgaWYgKGNvbmZpZ09iamVjdCAhPSBudWxsKSBCaWdOdW1iZXIuc2V0KGNvbmZpZ09iamVjdCk7XHJcblxyXG4gICAgcmV0dXJuIEJpZ051bWJlcjtcclxuICB9XHJcblxyXG5cclxuICAvLyBQUklWQVRFIEhFTFBFUiBGVU5DVElPTlNcclxuXHJcbiAgLy8gVGhlc2UgZnVuY3Rpb25zIGRvbid0IG5lZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyxcclxuICAvLyBlLmcuIERFQ0lNQUxfUExBQ0VTLCBpbiB0aGUgc2NvcGUgb2YgdGhlIGBjbG9uZWAgZnVuY3Rpb24gYWJvdmUuXHJcblxyXG5cclxuICBmdW5jdGlvbiBiaXRGbG9vcihuKSB7XHJcbiAgICB2YXIgaSA9IG4gfCAwO1xyXG4gICAgcmV0dXJuIG4gPiAwIHx8IG4gPT09IGkgPyBpIDogaSAtIDE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbiAgZnVuY3Rpb24gY29lZmZUb1N0cmluZyhhKSB7XHJcbiAgICB2YXIgcywgeixcclxuICAgICAgaSA9IDEsXHJcbiAgICAgIGogPSBhLmxlbmd0aCxcclxuICAgICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgICBmb3IgKDsgaSA8IGo7KSB7XHJcbiAgICAgIHMgPSBhW2krK10gKyAnJztcclxuICAgICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoOyB6LS07IHMgPSAnMCcgKyBzKTtcclxuICAgICAgciArPSBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7KTtcclxuXHJcbiAgICByZXR1cm4gci5zbGljZSgwLCBqICsgMSB8fCAxKTtcclxuICB9XHJcblxyXG5cclxuICAvLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXHJcbiAgZnVuY3Rpb24gY29tcGFyZSh4LCB5KSB7XHJcbiAgICB2YXIgYSwgYixcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jLFxyXG4gICAgICBpID0geC5zLFxyXG4gICAgICBqID0geS5zLFxyXG4gICAgICBrID0geC5lLFxyXG4gICAgICBsID0geS5lO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICBpZiAoIWkgfHwgIWopIHJldHVybiBudWxsO1xyXG5cclxuICAgIGEgPSB4YyAmJiAheGNbMF07XHJcbiAgICBiID0geWMgJiYgIXljWzBdO1xyXG5cclxuICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgaWYgKGEgfHwgYikgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICBpZiAoaSAhPSBqKSByZXR1cm4gaTtcclxuXHJcbiAgICBhID0gaSA8IDA7XHJcbiAgICBiID0gayA9PSBsO1xyXG5cclxuICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gYiA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gICAgaWYgKCFiKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgZm9yIChpID0gMDsgaSA8IGo7IGkrKykgaWYgKHhjW2ldICE9IHljW2ldKSByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDaGVjayB0aGF0IG4gaXMgYSBwcmltaXRpdmUgbnVtYmVyLCBhbiBpbnRlZ2VyLCBhbmQgaW4gcmFuZ2UsIG90aGVyd2lzZSB0aHJvdy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBpbnRDaGVjayhuLCBtaW4sIG1heCwgbmFtZSkge1xyXG4gICAgaWYgKG4gPCBtaW4gfHwgbiA+IG1heCB8fCBuICE9PSBtYXRoZmxvb3IobikpIHtcclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgIChiaWdudW1iZXJFcnJvciArIChuYW1lIHx8ICdBcmd1bWVudCcpICsgKHR5cGVvZiBuID09ICdudW1iZXInXHJcbiAgICAgICAgID8gbiA8IG1pbiB8fCBuID4gbWF4ID8gJyBvdXQgb2YgcmFuZ2U6ICcgOiAnIG5vdCBhbiBpbnRlZ2VyOiAnXHJcbiAgICAgICAgIDogJyBub3QgYSBwcmltaXRpdmUgbnVtYmVyOiAnKSArIFN0cmluZyhuKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQXNzdW1lcyBmaW5pdGUgbi5cclxuICBmdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgICB2YXIgayA9IG4uYy5sZW5ndGggLSAxO1xyXG4gICAgcmV0dXJuIGJpdEZsb29yKG4uZSAvIExPR19CQVNFKSA9PSBrICYmIG4uY1trXSAlIDIgIT0gMDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0V4cG9uZW50aWFsKHN0ciwgZSkge1xyXG4gICAgcmV0dXJuIChzdHIubGVuZ3RoID4gMSA/IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgOiBzdHIpICtcclxuICAgICAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9GaXhlZFBvaW50KHN0ciwgZSwgeikge1xyXG4gICAgdmFyIGxlbiwgenM7XHJcblxyXG4gICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgICBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICAgIGZvciAoenMgPSB6ICsgJy4nOyArK2U7IHpzICs9IHopO1xyXG4gICAgICBzdHIgPSB6cyArIHN0cjtcclxuXHJcbiAgICAvLyBQb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgICAgaWYgKCsrZSA+IGxlbikge1xyXG4gICAgICAgIGZvciAoenMgPSB6LCBlIC09IGxlbjsgLS1lOyB6cyArPSB6KTtcclxuICAgICAgICBzdHIgKz0genM7XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IGxlbikge1xyXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gRVhQT1JUXHJcblxyXG5cclxuICBCaWdOdW1iZXIgPSBjbG9uZSgpO1xyXG4gIEJpZ051bWJlclsnZGVmYXVsdCddID0gQmlnTnVtYmVyLkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQU1ELlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpZ051bWJlcjsgfSk7XHJcblxyXG4gIC8vIE5vZGUuanMgYW5kIG90aGVyIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMuXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQnJvd3Nlci5cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFnbG9iYWxPYmplY3QpIHtcclxuICAgICAgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiA/IHNlbGYgOiB3aW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgZ2xvYmFsT2JqZWN0LkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuICB9XHJcbn0pKHRoaXMpO1xyXG4iLCIvKlxuQ29weXJpZ2h0IDIwMTMgU2xlZXBsZXNzIFNvZnR3YXJlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbmRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG5yaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3JcbnNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuSU4gVEhFIFNPRlRXQVJFLiBcbiovXG5cbi8vIHllcywgSSBrbm93IHRoaXMgc2VlbXMgc3R1cGlkLCBidXQgSSBoYXZlIG15IHJlYXNvbnMuXG5cbnZhciBuZXQgPSByZXF1aXJlKFwibmV0XCIpXG5mb3IoayBpbiBuZXQpXG5cdGdsb2JhbFtrXSA9IG5ldFtrXVxuXG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXViaWNDb25uZWN0b3IgPSB2b2lkIDA7XG5jb25zdCBRdWJpY1BhY2thZ2VUeXBlXzEgPSByZXF1aXJlKFwiLi9xdWJpYy1jb21tdW5pY2F0aW9uL1F1YmljUGFja2FnZVR5cGVcIik7XG5jb25zdCBSZWNlaXZlZFBhY2thZ2VfMSA9IHJlcXVpcmUoXCIuL3F1YmljLWNvbW11bmljYXRpb24vUmVjZWl2ZWRQYWNrYWdlXCIpO1xuY29uc3QgUmVxdWVzdFJlc3BvbnNlSGVhZGVyXzEgPSByZXF1aXJlKFwiLi9xdWJpYy1jb21tdW5pY2F0aW9uL1JlcXVlc3RSZXNwb25zZUhlYWRlclwiKTtcbmNvbnN0IFF1YmljVGlja0luZm9fMSA9IHJlcXVpcmUoXCIuL3F1YmljLXR5cGVzL1F1YmljVGlja0luZm9cIik7XG5jb25zdCBRdWJpY0VudGl0eVJlc3BvbnNlXzEgPSByZXF1aXJlKFwiLi9xdWJpYy1jb21tdW5pY2F0aW9uL1F1YmljRW50aXR5UmVzcG9uc2VcIik7XG5jb25zdCBRdWJpY1BhY2thZ2VCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9RdWJpY1BhY2thZ2VCdWlsZGVyXCIpO1xuY29uc3QgUXViaWNFbnRpdHlSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi9xdWJpYy1jb21tdW5pY2F0aW9uL1F1YmljRW50aXR5UmVxdWVzdFwiKTtcbmNvbnN0IGNyeXB0b18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NyeXB0b1wiKSk7XG5jb25zdCBrZXlIZWxwZXJfMSA9IHJlcXVpcmUoXCIuL2tleUhlbHBlclwiKTtcbmNsYXNzIFF1YmljQ29ubmVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihicmlkZ2VBZGRyZXNzKSB7XG4gICAgICAgIHRoaXMuUE9SVCA9IDIxODQxO1xuICAgICAgICB0aGlzLmlzV3NDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoNCAqIDEwMjQgKiAxMDI0KTtcbiAgICAgICAgdGhpcy5idWZmZXJXcml0ZVBvc2l0aW9uID0gMDtcbiAgICAgICAgdGhpcy5idWZmZXJSZWFkUG9zaXRpb24gPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaWNrID0gMDtcbiAgICAgICAgdGhpcy5pc05vZGVKcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzTm9kZUpzID0gdGhpcy5pc05vZGVKc0NoZWNrKCk7XG4gICAgICAgIGlmICghdGhpcy5pc05vZGVKcykge1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQgPSBuZXcgV2ViU29ja2V0KGJyaWRnZUFkZHJlc3MgfHwgJ3dzczovL3dlYmJyaWRnZS5xdWJpYy5saS8nKTsgLy8gcWxpIHdlYiBicmlkZ2UgYWRkcmVzc1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYXNzdW1lIHdlIGFyZSBydW5uaW5nIGluIG5vZGVqc1xuICAgICAgICAgICAgY29uc3QgbmV0MiA9IHJlcXVpcmUoXCJuZXRcIik7XG4gICAgICAgICAgICB0aGlzLnNvY2tldCA9IG5ldyBuZXQyLlNvY2tldCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQub24oJ2RhdGEnLCAoZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyKGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Lm9uKCdjbG9zZScsIChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uUGVlckRpc2Nvbm5lY3RlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25QZWVyRGlzY29ubmVjdGVkKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNOb2RlSnNDaGVjaygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblBlZXJDb25uZWN0KCkge1xuICAgICAgICB0aGlzLnBlZXJDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5vblBlZXJDb25uZWN0ZWQpXG4gICAgICAgICAgICB0aGlzLm9uUGVlckNvbm5lY3RlZCgpO1xuICAgIH1cbiAgICB0b0Jhc2U2NCh1OCkge1xuICAgICAgICByZXR1cm4gYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHU4KSk7XG4gICAgfVxuICAgIGNvbm5lY3RQZWVyKGlwQWRkcmVzcykge1xuICAgICAgICBpZiAoIXRoaXMuaXNOb2RlSnMpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1dzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldTIG5vdCBjb25uZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQ/LnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjb25uZWN0JyxcbiAgICAgICAgICAgICAgICBob3N0OiBpcEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgcG9ydDogdGhpcy5QT1JUXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldD8uY29ubmVjdCh0aGlzLlBPUlQsIGlwQWRkcmVzcywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25QZWVyQ29ubmVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0ZWRQZWVyQWRkcmVzcyA9IGlwQWRkcmVzcztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RQZWVyKCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRQZWVyQWRkcmVzcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzTm9kZUpzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQ/LnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiAnZGlzY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHRoaXMuY29ubmVjdGVkUGVlckFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHBvcnQ6IHRoaXMuUE9SVFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Py5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZFBlZXJBZGRyZXNzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5wZWVyQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVjb25uZWN0UGVlcigpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0UGVlcigpOyAvLyBkaXNjb25uZWN0XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZFBlZXJBZGRyZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0UGVlcih0aGlzLmNvbm5lY3RlZFBlZXJBZGRyZXNzKTsgLy8gY29ubmNldFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgd3JpdGVCdWZmZXIoZGF0YSkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwid3JpdGVCdWZmZXJcIiwgZGF0YSk7XG4gICAgICAgIGxldCB3cml0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5idWZmZXJXcml0ZVBvc2l0aW9uICsgZGF0YS5sZW5ndGggPiB0aGlzLmJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICB3cml0ZUxlbmd0aCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAtIHRoaXMuYnVmZmVyV3JpdGVQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5idWZmZXIuc2V0KGRhdGEuc2xpY2UoMCwgd3JpdGVMZW5ndGgpLCB0aGlzLmJ1ZmZlcldyaXRlUG9zaXRpb24pO1xuICAgICAgICB0aGlzLmJ1ZmZlcldyaXRlUG9zaXRpb24gKz0gd3JpdGVMZW5ndGg7XG4gICAgICAgIGlmICh3cml0ZUxlbmd0aCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcldyaXRlUG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIuc2V0KGRhdGEuc2xpY2Uod3JpdGVMZW5ndGgsIGRhdGEubGVuZ3RoKSk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcldyaXRlUG9zaXRpb24gKz0gZGF0YS5sZW5ndGggLSB3cml0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2Nlc3NCdWZmZXIoKTtcbiAgICB9XG4gICAgcmVhZEZyb21CdWZmZXIobnVtYmVyT2ZCeXRlcywgc2V0UmVhZFBvc2l0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZXh0cmFjdCA9IG5ldyBVaW50OEFycmF5KG51bWJlck9mQnl0ZXMpO1xuICAgICAgICBpZiAodGhpcy5idWZmZXJSZWFkUG9zaXRpb24gKyBudW1iZXJPZkJ5dGVzIDw9IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcmVhZEJ5dGVzID0gdGhpcy5idWZmZXIuc2xpY2UodGhpcy5idWZmZXJSZWFkUG9zaXRpb24sIHRoaXMuYnVmZmVyUmVhZFBvc2l0aW9uICsgbnVtYmVyT2ZCeXRlcyk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQlVGRkVSIFJFQUQgXCIgKyB0aGlzLmJ1ZmZlclJlYWRQb3NpdGlvbiArIFwiIC0gXCIgKyBudW1iZXJPZkJ5dGVzLCByZWFkQnl0ZXMpO1xuICAgICAgICAgICAgZXh0cmFjdC5zZXQocmVhZEJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4dHJhY3Quc2V0KHRoaXMuYnVmZmVyLnNsaWNlKHRoaXMuYnVmZmVyUmVhZFBvc2l0aW9uKSk7XG4gICAgICAgICAgICBleHRyYWN0LnNldCh0aGlzLmJ1ZmZlci5zbGljZSgwLCB0aGlzLmJ1ZmZlclJlYWRQb3NpdGlvbiArIG51bWJlck9mQnl0ZXMgLSB0aGlzLmJ1ZmZlci5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0UmVhZFBvc2l0aW9uKVxuICAgICAgICAgICAgdGhpcy5zZXRSZWFkUG9zaXRpb24obnVtYmVyT2ZCeXRlcyk7XG4gICAgICAgIHJldHVybiBleHRyYWN0O1xuICAgIH1cbiAgICBzZXRSZWFkUG9zaXRpb24obnVtYmVyT2ZSZWFkQnl0cykge1xuICAgICAgICBpZiAodGhpcy5idWZmZXJSZWFkUG9zaXRpb24gKyBudW1iZXJPZlJlYWRCeXRzID4gdGhpcy5idWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5idWZmZXJSZWFkUG9zaXRpb24gPSAwICsgKHRoaXMuYnVmZmVyUmVhZFBvc2l0aW9uICsgbnVtYmVyT2ZSZWFkQnl0cyAtIHRoaXMuYnVmZmVyLmxlbmd0aCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyUmVhZFBvc2l0aW9uICs9IG51bWJlck9mUmVhZEJ5dHM7XG4gICAgfVxuICAgIHByb2Nlc3NCdWZmZXIoKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB0b1JlYWRCeXRlcyA9IE1hdGguYWJzKHRoaXMuYnVmZmVyV3JpdGVQb3NpdGlvbiAtIHRoaXMuYnVmZmVyUmVhZFBvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmICh0b1JlYWRCeXRlcyA8IDgpIC8qIGhlYWRlciBzaXplICovIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlYWQgaGVhZGVyXG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBuZXcgUmVxdWVzdFJlc3BvbnNlSGVhZGVyXzEuUmVxdWVzdFJlc3BvbnNlSGVhZGVyKCk7XG4gICAgICAgICAgICBoZWFkZXIucGFyc2UodGhpcy5yZWFkRnJvbUJ1ZmZlcig4IC8qIGhlYWRlciBzaXplICovKSk7XG4gICAgICAgICAgICBpZiAoaGVhZGVyID09PSB1bmRlZmluZWQgfHwgdG9SZWFkQnl0ZXMgPCBoZWFkZXI/LmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJOT1QgRU5PVUdIIEJZVEVTIEZPUiBDT01QTEVURSBQQUNLQUdFXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRSZWFkUG9zaXRpb24oaGVhZGVyLmdldFBhY2thZ2VTaXplKCkpO1xuICAgICAgICAgICAgY29uc3QgcmVjUGFja2FnZSA9IG5ldyBSZWNlaXZlZFBhY2thZ2VfMS5SZWNlaXZlZFBhY2thZ2UoKTtcbiAgICAgICAgICAgIHJlY1BhY2thZ2UuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICAgICAgcmVjUGFja2FnZS5pcEFkZHJlc3MgPSB0aGlzLmNvbm5lY3RlZFBlZXJBZGRyZXNzID8/IFwiXCI7XG4gICAgICAgICAgICBpZiAoaGVhZGVyLmdldFNpemUoKSA+IDgpIHtcbiAgICAgICAgICAgICAgICByZWNQYWNrYWdlLnBheUxvYWQgPSB0aGlzLnJlYWRGcm9tQnVmZmVyKGhlYWRlci5nZXRTaXplKCkgLSBoZWFkZXIuZ2V0UGFja2FnZVNpemUoKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNQYWNrYWdlLnBheUxvYWQgPSBuZXcgVWludDhBcnJheSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BhY2thZ2UocmVjUGFja2FnZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vblBhY2thZ2VSZWNlaXZlZClcbiAgICAgICAgICAgICAgICB0aGlzLm9uUGFja2FnZVJlY2VpdmVkKHJlY1BhY2thZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NQYWNrYWdlKHApIHtcbiAgICAgICAgaWYgKHAuaGVhZGVyLmdldFR5cGUoKSA9PSBRdWJpY1BhY2thZ2VUeXBlXzEuUXViaWNQYWNrYWdlVHlwZS5SRVNQT05EX0NVUlJFTlRfVElDS19JTkZPKSB7XG4gICAgICAgICAgICBjb25zdCB0aWNrSW5mbyA9IG5ldyBRdWJpY1RpY2tJbmZvXzEuUXViaWNUaWNrSW5mbygpLnBhcnNlKHAucGF5TG9hZCk7XG4gICAgICAgICAgICBpZiAodGlja0luZm8gJiYgdGhpcy5jdXJyZW50VGljayA8IHRpY2tJbmZvLmdldFRpY2soKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFRpY2sgPSB0aWNrSW5mby5nZXRUaWNrKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25UaWNrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVGljayh0aGlzLmN1cnJlbnRUaWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwLmhlYWRlci5nZXRUeXBlKCkgPT0gUXViaWNQYWNrYWdlVHlwZV8xLlF1YmljUGFja2FnZVR5cGUuUkVTUE9ORF9FTlRJVFkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudGl0eVJlc3BvbnNlID0gbmV3IFF1YmljRW50aXR5UmVzcG9uc2VfMS5RdWJpY0VudGl0eVJlc3BvbnNlKCkucGFyc2UocC5wYXlMb2FkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uQmFsYW5jZSlcbiAgICAgICAgICAgICAgICB0aGlzLm9uQmFsYW5jZShlbnRpdHlSZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdFRpY2tJbmZvKCkge1xuICAgICAgICBpZiAodGhpcy5wZWVyQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXIgPSBuZXcgUmVxdWVzdFJlc3BvbnNlSGVhZGVyXzEuUmVxdWVzdFJlc3BvbnNlSGVhZGVyKFF1YmljUGFja2FnZVR5cGVfMS5RdWJpY1BhY2thZ2VUeXBlLlJFUVVFU1RfQ1VSUkVOVF9USUNLX0lORk8pO1xuICAgICAgICAgICAgaGVhZGVyLnJhbmRvbWl6ZURlamFWdSgpO1xuICAgICAgICAgICAgdGhpcy5zZW5kUGFja2FnZShoZWFkZXIuZ2V0UGFja2FnZURhdGEoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdEJhbGFuY2UocGtleSkge1xuICAgICAgICBpZiAoIXRoaXMucGVlckNvbm5lY3RlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gbmV3IFJlcXVlc3RSZXNwb25zZUhlYWRlcl8xLlJlcXVlc3RSZXNwb25zZUhlYWRlcihRdWJpY1BhY2thZ2VUeXBlXzEuUXViaWNQYWNrYWdlVHlwZS5SRVFVRVNUX0VOVElUWSwgcGtleS5nZXRQYWNrYWdlU2l6ZSgpKTtcbiAgICAgICAgaGVhZGVyLnJhbmRvbWl6ZURlamFWdSgpO1xuICAgICAgICBjb25zdCBidWlsZGVyID0gbmV3IFF1YmljUGFja2FnZUJ1aWxkZXJfMS5RdWJpY1BhY2thZ2VCdWlsZGVyKGhlYWRlci5nZXRTaXplKCkpO1xuICAgICAgICBidWlsZGVyLmFkZChoZWFkZXIpO1xuICAgICAgICBidWlsZGVyLmFkZChuZXcgUXViaWNFbnRpdHlSZXF1ZXN0XzEuUXViaWNFbnRpdHlSZXF1ZXN0KHBrZXkpKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGJ1aWxkZXIuZ2V0RGF0YSgpO1xuICAgICAgICB0aGlzLnNlbmRQYWNrYWdlKGRhdGEpO1xuICAgIH1cbiAgICBHZXRQcml2YXRlUHVibGljS2V5KHNlZWQpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b18xLmRlZmF1bHQudGhlbigoeyBzY2hub3JycSwgSzEyIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleUhlbHBlciA9IG5ldyBrZXlIZWxwZXJfMS5LZXlIZWxwZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBrZXlIZWxwZXIucHJpdmF0ZUtleShzZWVkLCAwLCBLMTIpO1xuICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0ga2V5SGVscGVyLmNyZWF0ZVB1YmxpY0tleShwcml2YXRlS2V5LCBzY2hub3JycSwgSzEyKTtcbiAgICAgICAgICAgIHJldHVybiB7IHByaXZhdGVLZXksIHB1YmxpY0tleSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy5idWZmZXJSZWFkUG9zaXRpb24gPSAwO1xuICAgICAgICB0aGlzLmJ1ZmZlcldyaXRlUG9zaXRpb24gPSAwO1xuICAgICAgICAvLyBzdGFydCB0aWNrIGluZm8gaW50ZXJ2YWwgdG8gZ2V0IGN1cnJlbnQgdGljayByZWd1bGFybHlcbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFRpY2tJbmZvKCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgICAgIGlmICghdGhpcy5pc05vZGVKcyAmJiB0aGlzLndlYlNvY2tldCkge1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQub25tZXNzYWdlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbkRhdGEgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmIChqc29uRGF0YS5tZXNzYWdlID09PSAnY29ubmVjdCBkb25lJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUGVlckNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoanNvbkRhdGEubWVzc2FnZSA9PT0gJ2Rpc2Nvbm5lY3QgZG9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub25QZWVyRGlzY29ubmVjdGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vblBlZXJEaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoanNvbkRhdGEubWVzc2FnZSAmJiBqc29uRGF0YS5tZXNzYWdlLmluZGV4T2YoXCJDb25uZWN0aW9uUmVzZXRFcnJvclwiKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIHBlZXIgY2xvc2VzIHRoZSBjb25lY3Rpb24gdGhpcyBlcnJvciBvY2N1cmVzLiBpZiB3ZSBhcmUgcHVibGlzaGluZyB3ZSB3YW50IHRvIHJlY29ubmVjdCBub3dcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RQZWVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGpzb25EYXRhLm1lc3NhZ2UgPT09ICdyZWN2IGRhdGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IFVpbnQ4QXJyYXkuZnJvbShhdG9iKGpzb25EYXRhLmRhdGEpLCBjID0+IGMuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIoYnl0ZUFycmF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNXc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25SZWFkeSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblJlYWR5KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzV3NDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlZXJDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbldzRGlzY29ubmVjdGVkKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uV3NEaXNjb25uZWN0ZWQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uUmVhZHkpXG4gICAgICAgICAgICAgICAgdGhpcy5vblJlYWR5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogY29ubmVjdHMgdG8gYSBzcGVjaWZpYyBwZWVyXG4gICAgICogQHBhcmFtIGlwIG5vZGUvcGVlciBpcCBhZGRyZXNzXG4gICAgICovXG4gICAgY29ubmVjdChpcCkge1xuICAgICAgICB0aGlzLmNvbm5lY3RQZWVyKGlwKTtcbiAgICB9XG4gICAgc2VuZFBhY2thZ2UoZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNOb2RlSnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRXc1BhY2thZ2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kVGNwUGFja2FnZShkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kV3NQYWNrYWdlKGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzV3NDb25uZWN0ZWQgfHwgIXRoaXMucGVlckNvbm5lY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vY29uc29sZS5sb2coXCJSRVFVRVNUXCIsIGRhdGEpO1xuICAgICAgICB0aGlzLndlYlNvY2tldD8uc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBjb21tYW5kOiAnc2VuZGInLFxuICAgICAgICAgICAgZGF0YTogdGhpcy50b0Jhc2U2NChkYXRhKVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzZW5kVGNwUGFja2FnZShkYXRhKSB7XG4gICAgICAgIGlmICghdGhpcy5wZWVyQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2NrZXQ/LndyaXRlKGRhdGEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc3RhcnRzIHRoZSBjb25uZWN0aW9uXG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzdG9wcyB0aGUgd2ViIGJyaWRnZSB3cyBjb25uZWN0aW9uXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0UGVlcigpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMud2ViU29ja2V0KVxuICAgICAgICAgICAgdGhpcy53ZWJTb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0KVxuICAgICAgICAgICAgdGhpcy5zb2NrZXQuZGVzdHJveSgpOyAvLyB1bnRlc3RlZCFcbiAgICB9XG59XG5leHBvcnRzLlF1YmljQ29ubmVjdG9yID0gUXViaWNDb25uZWN0b3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXViaWNEZWZpbml0aW9ucyA9IHZvaWQgMDtcbmNsYXNzIFF1YmljRGVmaW5pdGlvbnMge1xufVxuZXhwb3J0cy5RdWJpY0RlZmluaXRpb25zID0gUXViaWNEZWZpbml0aW9ucztcblF1YmljRGVmaW5pdGlvbnMuU0lHTkFUVVJFX0xFTkdUSCA9IDY0O1xuUXViaWNEZWZpbml0aW9ucy5QVUJMSUNfS0VZX0xFTkdUSCA9IDMyO1xuUXViaWNEZWZpbml0aW9ucy5NQVhfVFJBTlNBQ1RJT05fU0laRSA9IDEwMjQ7XG5RdWJpY0RlZmluaXRpb25zLkRJR0VTVF9MRU5HVEggPSAzMjtcblF1YmljRGVmaW5pdGlvbnMuU1BFQ1RSVU1fREVQVEggPSAyNDtcblF1YmljRGVmaW5pdGlvbnMuTlVNQkVSX09GX1RSQU5TQUNUSU9OU19QRVJfVElDSyA9IDEwMjQ7XG5RdWJpY0RlZmluaXRpb25zLk1BWF9OVU1CRVJfT0ZfQ09OVFJBQ1RTID0gMTAyNDtcbi8vIGltcG9ydGFudCBhZGRyZXNzZXNcblF1YmljRGVmaW5pdGlvbnMuRU1QVFlfQUREUkVTUyA9IFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGWElCXCI7XG5RdWJpY0RlZmluaXRpb25zLkFSQklUUkFUT1JfQUREUkVTUyA9IFwiQUZaUFVBSVlWUE5VWUdKUlFWTFVLT1BQVkxIQVpRVEdMWUFBVVVOQlhGVFZUQU1TQktRQkxFSUVQQ1ZKXCI7XG5RdWJpY0RlZmluaXRpb25zLkRJU1BBVENIRVJfQUREUkVTU1MgPSBcIlhQWFlLRkxHU1dSSFJHQVVLV0ZXVlhDRFZFWUFQQ1BDTlVUTVVEV0ZHRFlRQ1daTkpNV0ZaRUVHQ0ZGT1wiO1xuUXViaWNEZWZpbml0aW9ucy5RWF9BRERSRVNTID0gXCJCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVJNSURcIjtcbi8vIGRlcHJlY3RhZWQvb2Jzb2xldGUgKG9ubHkgaGVyZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSlcblF1YmljRGVmaW5pdGlvbnMuQVJCSVRSQVRPUiA9IFwiQUZaUFVBSVlWUE5VWUdKUlFWTFVLT1BQVkxIQVpRVEdMWUFBVVVOQlhGVFZUQU1TQktRQkxFSUVQQ1ZKXCI7XG5RdWJpY0RlZmluaXRpb25zLlFYX1RSQU5TRkVSX0FTU0VUX0ZFRSA9IDEwMDsgLy8gMTAwIFF1YmljJ3NcblF1YmljRGVmaW5pdGlvbnMuUVhfSVNTVUVfQVNTRVRfRkVFID0gMTAwMDAwMDAwMDsgLy8gMWIgUXViaWMnc1xuUXViaWNEZWZpbml0aW9ucy5RWF9JU1NVRV9BU1NFVF9JTlBVVF9UWVBFID0gMTsgLy8gaW5wdXQgdHlwZSBmb3IgYSB0eCB0byBpc3N1ZSBhbiBhc3NldFxuUXViaWNEZWZpbml0aW9ucy5RWF9UUkFOU0ZFUl9BU1NFVF9JTlBVVF9UWVBFID0gMjsgLy8gaW5wdXQgdHlwZSBmb3IgYSB0eCB0byB0cmFuc2ZlciBhbiBhc3NldFxuUXViaWNEZWZpbml0aW9ucy5RWF9BRERfQVNLX09SREVSID0gNTsgLy8gaW5wdXQgdHlwZSBmb3IgYSB0eCB0byBjcmVhdGUgYW4gYXNrIG9yZGVyXG5RdWJpY0RlZmluaXRpb25zLlFYX0FERF9CSURfT1JERVIgPSA2OyAvLyBpbnB1dCB0eXBlIGZvciBhIHR4IHRvIGNyZWF0ZSBhIGJpZCBvcmRlclxuUXViaWNEZWZpbml0aW9ucy5RWF9SRU1PVkVfQVNLX09SREVSID0gNzsgLy8gaW5wdXQgdHlwZSBmb3IgYSB0eCB0byByZW1vdmUgYW4gYXNrIG9yZGVyXG5RdWJpY0RlZmluaXRpb25zLlFYX1JFTU9WRV9CSURfT1JERVIgPSA4OyAvLyBpbnB1dCB0eXBlIGZvciBhIHR4IHRvIHJlbW92ZSBhIGJpZCBvcmRlclxuLyogUVVUSUwgU0MgKi9cblF1YmljRGVmaW5pdGlvbnMuUVVUSUxfQUREUkVTUyA9IFwiRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFWV1JGXCI7XG5RdWJpY0RlZmluaXRpb25zLlFVVElMX1NFTkRNQU5ZX0lOUFVUX1RZUEUgPSAxOyAvLyBpbnB1dCB0eXBlIGZvciBzZW5kIG1hbnkgb24gUXV0aWxcblF1YmljRGVmaW5pdGlvbnMuUVVUSUxfU0VORE1BTllfRkVFID0gMTA7IC8vIGZlZSBpbiBxdWJpY3MgZm9yIHNlbmQgbWFueVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1YmljUGFja2FnZUJ1aWxkZXIgPSB2b2lkIDA7XG5jb25zdCBRdWJpY0RlZmluaXRpb25zXzEgPSByZXF1aXJlKFwiLi9RdWJpY0RlZmluaXRpb25zXCIpO1xuY29uc3QgY3J5cHRvXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY3J5cHRvXCIpKTtcbmNvbnN0IGtleUhlbHBlcl8xID0gcmVxdWlyZShcIi4va2V5SGVscGVyXCIpO1xuY2xhc3MgUXViaWNQYWNrYWdlQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIC8vIHRvZG86IGNyZWF0ZSBhIGR5bmFtaWMgYnVpbGRlclxuICAgICAgICB0aGlzLnBhY2tldCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIH1cbiAgICBnZXREYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWNrZXQ7XG4gICAgfVxuICAgIHNpZ24oc2VlZCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuZGVmYXVsdC50aGVuKCh7IHNjaG5vcnJxLCBLMTIgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5SGVscGVyID0gbmV3IGtleUhlbHBlcl8xLktleUhlbHBlcigpO1xuICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IGtleUhlbHBlci5wcml2YXRlS2V5KHNlZWQsIDAsIEsxMik7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBrZXlIZWxwZXIuY3JlYXRlUHVibGljS2V5KHByaXZhdGVLZXksIHNjaG5vcnJxLCBLMTIpO1xuICAgICAgICAgICAgY29uc3QgZGlnZXN0ID0gbmV3IFVpbnQ4QXJyYXkoUXViaWNEZWZpbml0aW9uc18xLlF1YmljRGVmaW5pdGlvbnMuRElHRVNUX0xFTkdUSCk7XG4gICAgICAgICAgICBjb25zdCB0b1NpZ24gPSB0aGlzLnBhY2tldC5zbGljZSgwLCB0aGlzLm9mZnNldCk7XG4gICAgICAgICAgICBLMTIodG9TaWduLCBkaWdlc3QsIFF1YmljRGVmaW5pdGlvbnNfMS5RdWJpY0RlZmluaXRpb25zLkRJR0VTVF9MRU5HVEgpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXIgPSBzY2hub3JycS5zaWduKHByaXZhdGVLZXksIHB1YmxpY0tleSwgZGlnZXN0KTtcbiAgICAgICAgICAgIHRoaXMucGFja2V0LnNldChzaWduYXR1ciwgdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gUXViaWNEZWZpbml0aW9uc18xLlF1YmljRGVmaW5pdGlvbnMuU0lHTkFUVVJFX0xFTkdUSDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhY2tldC5zbGljZSgwLCB0aGlzLm9mZnNldCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduQW5kRGlnZXN0KHNlZWQpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b18xLmRlZmF1bHQudGhlbigoeyBzY2hub3JycSwgSzEyIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleUhlbHBlciA9IG5ldyBrZXlIZWxwZXJfMS5LZXlIZWxwZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBrZXlIZWxwZXIucHJpdmF0ZUtleShzZWVkLCAwLCBLMTIpO1xuICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0ga2V5SGVscGVyLmNyZWF0ZVB1YmxpY0tleShwcml2YXRlS2V5LCBzY2hub3JycSwgSzEyKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2VzdCA9IG5ldyBVaW50OEFycmF5KFF1YmljRGVmaW5pdGlvbnNfMS5RdWJpY0RlZmluaXRpb25zLkRJR0VTVF9MRU5HVEgpO1xuICAgICAgICAgICAgY29uc3QgdG9TaWduID0gdGhpcy5wYWNrZXQuc2xpY2UoMCwgdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgSzEyKHRvU2lnbiwgZGlnZXN0LCBRdWJpY0RlZmluaXRpb25zXzEuUXViaWNEZWZpbml0aW9ucy5ESUdFU1RfTEVOR1RIKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNjaG5vcnJxLnNpZ24ocHJpdmF0ZUtleSwgcHVibGljS2V5LCBkaWdlc3QpO1xuICAgICAgICAgICAgdGhpcy5wYWNrZXQuc2V0KHNpZ25hdHVyZSwgdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gUXViaWNEZWZpbml0aW9uc18xLlF1YmljRGVmaW5pdGlvbnMuU0lHTkFUVVJFX0xFTkdUSDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZERhdGEgPSB0aGlzLnBhY2tldC5zbGljZSgwLCB0aGlzLm9mZnNldCk7XG4gICAgICAgICAgICBLMTIoc2lnbmVkRGF0YSwgZGlnZXN0LCBRdWJpY0RlZmluaXRpb25zXzEuUXViaWNEZWZpbml0aW9ucy5ESUdFU1RfTEVOR1RIKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2lnbmVkRGF0YTogc2lnbmVkRGF0YSxcbiAgICAgICAgICAgICAgICBkaWdlc3Q6IGRpZ2VzdCxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZChxKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBxLmdldFBhY2thZ2VEYXRhKCk7XG4gICAgICAgIHRoaXMucGFja2V0LnNldChkYXRhLCB0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkdWludDhBcnJheShxKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZFJhdyhxKTtcbiAgICB9XG4gICAgYWRkUmF3KHEpIHtcbiAgICAgICAgdGhpcy5wYWNrZXQuc2V0KHEsIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gcS5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRTaG9ydChxIC8qIG11c3QgYmUgYSBzaG9ydCAqLykge1xuICAgICAgICB0aGlzLnBhY2tldC5zZXQodGhpcy5Gcm9tU2hvcnQocSksIHRoaXMub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkZEludChxIC8qIG11c3QgYmUgYSBzaG9ydCAqLykge1xuICAgICAgICB0aGlzLnBhY2tldC5zZXQodGhpcy5Gcm9tSW50KHEpLCB0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBGcm9tSW50KG51bSkge1xuICAgICAgICAvLyBJZiBudW0gaXMgYSAzMi1iaXQgaW50ZWdlclxuICAgICAgICBsZXQgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDQpOyAvLyA0IGJ5dGVzIGZvciBhIDMyLWJpdCBpbnRlZ2VyXG4gICAgICAgIGxldCBkYXRhdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgICAgICBkYXRhdmlldy5zZXRJbnQzMigwLCBudW0sIHRydWUpOyAvLyBVc2Ugc2V0VWludDMyIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIHVuc2lnbmVkIGludGVnZXJzXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIH1cbiAgICBGcm9tU2hvcnQobnVtKSB7XG4gICAgICAgIC8vIElmIG51bSBpcyBhIDMyLWJpdCBpbnRlZ2VyXG4gICAgICAgIGxldCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMik7IC8vIDQgYnl0ZXMgZm9yIGEgMzItYml0IGludGVnZXJcbiAgICAgICAgbGV0IGRhdGF2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgIGRhdGF2aWV3LnNldEludDE2KDAsIG51bSwgdHJ1ZSk7IC8vIFVzZSBzZXRVaW50MzIgaWYgeW91IGFyZSBkZWFsaW5nIHdpdGggdW5zaWduZWQgaW50ZWdlcnNcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgfVxufVxuZXhwb3J0cy5RdWJpY1BhY2thZ2VCdWlsZGVyID0gUXViaWNQYWNrYWdlQnVpbGRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gbWFpbiBhY2Nlc3NvcnNcbmNvbnN0IFF1YmljQ29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi9RdWJpY0Nvbm5lY3RvclwiKTtcbmNvbnN0IFF1YmljRGVmaW5pdGlvbnNfMSA9IHJlcXVpcmUoXCIuL1F1YmljRGVmaW5pdGlvbnNcIik7XG5jb25zdCBxdWJpY0hlbHBlcl8xID0gcmVxdWlyZShcIi4vcXViaWNIZWxwZXJcIik7XG5jb25zdCBRdWJpY1BhY2thZ2VCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9RdWJpY1BhY2thZ2VCdWlsZGVyXCIpO1xuLy8gdHlwZXNcbmNvbnN0IER5bmFtaWNQYXlsb2FkXzEgPSByZXF1aXJlKFwiLi9xdWJpYy10eXBlcy9EeW5hbWljUGF5bG9hZFwiKTtcbmNvbnN0IExvbmdfMSA9IHJlcXVpcmUoXCIuL3F1YmljLXR5cGVzL0xvbmdcIik7XG5jb25zdCBQdWJsaWNLZXlfMSA9IHJlcXVpcmUoXCIuL3F1YmljLXR5cGVzL1B1YmxpY0tleVwiKTtcbmNvbnN0IFF1YmljRW50aXR5XzEgPSByZXF1aXJlKFwiLi9xdWJpYy10eXBlcy9RdWJpY0VudGl0eVwiKTtcbmNvbnN0IFF1YmljVGlja0RhdGFfMSA9IHJlcXVpcmUoXCIuL3F1YmljLXR5cGVzL1F1YmljVGlja0RhdGFcIik7XG5jb25zdCBRdWJpY1RpY2tJbmZvXzEgPSByZXF1aXJlKFwiLi9xdWJpYy10eXBlcy9RdWJpY1RpY2tJbmZvXCIpO1xuY29uc3QgUXViaWNUcmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vcXViaWMtdHlwZXMvUXViaWNUcmFuc2FjdGlvblwiKTtcbmNvbnN0IFNpZ25hdHVyZV8xID0gcmVxdWlyZShcIi4vcXViaWMtdHlwZXMvU2lnbmF0dXJlXCIpO1xuLy8gdHJhbnNhY3Rpb24gUGF5bG9hZHNcbmNvbnN0IFF1YmljVHJhbnNmZXJBc3NldFBheWxvYWRfMSA9IHJlcXVpcmUoXCIuL3F1YmljLXR5cGVzL3RyYW5zYWNpb24tcGF5bG9hZHMvUXViaWNUcmFuc2ZlckFzc2V0UGF5bG9hZFwiKTtcbmNvbnN0IFF1YmljVHJhbnNmZXJTZW5kTWFueVBheWxvYWRfMSA9IHJlcXVpcmUoXCIuL3F1YmljLXR5cGVzL3RyYW5zYWNpb24tcGF5bG9hZHMvUXViaWNUcmFuc2ZlclNlbmRNYW55UGF5bG9hZFwiKTtcbi8vIGNvbW11bmljYXRpb24gcGFja2FnZXNcbmNvbnN0IFF1YmljRW50aXR5UmVxdWVzdF8xID0gcmVxdWlyZShcIi4vcXViaWMtY29tbXVuaWNhdGlvbi9RdWJpY0VudGl0eVJlcXVlc3RcIik7XG5jb25zdCBRdWJpY0VudGl0eVJlc3BvbnNlXzEgPSByZXF1aXJlKFwiLi9xdWJpYy1jb21tdW5pY2F0aW9uL1F1YmljRW50aXR5UmVzcG9uc2VcIik7XG5jb25zdCBRdWJpY1BhY2thZ2VUeXBlXzEgPSByZXF1aXJlKFwiLi9xdWJpYy1jb21tdW5pY2F0aW9uL1F1YmljUGFja2FnZVR5cGVcIik7XG5jb25zdCBSZWNlaXZlZFBhY2thZ2VfMSA9IHJlcXVpcmUoXCIuL3F1YmljLWNvbW11bmljYXRpb24vUmVjZWl2ZWRQYWNrYWdlXCIpO1xuY29uc3QgUmVxdWVzdFJlc3BvbnNlSGVhZGVyXzEgPSByZXF1aXJlKFwiLi9xdWJpYy1jb21tdW5pY2F0aW9uL1JlcXVlc3RSZXNwb25zZUhlYWRlclwiKTtcbi8vIGNyeXB0byAoYmFzZSBxdWJpYyBsaWJyYXJ5KVxuY29uc3QgaW5kZXhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jcnlwdG8vaW5kZXhcIikpO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIGNyeXB0bzogaW5kZXhfMS5kZWZhdWx0LFxuICAgIFF1YmljRW50aXR5UmVxdWVzdDogUXViaWNFbnRpdHlSZXF1ZXN0XzEuUXViaWNFbnRpdHlSZXF1ZXN0LFxuICAgIFF1YmljRW50aXR5UmVzcG9uc2U6IFF1YmljRW50aXR5UmVzcG9uc2VfMS5RdWJpY0VudGl0eVJlc3BvbnNlLFxuICAgIFF1YmljUGFja2FnZVR5cGU6IFF1YmljUGFja2FnZVR5cGVfMS5RdWJpY1BhY2thZ2VUeXBlLFxuICAgIFJlY2VpdmVkUGFja2FnZTogUmVjZWl2ZWRQYWNrYWdlXzEuUmVjZWl2ZWRQYWNrYWdlLFxuICAgIFJlcXVlc3RSZXNwb25zZUhlYWRlcjogUmVxdWVzdFJlc3BvbnNlSGVhZGVyXzEuUmVxdWVzdFJlc3BvbnNlSGVhZGVyLFxuICAgIER5bmFtaWNQYXlsb2FkOiBEeW5hbWljUGF5bG9hZF8xLkR5bmFtaWNQYXlsb2FkLFxuICAgIExvbmc6IExvbmdfMS5Mb25nLFxuICAgIFB1YmxpY0tleTogUHVibGljS2V5XzEuUHVibGljS2V5LFxuICAgIFF1YmljRW50aXR5OiBRdWJpY0VudGl0eV8xLlF1YmljRW50aXR5LFxuICAgIFF1YmljVGlja0RhdGE6IFF1YmljVGlja0RhdGFfMS5RdWJpY1RpY2tEYXRhLFxuICAgIFF1YmljVGlja0luZm86IFF1YmljVGlja0luZm9fMS5RdWJpY1RpY2tJbmZvLFxuICAgIFF1YmljVHJhbnNhY3Rpb246IFF1YmljVHJhbnNhY3Rpb25fMS5RdWJpY1RyYW5zYWN0aW9uLFxuICAgIFNpZ25hdHVyZTogU2lnbmF0dXJlXzEuU2lnbmF0dXJlLFxuICAgIFF1YmljQ29ubmVjdG9yOiBRdWJpY0Nvbm5lY3Rvcl8xLlF1YmljQ29ubmVjdG9yLFxuICAgIFF1YmljRGVmaW5pdGlvbnM6IFF1YmljRGVmaW5pdGlvbnNfMS5RdWJpY0RlZmluaXRpb25zLFxuICAgIFF1YmljSGVscGVyOiBxdWJpY0hlbHBlcl8xLlF1YmljSGVscGVyLFxuICAgIFF1YmljUGFja2FnZUJ1aWxkZXI6IFF1YmljUGFja2FnZUJ1aWxkZXJfMS5RdWJpY1BhY2thZ2VCdWlsZGVyLFxuICAgIFF1YmljVHJhbnNmZXJBc3NldFBheWxvYWQ6IFF1YmljVHJhbnNmZXJBc3NldFBheWxvYWRfMS5RdWJpY1RyYW5zZmVyQXNzZXRQYXlsb2FkLFxuICAgIFF1YmljVHJhbnNmZXJTZW5kTWFueVBheWxvYWQ6IFF1YmljVHJhbnNmZXJTZW5kTWFueVBheWxvYWRfMS5RdWJpY1RyYW5zZmVyU2VuZE1hbnlQYXlsb2FkXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLktleUhlbHBlciA9IHZvaWQgMDtcbmNsYXNzIEtleUhlbHBlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuU0VFRF9BTFBIQUJFVCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eic7XG4gICAgICAgIHRoaXMuUFJJVkFURV9LRVlfTEVOR1RIID0gMzI7XG4gICAgICAgIHRoaXMuUFVCTElDX0tFWV9MRU5HVEggPSAzMjtcbiAgICAgICAgdGhpcy5DSEVDS1NVTV9MRU5HVEggPSAzO1xuICAgIH1cbiAgICBjcmVhdGVQdWJsaWNLZXkocHJpdmF0ZUtleSwgc2Nobm9ycnEsIEsxMikge1xuICAgICAgICBjb25zdCBwdWJsaWNLZXlXaXRoQ2hlY2tzdW0gPSBuZXcgVWludDhBcnJheSh0aGlzLlBVQkxJQ19LRVlfTEVOR1RIICsgdGhpcy5DSEVDS1NVTV9MRU5HVEgpO1xuICAgICAgICBwdWJsaWNLZXlXaXRoQ2hlY2tzdW0uc2V0KHNjaG5vcnJxLmdlbmVyYXRlUHVibGljS2V5KHByaXZhdGVLZXkpKTtcbiAgICAgICAgSzEyKHB1YmxpY0tleVdpdGhDaGVja3N1bS5zdWJhcnJheSgwLCB0aGlzLlBVQkxJQ19LRVlfTEVOR1RIKSwgcHVibGljS2V5V2l0aENoZWNrc3VtLCB0aGlzLkNIRUNLU1VNX0xFTkdUSCwgdGhpcy5QVUJMSUNfS0VZX0xFTkdUSCk7XG4gICAgICAgIHJldHVybiBwdWJsaWNLZXlXaXRoQ2hlY2tzdW07XG4gICAgfVxuICAgIHNlZWRUb0J5dGVzKHNlZWQpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShzZWVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnl0ZXNbaV0gPSB0aGlzLlNFRURfQUxQSEFCRVQuaW5kZXhPZihzZWVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIDtcbiAgICBwcml2YXRlS2V5KHNlZWQsIGluZGV4LCBLMTIpIHtcbiAgICAgICAgY29uc3QgYnl0ZVNlZWQgPSB0aGlzLnNlZWRUb0J5dGVzKHNlZWQpO1xuICAgICAgICBjb25zdCBwcmVpbWFnZSA9IGJ5dGVTZWVkLnNsaWNlKCk7XG4gICAgICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVpbWFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgrK3ByZWltYWdlW2ldID4gdGhpcy5TRUVEX0FMUEhBQkVULmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwcmVpbWFnZVtpXSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5QUklWQVRFX0tFWV9MRU5HVEgpO1xuICAgICAgICBLMTIocHJlaW1hZ2UsIGtleSwgdGhpcy5QUklWQVRFX0tFWV9MRU5HVEgpO1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLktleUhlbHBlciA9IEtleUhlbHBlcjtcbktleUhlbHBlci5nZXRJZGVudGl0eUJ5dGVzID0gZnVuY3Rpb24gKGlkZW50aXR5KSB7XG4gICAgY29uc3QgcHVibGljS2V5Qnl0ZXMgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhwdWJsaWNLZXlCeXRlcy5idWZmZXIsIDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIHZpZXcuc2V0QmlnVWludDY0KGkgKiA4LCAwbiwgdHJ1ZSk7XG4gICAgICAgIGZvciAobGV0IGogPSAxNDsgai0tID4gMDspIHtcbiAgICAgICAgICAgIHZpZXcuc2V0QmlnVWludDY0KGkgKiA4LCB2aWV3LmdldEJpZ1VpbnQ2NChpICogOCwgdHJ1ZSkgKiAyNm4gKyBCaWdJbnQoaWRlbnRpdHkuY2hhckNvZGVBdChpICogMTQgKyBqKSkgLSBCaWdJbnQoJ0EnLmNoYXJDb2RlQXQoMCkpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHVibGljS2V5Qnl0ZXM7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1YmljRW50aXR5UmVxdWVzdCA9IHZvaWQgMDtcbmNvbnN0IFF1YmljUGFja2FnZUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi9RdWJpY1BhY2thZ2VCdWlsZGVyXCIpO1xuY29uc3QgUHVibGljS2V5XzEgPSByZXF1aXJlKFwiLi4vcXViaWMtdHlwZXMvUHVibGljS2V5XCIpO1xuY29uc3QgUXViaWNEZWZpbml0aW9uc18xID0gcmVxdWlyZShcIi4uL1F1YmljRGVmaW5pdGlvbnNcIik7XG4vKipcbiAqIHR5cGVkZWYgc3RydWN0XG4qIHtcbiogICAgIHVuc2lnbmVkIGNoYXIgcHVibGljS2V5WzMyXTtcbiogfSBSZXF1ZXN0ZWRFbnRpdHk7XG4gKi9cbmNsYXNzIFF1YmljRW50aXR5UmVxdWVzdCB7XG4gICAgZ2V0UHVibGljS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJsaWNLZXk7XG4gICAgfVxuICAgIHNldFB1YmxpY0tleShwdWJsaWNLZXkpIHtcbiAgICAgICAgdGhpcy5wdWJsaWNLZXkgPSBwdWJsaWNLZXk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHB1YmxpY0tleSkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbFBhY2thZ2VTaXplID0gMzI7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gbmV3IFB1YmxpY0tleV8xLlB1YmxpY0tleSgpO1xuICAgICAgICBpZiAocHVibGljS2V5ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLnNldFB1YmxpY0tleShwdWJsaWNLZXkpO1xuICAgIH1cbiAgICBnZXRQYWNrYWdlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFja2FnZURhdGEoKS5sZW5ndGg7XG4gICAgfVxuICAgIHBhcnNlKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSB0aGlzLl9pbnRlcm5hbFBhY2thZ2VTaXplKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSU5WQUxJRCBQQUNLQUdFIFNJWkVcIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0UHVibGljS2V5KG5ldyBQdWJsaWNLZXlfMS5QdWJsaWNLZXkoZGF0YS5zbGljZSgwLCBRdWJpY0RlZmluaXRpb25zXzEuUXViaWNEZWZpbml0aW9ucy5QVUJMSUNfS0VZX0xFTkdUSCkpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldFBhY2thZ2VEYXRhKCkge1xuICAgICAgICBjb25zdCBidWlsZGVyID0gbmV3IFF1YmljUGFja2FnZUJ1aWxkZXJfMS5RdWJpY1BhY2thZ2VCdWlsZGVyKHRoaXMuX2ludGVybmFsUGFja2FnZVNpemUpO1xuICAgICAgICBidWlsZGVyLmFkZCh0aGlzLnB1YmxpY0tleSk7XG4gICAgICAgIHJldHVybiBidWlsZGVyLmdldERhdGEoKTtcbiAgICB9XG59XG5leHBvcnRzLlF1YmljRW50aXR5UmVxdWVzdCA9IFF1YmljRW50aXR5UmVxdWVzdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5RdWJpY0VudGl0eVJlc3BvbnNlID0gdm9pZCAwO1xuY29uc3QgUXViaWNQYWNrYWdlQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uL1F1YmljUGFja2FnZUJ1aWxkZXJcIik7XG5jb25zdCBRdWJpY0VudGl0eV8xID0gcmVxdWlyZShcIi4uL3F1YmljLXR5cGVzL1F1YmljRW50aXR5XCIpO1xuLyoqXG4gKiB0eXBlZGVmIHN0cnVjdFxuICoge1xuICogICAgIHVuc2lnbmVkIGNoYXIgcHVibGljS2V5WzMyXTtcbiAqICAgICBsb25nIGxvbmcgaW5jb21pbmdBbW91bnQsIG91dGdvaW5nQW1vdW50O1xuICogICAgIHVuc2lnbmVkIGludCBudW1iZXJPZkluY29taW5nVHJhbnNmZXJzLCBudW1iZXJPZk91dGdvaW5nVHJhbnNmZXJzO1xuICogICAgIHVuc2lnbmVkIGludCBsYXRlc3RJbmNvbWluZ1RyYW5zZmVyVGljaywgbGF0ZXN0T3V0Z29pbmdUcmFuc2ZlclRpY2s7XG4gKiAgICAgdW5zaWduZWQgaW50IHRpY2s7XG4gKiAgICAgaW50IHNwZWN0cnVtSW5kZXg7XG4gKiAgICAgdW5zaWduZWQgY2hhciBzaWJsaW5nc1tTUEVDVFJVTV9ERVBUSF1bMzJdO1xuICogfSBSZXNwb25kZWRFbnRpdHk7XG4gKi9cbmNsYXNzIFF1YmljRW50aXR5UmVzcG9uc2Uge1xuICAgIGdldEVudGl0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50aXR5O1xuICAgIH1cbiAgICBzZXRFbnRpdHkoZW50aXR5KSB7XG4gICAgICAgIHRoaXMuZW50aXR5ID0gZW50aXR5O1xuICAgIH1cbiAgICBnZXRUaWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aWNrO1xuICAgIH1cbiAgICBzZXRUaWNrKHRpY2spIHtcbiAgICAgICAgdGhpcy50aWNrID0gdGljaztcbiAgICB9XG4gICAgZ2V0U3BlY3RydW1JbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlY3RydW1JbmRleDtcbiAgICB9XG4gICAgc2V0U3BlY3RydW1JbmRleChzcGVjdHJ1bUluZGV4KSB7XG4gICAgICAgIHRoaXMuc3BlY3RydW1JbmRleCA9IHNwZWN0cnVtSW5kZXg7XG4gICAgfVxuICAgIGdldFNpYmxpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWJsaW5ncztcbiAgICB9XG4gICAgc2V0U2libGluZ3Moc2libGluZ3MpIHtcbiAgICAgICAgdGhpcy5zaWJsaW5ncyA9IHNpYmxpbmdzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxQYWNrYWdlU2l6ZSA9IDg0MDtcbiAgICAgICAgdGhpcy5lbnRpdHkgPSBuZXcgUXViaWNFbnRpdHlfMS5RdWJpY0VudGl0eSgpO1xuICAgICAgICB0aGlzLnRpY2sgPSAwO1xuICAgICAgICB0aGlzLnNwZWN0cnVtSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnNpYmxpbmdzID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9XG4gICAgZ2V0UGFja2FnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBhY2thZ2VEYXRhKCkubGVuZ3RoO1xuICAgIH1cbiAgICBwYXJzZShkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5faW50ZXJuYWxQYWNrYWdlU2l6ZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIklOVkFMSUQgUEFDS0FHRSBTSVpFXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlcik7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCBlbnRpdHkgPSBuZXcgUXViaWNFbnRpdHlfMS5RdWJpY0VudGl0eSgpO1xuICAgICAgICBpZiAoZW50aXR5LnBhcnNlKGRhdGEuc2xpY2UoMCwgZW50aXR5LmdldFBhY2thZ2VTaXplKCkpKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldEVudGl0eShlbnRpdHkpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGVudGl0eS5nZXRQYWNrYWdlU2l6ZSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRUaWNrKGRhdGFWaWV3LmdldEludDMyKG9mZnNldCwgdHJ1ZSkpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB0aGlzLnNldFNwZWN0cnVtSW5kZXgoZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCB0cnVlKSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIHRoaXMuc2V0U2libGluZ3MoZGF0YS5zbGljZShvZmZzZXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0UGFja2FnZURhdGEoKSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkZXIgPSBuZXcgUXViaWNQYWNrYWdlQnVpbGRlcl8xLlF1YmljUGFja2FnZUJ1aWxkZXIodGhpcy5faW50ZXJuYWxQYWNrYWdlU2l6ZSk7XG4gICAgICAgIGJ1aWxkZXIuYWRkKHRoaXMuZW50aXR5KTtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQodGhpcy50aWNrKTtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQodGhpcy5zcGVjdHJ1bUluZGV4KTtcbiAgICAgICAgYnVpbGRlci5hZGRSYXcodGhpcy5zaWJsaW5ncyk7XG4gICAgICAgIHJldHVybiBidWlsZGVyLmdldERhdGEoKTtcbiAgICB9XG59XG5leHBvcnRzLlF1YmljRW50aXR5UmVzcG9uc2UgPSBRdWJpY0VudGl0eVJlc3BvbnNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1YmljUGFja2FnZVR5cGUgPSB2b2lkIDA7XG5jbGFzcyBRdWJpY1BhY2thZ2VUeXBlIHtcbn1cbmV4cG9ydHMuUXViaWNQYWNrYWdlVHlwZSA9IFF1YmljUGFja2FnZVR5cGU7XG5RdWJpY1BhY2thZ2VUeXBlLkVYQ0hBTkdFX1BVQkxJQ19QRUVSID0gMDtcblF1YmljUGFja2FnZVR5cGUuQlJPQURDQVNUX01FU1NBR0UgPSAxO1xuUXViaWNQYWNrYWdlVHlwZS5CUk9BRENBU1RfQ09NUFVUT1JTID0gMjtcblF1YmljUGFja2FnZVR5cGUuQlJPQURDQVNUX1RJQ0sgPSAzO1xuUXViaWNQYWNrYWdlVHlwZS5CUk9BRENBU1RfRlVUVVJFX1RJQ0tfREFUQSA9IDg7XG5RdWJpY1BhY2thZ2VUeXBlLlJFUVVFU1RfQ09NUFVUT1JTID0gMTE7XG5RdWJpY1BhY2thZ2VUeXBlLlJFUVVFU1RfUVVPUlVNX1RJQ0sgPSAxNDtcblF1YmljUGFja2FnZVR5cGUuUkVRVUVTVF9USUNLX0RBVEEgPSAxNjtcblF1YmljUGFja2FnZVR5cGUuQlJPQURDQVNUX1RSQU5TQUNUSU9OID0gMjQ7XG5RdWJpY1BhY2thZ2VUeXBlLlJFUVVFU1RfQ1VSUkVOVF9USUNLX0lORk8gPSAyNztcblF1YmljUGFja2FnZVR5cGUuUkVTUE9ORF9DVVJSRU5UX1RJQ0tfSU5GTyA9IDI4O1xuUXViaWNQYWNrYWdlVHlwZS5SRVFVRVNUX1RJQ0tfVFJBTlNBQ1RJT05TID0gMjk7XG5RdWJpY1BhY2thZ2VUeXBlLlJFUVVFU1RfRU5USVRZID0gMzE7XG5RdWJpY1BhY2thZ2VUeXBlLlJFU1BPTkRfRU5USVRZID0gMzI7XG5RdWJpY1BhY2thZ2VUeXBlLlJFUVVFU1RfQ09OVFJBQ1RfSVBPID0gMzM7XG5RdWJpY1BhY2thZ2VUeXBlLlJFU1BPTkRfQ09OVFJBQ1RfSVBPID0gMzQ7XG5RdWJpY1BhY2thZ2VUeXBlLlJFUVVFU1RfSVNTVUVEX0FTU0VUUyA9IDM2O1xuUXViaWNQYWNrYWdlVHlwZS5SRVNQT05EX0lTU1VFRF9BU1NFVFMgPSAzNztcblF1YmljUGFja2FnZVR5cGUuUkVRVUVTVF9PV05FRF9BU1NFVFMgPSAzODtcblF1YmljUGFja2FnZVR5cGUuUkVTUE9ORF9PV05FRF9BU1NFVFMgPSAzOTtcblF1YmljUGFja2FnZVR5cGUuUkVRVUVTVF9QT1NTRVNTRURfQVNTRVRTID0gMzk7XG5RdWJpY1BhY2thZ2VUeXBlLlJFU1BPTkRfUE9TU0VTU0VEX0FTU0VUUyA9IDQwO1xuUXViaWNQYWNrYWdlVHlwZS5QUk9DRVNTX1NQRUNJQUxfQ09NTUFORCA9IDI1NTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZWNlaXZlZFBhY2thZ2UgPSB2b2lkIDA7XG5jbGFzcyBSZWNlaXZlZFBhY2thZ2Uge1xufVxuZXhwb3J0cy5SZWNlaXZlZFBhY2thZ2UgPSBSZWNlaXZlZFBhY2thZ2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVxdWVzdFJlc3BvbnNlSGVhZGVyID0gdm9pZCAwO1xuY2xhc3MgUmVxdWVzdFJlc3BvbnNlSGVhZGVyIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrYWdlVHlwZSB0eXBlIG9mIHRoZSBwYWNrYWdlIHRvIHNlbmQgKHVzZSBRdWJpY1BhY2thZ2V0eXBlcyBzdGF0aWNzKVxuICAgICAqIEBwYXJhbSBwYXlsb2FkU2l6ZSBzaXplIG9mIHRoZSBxdWJpYyBwYWNrYWdlIChoZWFkZXIgc2l6ZSBpcyBhZGRlZCBhdXRvbWF0aWNhbGx5KVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHBhY2thZ2VUeXBlID0gdW5kZWZpbmVkLCBwYXlsb2FkU2l6ZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB0aGlzLnR5cGUgPSAwO1xuICAgICAgICB0aGlzLmRlamFWdSA9IDA7XG4gICAgICAgIGlmIChwYWNrYWdlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFR5cGUocGFja2FnZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXlsb2FkU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNpemUocGF5bG9hZFNpemUgKyB0aGlzLmdldFBhY2thZ2VTaXplKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRTaXplKHRoaXMuZ2V0UGFja2FnZVNpemUoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0VHlwZSh0KSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgIH1cbiAgICBzZXRTaXplKHQpIHtcbiAgICAgICAgdGhpcy5zaXplID0gdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgfVxuICAgIHNldERlamFWdSh0KSB7XG4gICAgICAgIHRoaXMuZGVqYVZ1ID0gdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldERlamFWdSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVqYVZ1O1xuICAgIH1cbiAgICByYW5kb21pemVEZWphVnUoKSB7XG4gICAgICAgIHRoaXMuZGVqYVZ1ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjE0NzQ4MzY0Nyk7XG4gICAgfVxuICAgIGdldFBhY2thZ2VTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWNrYWdlRGF0YSgpLmxlbmd0aDtcbiAgICB9XG4gICAgcGFyc2UoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCA4KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSU5WQUxJRCBQQUNLQUdFIFNJWkVcIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U2l6ZSgoZGF0YVsyXSA8PCAxNikgfCAoZGF0YVsxXSA8PCA4KSB8IGRhdGFbMF0pO1xuICAgICAgICB0aGlzLnNldFR5cGUoZGF0YVszXSk7XG4gICAgICAgIHRoaXMuc2V0RGVqYVZ1KChkYXRhWzJdIDw8IDI0KSB8IChkYXRhWzJdIDw8IDE2KSB8IChkYXRhWzFdIDw8IDgpIHwgZGF0YVswXSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRQYWNrYWdlRGF0YSgpIHtcbiAgICAgICAgLy8gdmFsaWRhdGlvbiBvZiBwYWNrZXRcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSA+IDE2Nzc3MjE1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaXplIGNhbm5vdCBiZSA+MTY3NzcyMTVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHlwZSA+IDI1NSB8fCB0aGlzLnR5cGUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAyNTVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoOCkuZmlsbCgwKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIC8vIGdlbmVyYXRlIHNpemVcbiAgICAgICAgYnl0ZXNbb2Zmc2V0KytdID0gdGhpcy5zaXplO1xuICAgICAgICBieXRlc1tvZmZzZXQrK10gPSAodGhpcy5zaXplID4+IDgpO1xuICAgICAgICBieXRlc1tvZmZzZXQrK10gPSAodGhpcy5zaXplID4+IDE2KTtcbiAgICAgICAgYnl0ZXNbb2Zmc2V0KytdID0gdGhpcy50eXBlO1xuICAgICAgICBieXRlc1tvZmZzZXQrK10gPSB0aGlzLmRlamFWdTtcbiAgICAgICAgYnl0ZXNbb2Zmc2V0KytdID0gKHRoaXMuZGVqYVZ1ID4+IDgpO1xuICAgICAgICBieXRlc1tvZmZzZXQrK10gPSAodGhpcy5kZWphVnUgPj4gMTYpO1xuICAgICAgICBieXRlc1tvZmZzZXQrK10gPSAodGhpcy5kZWphVnUgPj4gMjQpO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0UmVzcG9uc2VIZWFkZXIgPSBSZXF1ZXN0UmVzcG9uc2VIZWFkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRHluYW1pY1BheWxvYWQgPSB2b2lkIDA7XG5jbGFzcyBEeW5hbWljUGF5bG9hZCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZHluYW1pYyBwYXlsb2FkXG4gICAgICogdGhlIG1heFNpemUgc2hvdWxkIGJlIHNldCB0byB0aGUgbWF4IGV4cGVjdGVkIHNpemUgZm9yIHRoaXMgcGFsb2FkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1heFNpemUpIHtcbiAgICAgICAgdGhpcy5maWxsZWRTaXplID0gMDtcbiAgICAgICAgdGhpcy5tYXhTaXplID0gMDtcbiAgICAgICAgdGhpcy5ieXRlcyA9IG5ldyBVaW50OEFycmF5KG1heFNpemUpLmZpbGwoMCk7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IG1heFNpemU7XG4gICAgfVxuICAgIHNldFBheWxvYWQoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiB0aGlzLm1heFNpemUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIG11c3QgYmUgbG93ZXIgb3IgZXF1YWwgXCIgKyB0aGlzLm1heFNpemUpO1xuICAgICAgICB0aGlzLmJ5dGVzID0gZGF0YTtcbiAgICAgICAgdGhpcy5maWxsZWRTaXplID0gdGhpcy5ieXRlcy5sZW5ndGg7XG4gICAgfVxuICAgIGdldFBhY2thZ2VEYXRhKCkge1xuICAgICAgICBpZiAodGhpcy5maWxsZWRTaXplID09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzO1xuICAgIH1cbiAgICBnZXRQYWNrYWdlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsbGVkU2l6ZTtcbiAgICB9XG59XG5leHBvcnRzLkR5bmFtaWNQYXlsb2FkID0gRHluYW1pY1BheWxvYWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTG9uZyA9IHZvaWQgMDtcbmNsYXNzIExvbmcge1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxWYWx1ZSA9IDApIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IEJpZ0ludCgwKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsVmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TnVtYmVyKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5pdGlhbFZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhpbml0aWFsVmFsdWUuYnVmZmVyLCAwKTtcbiAgICAgICAgICAgIHRoaXMuc2V0TnVtYmVyKHZpZXcuZ2V0QmlnVWludDY0KDAsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXROdW1iZXIoaW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXROdW1iZXIobikge1xuICAgICAgICBpZiAodHlwZW9mIG4gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gQmlnSW50KG4pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbjtcbiAgICB9XG4gICAgZ2V0TnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgZ2V0UGFja2FnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiA4OyAvLyBmaXhlZCBzaXplIFxuICAgIH1cbiAgICBnZXRQYWNrYWdlRGF0YSgpIHtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig4KTtcbiAgICAgICAgbGV0IGRhdGF2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgIGRhdGF2aWV3LnNldEJpZ0ludDY0KDAsIHRoaXMudmFsdWUsIHRydWUpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICB9XG59XG5leHBvcnRzLkxvbmcgPSBMb25nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlB1YmxpY0tleSA9IHZvaWQgMDtcbmNvbnN0IGtleUhlbHBlcl8xID0gcmVxdWlyZShcIi4uL2tleUhlbHBlclwiKTtcbmNvbnN0IFF1YmljRGVmaW5pdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9RdWJpY0RlZmluaXRpb25zXCIpO1xuY29uc3QgcXViaWNIZWxwZXJfMSA9IHJlcXVpcmUoXCIuLi9xdWJpY0hlbHBlclwiKTtcbmNsYXNzIFB1YmxpY0tleSB7XG4gICAgY29uc3RydWN0b3IoaWRlbnRpdHkgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ieXRlcyA9IG5ldyBVaW50OEFycmF5KFF1YmljRGVmaW5pdGlvbnNfMS5RdWJpY0RlZmluaXRpb25zLlBVQkxJQ19LRVlfTEVOR1RIKS5maWxsKDApO1xuICAgICAgICB0aGlzLmlkZW50aXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHlwZW9mIGlkZW50aXR5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnNldElkZW50aXR5RnJvbVN0cmluZyhpZGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWRlbnRpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRJZGVudGl0eShpZGVudGl0eSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SWRlbnRpdHlGcm9tU3RyaW5nKGlkKSB7XG4gICAgICAgIHRoaXMuaWRlbnRpdHkgPSBpZDtcbiAgICAgICAgdGhpcy5zZXRJZGVudGl0eShrZXlIZWxwZXJfMS5LZXlIZWxwZXIuZ2V0SWRlbnRpdHlCeXRlcyhpZCkpO1xuICAgIH1cbiAgICBhc3luYyBzZXRJZGVudGl0eShieXRlcykge1xuICAgICAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgICAgIC8vIGNvbnZlcnQgYnl0ZSB0byBpZFxuICAgICAgICB0aGlzLmlkZW50aXR5ID0gYXdhaXQgbmV3IHF1YmljSGVscGVyXzEuUXViaWNIZWxwZXIoKS5nZXRJZGVudGl0eShieXRlcyk7XG4gICAgfVxuICAgIGdldElkZW50aXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcztcbiAgICB9XG4gICAgZ2V0SWRlbnRpdHlBc1NyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZGVudGl0eTtcbiAgICB9XG4gICAgZ2V0UGFja2FnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0UGFja2FnZURhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzO1xuICAgIH1cbiAgICBlcXVhbHMoY29tcGFyZSkge1xuICAgICAgICByZXR1cm4gY29tcGFyZSAmJiB0aGlzLmJ5dGVzLmxlbmd0aCA9PT0gY29tcGFyZS5ieXRlcy5sZW5ndGggJiYgdGhpcy5ieXRlcy5ldmVyeSgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZSA9PT0gY29tcGFyZS5ieXRlc1tpbmRleF0pO1xuICAgIH1cbiAgICBhc3luYyB2ZXJpZnlJZGVudGl0eSgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IG5ldyBxdWJpY0hlbHBlcl8xLlF1YmljSGVscGVyKCkudmVyaWZ5SWRlbnRpdHkodGhpcy5pZGVudGl0eSk7XG4gICAgfVxufVxuZXhwb3J0cy5QdWJsaWNLZXkgPSBQdWJsaWNLZXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXViaWNFbnRpdHkgPSB2b2lkIDA7XG5jb25zdCBMb25nXzEgPSByZXF1aXJlKFwiLi9Mb25nXCIpO1xuY29uc3QgUXViaWNQYWNrYWdlQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uL1F1YmljUGFja2FnZUJ1aWxkZXJcIik7XG5jb25zdCBQdWJsaWNLZXlfMSA9IHJlcXVpcmUoXCIuL1B1YmxpY0tleVwiKTtcbmNvbnN0IFF1YmljRGVmaW5pdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9RdWJpY0RlZmluaXRpb25zXCIpO1xuLyoqXG4gKiB0eXBlZGVmIHN0cnVjdFxuICoge1xuICogICAgIHVuc2lnbmVkIGNoYXIgcHVibGljS2V5WzMyXTtcbiAqICAgICBsb25nIGxvbmcgaW5jb21pbmdBbW91bnQsIG91dGdvaW5nQW1vdW50O1xuICogICAgIHVuc2lnbmVkIGludCBudW1iZXJPZkluY29taW5nVHJhbnNmZXJzLCBudW1iZXJPZk91dGdvaW5nVHJhbnNmZXJzO1xuICogICAgIHVuc2lnbmVkIGludCBsYXRlc3RJbmNvbWluZ1RyYW5zZmVyVGljaywgbGF0ZXN0T3V0Z29pbmdUcmFuc2ZlclRpY2s7XG4gKiB9IEVudGl0eTtcbiAqL1xuY2xhc3MgUXViaWNFbnRpdHkge1xuICAgIGdldFB1YmxpY0tleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVibGljS2V5O1xuICAgIH1cbiAgICBzZXRQdWJsaWNLZXkocHVibGljS2V5KSB7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gcHVibGljS2V5O1xuICAgIH1cbiAgICBnZXRJbmNvbWluZ0Ftb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5jb21pbmdBbW91bnQ7XG4gICAgfVxuICAgIHNldEluY29taW5nQW1vdW50KGluY29taW5nQWNtb3VudCkge1xuICAgICAgICB0aGlzLmluY29taW5nQW1vdW50ID0gaW5jb21pbmdBY21vdW50O1xuICAgIH1cbiAgICBnZXRPdXRnb2luZ0Ftb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0Z29pbmdBbW91bnQ7XG4gICAgfVxuICAgIHNldE91dGdvaW5nQW1vdW50KG91dGdvaW5nQW1vdW50KSB7XG4gICAgICAgIHRoaXMub3V0Z29pbmdBbW91bnQgPSBvdXRnb2luZ0Ftb3VudDtcbiAgICB9XG4gICAgZ2V0TnVtYmVyT2ZJbmNvbWluZ1RyYW5zZmVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtYmVyT2ZJbmNvbWluZ1RyYW5zZmVycztcbiAgICB9XG4gICAgc2V0TnVtYmVyT2ZJbmNvbWluZ1RyYW5zZmVycyhudW1iZXJPZkluY29taW5nVHJhbnNmZXJzKSB7XG4gICAgICAgIHRoaXMubnVtYmVyT2ZJbmNvbWluZ1RyYW5zZmVycyA9IG51bWJlck9mSW5jb21pbmdUcmFuc2ZlcnM7XG4gICAgfVxuICAgIGdldE51bWJlck9mT3V0Z29pbmdUcmFuc2ZlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bWJlck9mT3V0Z29pbmdUcmFuc2ZlcnM7XG4gICAgfVxuICAgIHNldE51bWJlck9mT3V0Z29pbmdUcmFuc2ZlcnMobnVtYmVyT2ZPdXRnb2luZ1RyYW5zZmVycykge1xuICAgICAgICB0aGlzLm51bWJlck9mT3V0Z29pbmdUcmFuc2ZlcnMgPSBudW1iZXJPZk91dGdvaW5nVHJhbnNmZXJzO1xuICAgIH1cbiAgICBnZXRMYXRlc3RJbmNvbWluZ1RyYW5zZmVyVGljaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF0ZXN0SW5jb21pbmdUcmFuc2ZlclRpY2s7XG4gICAgfVxuICAgIHNldExhdGVzdEluY29taW5nVHJhbnNmZXJUaWNrKGxhdGVzdEluY29taW5nVHJhbnNmZXJUaWNrKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0SW5jb21pbmdUcmFuc2ZlclRpY2sgPSBsYXRlc3RJbmNvbWluZ1RyYW5zZmVyVGljaztcbiAgICB9XG4gICAgZ2V0TGF0ZXN0T3V0Z29pbmdUcmFuc2ZlclRpY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhdGVzdE91dGdvaW5nVHJhbnNmZXJUaWNrO1xuICAgIH1cbiAgICBzZXRMYXRlc3RPdXRnb2luZ1RyYW5zZmVyVGljayhsYXRlc3RPdXRnb2luZ1RyYW5zZmVyVGljaykge1xuICAgICAgICB0aGlzLmxhdGVzdE91dGdvaW5nVHJhbnNmZXJUaWNrID0gbGF0ZXN0T3V0Z29pbmdUcmFuc2ZlclRpY2s7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbFBhY2thZ2VTaXplID0gNjQ7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gbmV3IFB1YmxpY0tleV8xLlB1YmxpY0tleSgpO1xuICAgICAgICB0aGlzLmluY29taW5nQW1vdW50ID0gbmV3IExvbmdfMS5Mb25nKCk7XG4gICAgICAgIHRoaXMub3V0Z29pbmdBbW91bnQgPSBuZXcgTG9uZ18xLkxvbmcoKTtcbiAgICAgICAgdGhpcy5udW1iZXJPZkluY29taW5nVHJhbnNmZXJzID0gMDtcbiAgICAgICAgdGhpcy5udW1iZXJPZk91dGdvaW5nVHJhbnNmZXJzID0gMDtcbiAgICAgICAgdGhpcy5sYXRlc3RJbmNvbWluZ1RyYW5zZmVyVGljayA9IDA7XG4gICAgICAgIHRoaXMubGF0ZXN0T3V0Z29pbmdUcmFuc2ZlclRpY2sgPSAwO1xuICAgIH1cbiAgICBnZXRCYWxhbmNlKCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMuZ2V0SW5jb21pbmdBbW91bnQoKS5nZXROdW1iZXIoKSAtIHRoaXMuZ2V0T3V0Z29pbmdBbW91bnQoKS5nZXROdW1iZXIoKSk7XG4gICAgfVxuICAgIGdldFBhY2thZ2VTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWNrYWdlRGF0YSgpLmxlbmd0aDtcbiAgICB9XG4gICAgcGFyc2UoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IHRoaXMuX2ludGVybmFsUGFja2FnZVNpemUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJTlZBTElEIFBBQ0tBR0UgU0laRVwiKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoZGF0YS5idWZmZXIpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5zZXRQdWJsaWNLZXkobmV3IFB1YmxpY0tleV8xLlB1YmxpY0tleShkYXRhLnNsaWNlKDAsIFF1YmljRGVmaW5pdGlvbnNfMS5RdWJpY0RlZmluaXRpb25zLlBVQkxJQ19LRVlfTEVOR1RIKSkpO1xuICAgICAgICBvZmZzZXQgKz0gUXViaWNEZWZpbml0aW9uc18xLlF1YmljRGVmaW5pdGlvbnMuUFVCTElDX0tFWV9MRU5HVEg7XG4gICAgICAgIHRoaXMuc2V0SW5jb21pbmdBbW91bnQobmV3IExvbmdfMS5Mb25nKGRhdGFWaWV3LmdldEJpZ0ludDY0KG9mZnNldCwgdHJ1ZSkpKTtcbiAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgIHRoaXMuc2V0T3V0Z29pbmdBbW91bnQobmV3IExvbmdfMS5Mb25nKGRhdGFWaWV3LmdldEJpZ0ludDY0KG9mZnNldCwgdHJ1ZSkpKTtcbiAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgIHRoaXMuc2V0TnVtYmVyT2ZJbmNvbWluZ1RyYW5zZmVycyhkYXRhVmlldy5nZXRJbnQzMihvZmZzZXQsIHRydWUpKTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHRoaXMuc2V0TnVtYmVyT2ZPdXRnb2luZ1RyYW5zZmVycyhkYXRhVmlldy5nZXRJbnQzMihvZmZzZXQsIHRydWUpKTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIHRoaXMuc2V0TGF0ZXN0SW5jb21pbmdUcmFuc2ZlclRpY2soZGF0YVZpZXcuZ2V0SW50MzIob2Zmc2V0LCB0cnVlKSk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICB0aGlzLnNldExhdGVzdE91dGdvaW5nVHJhbnNmZXJUaWNrKGRhdGFWaWV3LmdldEludDMyKG9mZnNldCwgdHJ1ZSkpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldFBhY2thZ2VEYXRhKCkge1xuICAgICAgICBjb25zdCBidWlsZGVyID0gbmV3IFF1YmljUGFja2FnZUJ1aWxkZXJfMS5RdWJpY1BhY2thZ2VCdWlsZGVyKHRoaXMuX2ludGVybmFsUGFja2FnZVNpemUpO1xuICAgICAgICBidWlsZGVyLmFkZCh0aGlzLnB1YmxpY0tleSk7XG4gICAgICAgIGJ1aWxkZXIuYWRkKHRoaXMuaW5jb21pbmdBbW91bnQpO1xuICAgICAgICBidWlsZGVyLmFkZCh0aGlzLm91dGdvaW5nQW1vdW50KTtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQodGhpcy5udW1iZXJPZkluY29taW5nVHJhbnNmZXJzKTtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQodGhpcy5udW1iZXJPZk91dGdvaW5nVHJhbnNmZXJzKTtcbiAgICAgICAgYnVpbGRlci5hZGRJbnQodGhpcy5sYXRlc3RJbmNvbWluZ1RyYW5zZmVyVGljayk7XG4gICAgICAgIGJ1aWxkZXIuYWRkSW50KHRoaXMubGF0ZXN0T3V0Z29pbmdUcmFuc2ZlclRpY2spO1xuICAgICAgICByZXR1cm4gYnVpbGRlci5nZXREYXRhKCk7XG4gICAgfVxufVxuZXhwb3J0cy5RdWJpY0VudGl0eSA9IFF1YmljRW50aXR5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1YmljVGlja0RhdGEgPSB2b2lkIDA7XG5jb25zdCBRdWJpY0RlZmluaXRpb25zXzEgPSByZXF1aXJlKFwiLi4vUXViaWNEZWZpbml0aW9uc1wiKTtcbmNvbnN0IFNpZ25hdHVyZV8xID0gcmVxdWlyZShcIi4vU2lnbmF0dXJlXCIpO1xuLyoqXG4gKiB0eXBlZGVmIHN0cnVjdFxue1xuICAgIHVuc2lnbmVkIHNob3J0IGNvbXB1dG9ySW5kZXg7XG4gICAgdW5zaWduZWQgc2hvcnQgZXBvY2g7XG4gICAgdW5zaWduZWQgaW50IHRpY2s7XG5cbiAgICB1bnNpZ25lZCBzaG9ydCBtaWxsaXNlY29uZDtcbiAgICB1bnNpZ25lZCBjaGFyIHNlY29uZDtcbiAgICB1bnNpZ25lZCBjaGFyIG1pbnV0ZTtcbiAgICB1bnNpZ25lZCBjaGFyIGhvdXI7XG4gICAgdW5zaWduZWQgY2hhciBkYXk7XG4gICAgdW5zaWduZWQgY2hhciBtb250aDtcbiAgICB1bnNpZ25lZCBjaGFyIHllYXI7XG5cbiAgICB1bmlvblxuICAgIHtcbiAgICAgICAgc3RydWN0XG4gICAgICAgIHtcbiAgICAgICAgICAgIHVuc2lnbmVkIGNoYXIgdXJpU2l6ZTtcbiAgICAgICAgICAgIHVuc2lnbmVkIGNoYXIgdXJpWzI1NV07XG4gICAgICAgIH0gcHJvcG9zYWw7XG4gICAgICAgIHN0cnVjdFxuICAgICAgICB7XG4gICAgICAgICAgICB1bnNpZ25lZCBjaGFyIHplcm87XG4gICAgICAgICAgICB1bnNpZ25lZCBjaGFyIHZvdGVzWyhOVU1CRVJfT0ZfQ09NUFVUT1JTICogMyArIDcpIC8gOF07XG4gICAgICAgICAgICB1bnNpZ25lZCBjaGFyIHF1YXNpUmFuZG9tTnVtYmVyO1xuICAgICAgICB9IGJhbGxvdDtcbiAgICB9IHZhclN0cnVjdDtcblxuICAgIHVuc2lnbmVkIGNoYXIgdGltZWxvY2tbMzJdO1xuICAgIHVuc2lnbmVkIGNoYXIgdHJhbnNhY3Rpb25EaWdlc3RzW05VTUJFUl9PRl9UUkFOU0FDVElPTlNfUEVSX1RJQ0tdWzMyXTtcbiAgICBsb25nIGxvbmcgY29udHJhY3RGZWVzW01BWF9OVU1CRVJfT0ZfQ09OVFJBQ1RTXTtcblxuICAgIHVuc2lnbmVkIGNoYXIgc2lnbmF0dXJlW1NJR05BVFVSRV9TSVpFXTtcbn0gVGlja0RhdGE7XG4gKi9cbmNsYXNzIFF1YmljVGlja0RhdGEge1xuICAgIGdldCB1bmlvbkRhdGFWaWV3KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3VuaW9uRGF0YVZpZXcpXG4gICAgICAgICAgICB0aGlzLl91bmlvbkRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRoaXMudW5pb25EYXRhLmJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0aGlzLl91bmlvbkRhdGFWaWV3O1xuICAgIH1cbiAgICBzZXQgdW5pb25EYXRhVmlldyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl91bmlvbkRhdGFWaWV3ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldFNpZ25hdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlO1xuICAgIH1cbiAgICBzZXRTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICAgIH1cbiAgICBnZXRDb21wdXRvckluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRvckluZGV4O1xuICAgIH1cbiAgICBzZXRDb21wdXRvckluZGV4KGNvbXB1dG9ySW5kZXgpIHtcbiAgICAgICAgdGhpcy5jb21wdXRvckluZGV4ID0gY29tcHV0b3JJbmRleDtcbiAgICB9XG4gICAgZ2V0RXBvY2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVwb2NoO1xuICAgIH1cbiAgICBzZXRFcG9jaChlcG9jaCkge1xuICAgICAgICB0aGlzLmVwb2NoID0gZXBvY2g7XG4gICAgfVxuICAgIGdldFRpY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpY2s7XG4gICAgfVxuICAgIHNldFRpY2sodGljaykge1xuICAgICAgICB0aGlzLnRpY2sgPSB0aWNrO1xuICAgIH1cbiAgICBnZXRNaWxsaXNlY29uZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQ7XG4gICAgfVxuICAgIHNldE1pbGxpc2Vjb25kKG1pbGxpc2Vjb25kKSB7XG4gICAgICAgIHRoaXMubWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZDtcbiAgICB9XG4gICAgZ2V0U2Vjb25kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmQ7XG4gICAgfVxuICAgIHNldFNlY29uZChzZWNvbmQpIHtcbiAgICAgICAgdGhpcy5zZWNvbmQgPSBzZWNvbmQ7XG4gICAgfVxuICAgIGdldE1pbnV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWludXRlO1xuICAgIH1cbiAgICBzZXRNaW51dGUobWludXRlKSB7XG4gICAgICAgIHRoaXMubWludXRlID0gbWludXRlO1xuICAgIH1cbiAgICBnZXRIb3VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VyO1xuICAgIH1cbiAgICBzZXRIb3VyKGhvdXIpIHtcbiAgICAgICAgdGhpcy5ob3VyID0gaG91cjtcbiAgICB9XG4gICAgZ2V0RGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXk7XG4gICAgfVxuICAgIHNldERheShkYXkpIHtcbiAgICAgICAgdGhpcy5kYXkgPSBkYXk7XG4gICAgfVxuICAgIGdldE1vbnRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aDtcbiAgICB9XG4gICAgc2V0TW9udGgobW9udGgpIHtcbiAgICAgICAgdGhpcy5tb250aCA9IG1vbnRoO1xuICAgIH1cbiAgICBnZXRZZWFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyO1xuICAgIH1cbiAgICBzZXRZZWFyKHllYXIpIHtcbiAgICAgICAgdGhpcy55ZWFyID0geWVhcjtcbiAgICB9XG4gICAgZ2V0VW5pb25EYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlvbkRhdGE7XG4gICAgfVxuICAgIHNldFVuaW9uRGF0YSh1bmlvbkRhdGEpIHtcbiAgICAgICAgdGhpcy51bmlvbkRhdGEgPSB1bmlvbkRhdGE7XG4gICAgfVxuICAgIGdldFRpbWVMb2NrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aW1lTG9jaztcbiAgICB9XG4gICAgc2V0VGltZUxvY2sodGltZUxvY2spIHtcbiAgICAgICAgdGhpcy50aW1lTG9jayA9IHRpbWVMb2NrO1xuICAgIH1cbiAgICAvLyB0b2RvOiBpbXBsZW1lbnRcbiAgICAvLyBwdWJsaWMgZ2V0VHJhbnNhY3Rpb25EaWdlc3RzKCk6IFVpbnQ4QXJyYXlbXVtdIHtcbiAgICAvLyAgICAgcmV0dXJuIHRoaXMudHJhbnNhY3Rpb25EaWdlc3RzO1xuICAgIC8vIH1cbiAgICBzZXRUcmFuc2FjdGlvbkRpZ2VzdHModHJhbnNhY3Rpb25EaWdlc3RzIC8qIGphZ2dlZCBhcnJheSAxMDI0eDMyICovKSB7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25EaWdlc3RzID0gdHJhbnNhY3Rpb25EaWdlc3RzO1xuICAgIH1cbiAgICBnZXRDb250cmFjdEZlZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyYWN0RmVlcztcbiAgICB9XG4gICAgc2V0Q29udHJhY3RGZWVzKGNvbnRyYWN0RmVlcykge1xuICAgICAgICB0aGlzLmNvbnRyYWN0RmVlcyA9IGNvbnRyYWN0RmVlcztcbiAgICB9XG4gICAgLyogdW5pb24gZGF0YSB0eXBlcyAqL1xuICAgIGdldFByb3Bvc2FsVXJpU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pb25EYXRhWzBdO1xuICAgIH1cbiAgICBzZXRQcm9wb3NhbFVyaVNpemUoc2l6ZSkge1xuICAgICAgICB0aGlzLnVuaW9uRGF0YVswXSA9IHNpemU7XG4gICAgfVxuICAgIGdldFByb3Bvc2FsVXJpKCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHRoaXMudW5pb25EYXRhLnNsaWNlKDEsIHRoaXMuZ2V0UHJvcG9zYWxVcmlTaXplKCkpKTtcbiAgICB9XG4gICAgc2V0UHJvcG9zYWxVcmkodXJpKSB7XG4gICAgICAgIGlmICh1cmkubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVVJJIFNJWkUgTVVTVCBCRSBNQVggMjU1XCIpO1xuICAgICAgICAgICAgdGhyb3cgXCJVUkkgU0laRSBNVVNUIEJFIE1BWCAyNTVcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh1cmkpO1xuICAgICAgICB0aGlzLnVuaW9uRGF0YS5zZXQoYnl0ZXMsIDEpO1xuICAgICAgICB0aGlzLnNldFByb3Bvc2FsVXJpU2l6ZSh1cmkubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFsUGFja2FnZVNpemUgPSA0MTMyODtcbiAgICB9XG4gICAgZ2V0UGFja2FnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFBhY2thZ2VTaXplO1xuICAgIH1cbiAgICBwYXJzZShkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5faW50ZXJuYWxQYWNrYWdlU2l6ZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIklOVkFMSUQgUEFDS0FHRSBTSVpFXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhkYXRhLmJ1ZmZlcik7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLnNldENvbXB1dG9ySW5kZXgoZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCwgdHJ1ZSkpO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgdGhpcy5zZXRFcG9jaChkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0LCB0cnVlKSk7XG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICB0aGlzLnNldFRpY2soZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSkpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgdGhpcy5zZXRNaWxsaXNlY29uZChkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0LCB0cnVlKSk7XG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICB0aGlzLnNldFNlY29uZChkYXRhW29mZnNldCsrXSk7XG4gICAgICAgIHRoaXMuc2V0TWludXRlKGRhdGFbb2Zmc2V0KytdKTtcbiAgICAgICAgdGhpcy5zZXRIb3VyKGRhdGFbb2Zmc2V0KytdKTtcbiAgICAgICAgdGhpcy5zZXREYXkoZGF0YVtvZmZzZXQrK10pO1xuICAgICAgICB0aGlzLnNldE1vbnRoKGRhdGFbb2Zmc2V0KytdKTtcbiAgICAgICAgdGhpcy5zZXRZZWFyKGRhdGFbb2Zmc2V0KytdKTtcbiAgICAgICAgdGhpcy5zZXRVbmlvbkRhdGEoZGF0YS5zbGljZShvZmZzZXQsIDI1NikpO1xuICAgICAgICBvZmZzZXQgKz0gMjU2O1xuICAgICAgICB0aGlzLnNldFRpbWVMb2NrKGRhdGEuc2xpY2Uob2Zmc2V0LCAzMikpO1xuICAgICAgICBvZmZzZXQgKz0gMzI7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNhY3Rpb25EaWdlc3RzKGRhdGEuc2xpY2Uob2Zmc2V0LCBRdWJpY0RlZmluaXRpb25zXzEuUXViaWNEZWZpbml0aW9ucy5OVU1CRVJfT0ZfVFJBTlNBQ1RJT05TX1BFUl9USUNLICogUXViaWNEZWZpbml0aW9uc18xLlF1YmljRGVmaW5pdGlvbnMuRElHRVNUX0xFTkdUSCkpO1xuICAgICAgICBvZmZzZXQgKz0gUXViaWNEZWZpbml0aW9uc18xLlF1YmljRGVmaW5pdGlvbnMuTlVNQkVSX09GX1RSQU5TQUNUSU9OU19QRVJfVElDSyAqIFF1YmljRGVmaW5pdGlvbnNfMS5RdWJpY0RlZmluaXRpb25zLkRJR0VTVF9MRU5HVEg7XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0RmVlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFF1YmljRGVmaW5pdGlvbnNfMS5RdWJpY0RlZmluaXRpb25zLk1BWF9OVU1CRVJfT0ZfQ09OVFJBQ1RTOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnRyYWN0RmVlcy5wdXNoKGRhdGFWaWV3LmdldEJpZ0ludDY0KG9mZnNldCwgdHJ1ZSkpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDb250cmFjdEZlZXMoY29udHJhY3RGZWVzKTtcbiAgICAgICAgdGhpcy5zZXRTaWduYXR1cmUobmV3IFNpZ25hdHVyZV8xLlNpZ25hdHVyZShkYXRhLnNsaWNlKG9mZnNldCwgUXViaWNEZWZpbml0aW9uc18xLlF1YmljRGVmaW5pdGlvbnMuU0lHTkFUVVJFX0xFTkdUSCkpKTtcbiAgICAgICAgb2Zmc2V0ICs9IFF1YmljRGVmaW5pdGlvbnNfMS5RdWJpY0RlZmluaXRpb25zLlNJR05BVFVSRV9MRU5HVEg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRQYWNrYWdlRGF0YSgpIHtcbiAgICAgICAgLy8gdG9kbzogaW1wbGVtZW50XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuUXViaWNUaWNrRGF0YSA9IFF1YmljVGlja0RhdGE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXViaWNUaWNrSW5mbyA9IHZvaWQgMDtcbmNvbnN0IFF1YmljUGFja2FnZUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi9RdWJpY1BhY2thZ2VCdWlsZGVyXCIpO1xuLyoqXG4gKiB0eXBlZGVmIHN0cnVjdFxuKiB7XG4qICAgICB1bnNpZ25lZCBzaG9ydCB0aWNrRHVyYXRpb247XG4qICAgICB1bnNpZ25lZCBzaG9ydCBlcG9jaDtcbiogICAgIHVuc2lnbmVkIGludCB0aWNrO1xuKiAgICAgdW5zaWduZWQgc2hvcnQgbnVtYmVyT2ZBbGlnbmVkVm90ZXM7XG4qICAgICB1bnNpZ25lZCBzaG9ydCBudW1iZXJPZk1pc2FsaWduZWRWb3RlcztcbiogfSBDdXJyZW50VGlja0luZm87XG4gKi9cbmNsYXNzIFF1YmljVGlja0luZm8ge1xuICAgIGdldFRpY2tEdXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlja0R1cmF0aW9uO1xuICAgIH1cbiAgICBzZXRUaWNrRHVyYXRpb24odGlja0R1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMudGlja0R1cmF0aW9uID0gdGlja0R1cmF0aW9uO1xuICAgIH1cbiAgICBnZXRFcG9jaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXBvY2g7XG4gICAgfVxuICAgIHNldEVwb2NoKGVwb2NoKSB7XG4gICAgICAgIHRoaXMuZXBvY2ggPSBlcG9jaDtcbiAgICB9XG4gICAgZ2V0VGljaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGljaztcbiAgICB9XG4gICAgc2V0VGljayh0aWNrKSB7XG4gICAgICAgIHRoaXMudGljayA9IHRpY2s7XG4gICAgfVxuICAgIGdldE51bWJlck9mQWxpZ25lZFZvdGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1iZXJPZkFsaWduZWRWb3RlcztcbiAgICB9XG4gICAgc2V0TnVtYmVyT2ZBbGlnbmVkVm90ZXMobnVtYmVyT2ZBbGlnbmVkVm90ZXMpIHtcbiAgICAgICAgdGhpcy5udW1iZXJPZkFsaWduZWRWb3RlcyA9IG51bWJlck9mQWxpZ25lZFZvdGVzO1xuICAgIH1cbiAgICBnZXROdW1iZXJPZk1pc2FsaWduZWRWb3RlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtYmVyT2ZNaXNhbGlnbmVkVm90ZXM7XG4gICAgfVxuICAgIHNldE51bWJlck9mTWlzYWxpZ25lZFZvdGVzKG51bWJlck9mTWlzYWxpZ25lZFZvdGVzKSB7XG4gICAgICAgIHRoaXMubnVtYmVyT2ZNaXNhbGlnbmVkVm90ZXMgPSBudW1iZXJPZk1pc2FsaWduZWRWb3RlcztcbiAgICB9XG4gICAgZ2V0SW5pdGlhbFRpY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxUaWNrO1xuICAgIH1cbiAgICBzZXRJbml0aWFsVGljayh0aWNrKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbFRpY2sgPSB0aWNrO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxQYWNrYWdlU2l6ZSA9IDE2O1xuICAgICAgICB0aGlzLnRpY2tEdXJhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuZXBvY2ggPSAwO1xuICAgICAgICB0aGlzLnRpY2sgPSAwO1xuICAgICAgICB0aGlzLm51bWJlck9mQWxpZ25lZFZvdGVzID0gMDtcbiAgICAgICAgdGhpcy5udW1iZXJPZk1pc2FsaWduZWRWb3RlcyA9IDA7XG4gICAgICAgIHRoaXMuaW5pdGlhbFRpY2sgPSAwO1xuICAgIH1cbiAgICBnZXRQYWNrYWdlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFja2FnZURhdGEoKS5sZW5ndGg7XG4gICAgfVxuICAgIHBhcnNlKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSB0aGlzLl9pbnRlcm5hbFBhY2thZ2VTaXplKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSU5WQUxJRCBQQUNLQUdFIFNJWkVcIik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuc2V0VGlja0R1cmF0aW9uKGRhdGFWaWV3LmdldEludDE2KDAsIHRydWUpKTtcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIHRoaXMuc2V0RXBvY2goZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCB0cnVlKSk7XG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICB0aGlzLnNldFRpY2soZGF0YVZpZXcuZ2V0SW50MzIob2Zmc2V0LCB0cnVlKSk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICB0aGlzLnNldE51bWJlck9mQWxpZ25lZFZvdGVzKGRhdGFWaWV3LmdldEludDE2KG9mZnNldCwgdHJ1ZSkpO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgdGhpcy5zZXROdW1iZXJPZk1pc2FsaWduZWRWb3RlcyhkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIHRydWUpKTtcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgIHRoaXMuc2V0SW5pdGlhbFRpY2soZGF0YVZpZXcuZ2V0SW50MzIob2Zmc2V0LCB0cnVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRQYWNrYWdlRGF0YSgpIHtcbiAgICAgICAgY29uc3QgYnVpbGRlciA9IG5ldyBRdWJpY1BhY2thZ2VCdWlsZGVyXzEuUXViaWNQYWNrYWdlQnVpbGRlcih0aGlzLl9pbnRlcm5hbFBhY2thZ2VTaXplKTtcbiAgICAgICAgYnVpbGRlci5hZGRTaG9ydCh0aGlzLnRpY2tEdXJhdGlvbik7XG4gICAgICAgIGJ1aWxkZXIuYWRkU2hvcnQodGhpcy5lcG9jaCk7XG4gICAgICAgIGJ1aWxkZXIuYWRkSW50KHRoaXMudGljayk7XG4gICAgICAgIGJ1aWxkZXIuYWRkU2hvcnQodGhpcy5udW1iZXJPZkFsaWduZWRWb3Rlcyk7XG4gICAgICAgIGJ1aWxkZXIuYWRkU2hvcnQodGhpcy5udW1iZXJPZk1pc2FsaWduZWRWb3Rlcyk7XG4gICAgICAgIGJ1aWxkZXIuYWRkSW50KHRoaXMuaW5pdGlhbFRpY2spO1xuICAgICAgICByZXR1cm4gYnVpbGRlci5nZXREYXRhKCk7XG4gICAgfVxufVxuZXhwb3J0cy5RdWJpY1RpY2tJbmZvID0gUXViaWNUaWNrSW5mbztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5RdWJpY1RyYW5zYWN0aW9uID0gdm9pZCAwO1xuY29uc3QgcXViaWNIZWxwZXJfMSA9IHJlcXVpcmUoXCIuLi9xdWJpY0hlbHBlclwiKTtcbmNvbnN0IER5bmFtaWNQYXlsb2FkXzEgPSByZXF1aXJlKFwiLi9EeW5hbWljUGF5bG9hZFwiKTtcbmNvbnN0IExvbmdfMSA9IHJlcXVpcmUoXCIuL0xvbmdcIik7XG5jb25zdCBRdWJpY1BhY2thZ2VCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi4vUXViaWNQYWNrYWdlQnVpbGRlclwiKTtcbmNvbnN0IFB1YmxpY0tleV8xID0gcmVxdWlyZShcIi4vUHVibGljS2V5XCIpO1xuY29uc3QgUXViaWNEZWZpbml0aW9uc18xID0gcmVxdWlyZShcIi4uL1F1YmljRGVmaW5pdGlvbnNcIik7XG5jb25zdCBTaWduYXR1cmVfMSA9IHJlcXVpcmUoXCIuL1NpZ25hdHVyZVwiKTtcbi8qKlxuICogQytTIFN0cnVjdFxuICogdHlwZWRlZiBzdHJ1Y3RcbiAqIHtcbiAqICB1bnNpZ25lZCBjaGFyIHNvdXJjZVB1YmxpY0tleVszMl07XG4gKiAgdW5zaWduZWQgY2hhciBkZXN0aW5hdGlvblB1YmxpY0tleVszMl07XG4gKiAgbG9uZyBsb25nIGFtb3VudDtcbiAqICB1bnNpZ25lZCBpbnQgdGljaztcbiAqICB1bnNpZ25lZCBzaG9ydCBpbnB1dFR5cGU7XG4gKiAgdW5zaWduZWQgc2hvcnQgaW5wdXRTaXplO1xuICogfSBUcmFuc2FjdGlvbjtcbiAqL1xuY2xhc3MgUXViaWNUcmFuc2FjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIHRvZG86IGNyZWF0ZSBnZXR0ZXIvc2V0dGVyXG4gICAgICAgIHRoaXMuc291cmNlUHVibGljS2V5ID0gbmV3IFB1YmxpY0tleV8xLlB1YmxpY0tleSgpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uUHVibGljS2V5ID0gbmV3IFB1YmxpY0tleV8xLlB1YmxpY0tleSgpO1xuICAgICAgICB0aGlzLmFtb3VudCA9IG5ldyBMb25nXzEuTG9uZygpO1xuICAgICAgICB0aGlzLnRpY2sgPSAwO1xuICAgICAgICB0aGlzLmlucHV0VHlwZSA9IDA7XG4gICAgICAgIHRoaXMuaW5wdXRTaXplID0gMDtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gbmV3IER5bmFtaWNQYXlsb2FkXzEuRHluYW1pY1BheWxvYWQoUXViaWNEZWZpbml0aW9uc18xLlF1YmljRGVmaW5pdGlvbnMuTUFYX1RSQU5TQUNUSU9OX1NJWkUpO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmVfMS5TaWduYXR1cmUoKTtcbiAgICB9XG4gICAgc2V0U291cmNlUHVibGljS2V5KHApIHtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQdWJsaWNLZXlfMS5QdWJsaWNLZXkpXG4gICAgICAgICAgICB0aGlzLnNvdXJjZVB1YmxpY0tleSA9IHA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuc291cmNlUHVibGljS2V5ID0gbmV3IFB1YmxpY0tleV8xLlB1YmxpY0tleShwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldERlc3RpbmF0aW9uUHVibGljS2V5KHApIHtcbiAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQdWJsaWNLZXlfMS5QdWJsaWNLZXkpXG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uUHVibGljS2V5ID0gcDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvblB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXlfMS5QdWJsaWNLZXkocCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRBbW91bnQocCkge1xuICAgICAgICBpZiAocCBpbnN0YW5jZW9mIExvbmdfMS5Mb25nKVxuICAgICAgICAgICAgdGhpcy5hbW91bnQgPSBwO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmFtb3VudCA9IG5ldyBMb25nXzEuTG9uZyhwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldFRpY2socCkge1xuICAgICAgICB0aGlzLnRpY2sgPSBwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0SW5wdXRUeXBlKHApIHtcbiAgICAgICAgdGhpcy5pbnB1dFR5cGUgPSBwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0SW5wdXRTaXplKHApIHtcbiAgICAgICAgdGhpcy5pbnB1dFNpemUgPSBwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0UGF5bG9hZChwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgIHRoaXMuaW5wdXRTaXplID0gdGhpcy5wYXlsb2FkLmdldFBhY2thZ2VTaXplKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRQYXlsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXlsb2FkO1xuICAgIH1cbiAgICBfaW50ZXJuYWxTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VQdWJsaWNLZXkuZ2V0UGFja2FnZVNpemUoKVxuICAgICAgICAgICAgKyB0aGlzLmRlc3RpbmF0aW9uUHVibGljS2V5LmdldFBhY2thZ2VTaXplKClcbiAgICAgICAgICAgICsgdGhpcy5hbW91bnQuZ2V0UGFja2FnZVNpemUoKVxuICAgICAgICAgICAgKyA0IC8vIHRpY2tcbiAgICAgICAgICAgICsgMiAvLyBpbnB1dFR5cGVcbiAgICAgICAgICAgICsgMiAvLyBpbnB1dFNpemVcbiAgICAgICAgICAgICsgdGhpcy5pbnB1dFNpemVcbiAgICAgICAgICAgICsgdGhpcy5zaWduYXR1cmUuZ2V0UGFja2FnZVNpemUoKTtcbiAgICB9XG4gICAgZ2V0UGFja2FnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFNpemUoKTtcbiAgICB9XG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNBTEwgYnVpbGQoKSBCRUZPUkUgVVNJTkcgZ2V0SWQoKSBNRVRIT0RcIik7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYnVpbGRzIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBzZW50XG4gICAgICogaW5jbHVkZXMgc2lnbmluZyB3aXRoIHNlZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWVkIHRoZSBzZWVkIHRvIGJlIHVzZWQgdG8gc2lnbiB0aGlzIHRyYW5zYWNpb24uIHRoZSBzZWVkIHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGUgc291cmNlUHVibGljS2V5XG4gICAgICogQHJldHVybnMgYSBjb21wbGV0ZSB0cmFuc2FjdGlvbiBwYWNrYWdlXG4gICAgICovXG4gICAgYXN5bmMgYnVpbGQoc2VlZCkge1xuICAgICAgICB0aGlzLmJ1aWx0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGJ1aWxkZXIgPSBuZXcgUXViaWNQYWNrYWdlQnVpbGRlcl8xLlF1YmljUGFja2FnZUJ1aWxkZXIodGhpcy5faW50ZXJuYWxTaXplKCkpO1xuICAgICAgICBidWlsZGVyLmFkZCh0aGlzLnNvdXJjZVB1YmxpY0tleSk7XG4gICAgICAgIGJ1aWxkZXIuYWRkKHRoaXMuZGVzdGluYXRpb25QdWJsaWNLZXkpO1xuICAgICAgICBidWlsZGVyLmFkZCh0aGlzLmFtb3VudCk7XG4gICAgICAgIGJ1aWxkZXIuYWRkSW50KHRoaXMudGljayk7XG4gICAgICAgIGJ1aWxkZXIuYWRkU2hvcnQodGhpcy5pbnB1dFR5cGUpO1xuICAgICAgICBidWlsZGVyLmFkZFNob3J0KHRoaXMuaW5wdXRTaXplKTtcbiAgICAgICAgYnVpbGRlci5hZGQodGhpcy5wYXlsb2FkKTtcbiAgICAgICAgY29uc3QgeyBzaWduZWREYXRhLCBkaWdlc3QsIHNpZ25hdHVyZSB9ID0gYXdhaXQgYnVpbGRlci5zaWduQW5kRGlnZXN0KHNlZWQpO1xuICAgICAgICB0aGlzLmJ1aWx0RGF0YSA9IHNpZ25lZERhdGE7XG4gICAgICAgIHRoaXMuZGlnZXN0ID0gZGlnZXN0O1xuICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IG5ldyBTaWduYXR1cmVfMS5TaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgdGhpcy5pZCA9IGF3YWl0IG5ldyBxdWJpY0hlbHBlcl8xLlF1YmljSGVscGVyKCkuZ2V0SHVtYW5SZWFkYWJsZUJ5dGVzKGRpZ2VzdCk7XG4gICAgICAgIHJldHVybiBzaWduZWREYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdWx0IG9mIGJ1aWxkKCkgbXVzdCBiZSBwYXNzZWQgdGhyb3VnaCB0aGlzIGZ1bmN0aW9uLFxuICAgICAqIGFzIHRoZSBgYnJvYWRjYXN0LXRyYW5zYWN0aW9uYCBlbmRwb2ludCBleHBlY3RzIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBCYXNlNjQgZW5jb2RlZC5cbiAgICAgKi9cbiAgICBlbmNvZGVUcmFuc2FjdGlvblRvQmFzZTY0KHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KHRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3Qgc3RyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlQXJyYXkpO1xuICAgICAgICByZXR1cm4gYnRvYShzdHIpO1xuICAgIH1cbiAgICBnZXRQYWNrYWdlRGF0YSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1aWx0RGF0YSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNBTEwgYnVpbGQoKSBCRUZPUkUgVVNJTkcgZ2V0UGFja2FnZURhdGEoKSBNRVRIT0RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbHREYXRhID8/IG5ldyBVaW50OEFycmF5KCk7XG4gICAgfVxufVxuZXhwb3J0cy5RdWJpY1RyYW5zYWN0aW9uID0gUXViaWNUcmFuc2FjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaWduYXR1cmUgPSB2b2lkIDA7XG5jb25zdCBRdWJpY0RlZmluaXRpb25zXzEgPSByZXF1aXJlKFwiLi4vUXViaWNEZWZpbml0aW9uc1wiKTtcbmNsYXNzIFNpZ25hdHVyZSB7XG4gICAgY29uc3RydWN0b3IoZGF0YSA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoUXViaWNEZWZpbml0aW9uc18xLlF1YmljRGVmaW5pdGlvbnMuU0lHTkFUVVJFX0xFTkdUSCkuZmlsbCgwKTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2lnbmF0dXJlKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFNpZ25hdHVyZShieXRlcykge1xuICAgICAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgfVxuICAgIGdldFBhY2thZ2VEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcztcbiAgICB9XG4gICAgZ2V0UGFja2FnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLmxlbmd0aDtcbiAgICB9XG59XG5leHBvcnRzLlNpZ25hdHVyZSA9IFNpZ25hdHVyZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5RdWJpY1RyYW5zZmVyQXNzZXRQYXlsb2FkID0gdm9pZCAwO1xuY29uc3QgUXViaWNQYWNrYWdlQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uLy4uL1F1YmljUGFja2FnZUJ1aWxkZXJcIik7XG5jb25zdCBEeW5hbWljUGF5bG9hZF8xID0gcmVxdWlyZShcIi4uL0R5bmFtaWNQYXlsb2FkXCIpO1xuY29uc3QgTG9uZ18xID0gcmVxdWlyZShcIi4uL0xvbmdcIik7XG5jb25zdCBQdWJsaWNLZXlfMSA9IHJlcXVpcmUoXCIuLi9QdWJsaWNLZXlcIik7XG5jb25zdCBxdWJpY0hlbHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL3F1YmljSGVscGVyXCIpO1xuLyoqXG4gKlxuICogVHJhbnNhY3Rpb24gUGF5bG9hZCB0byB0cmFuc2ZlciBhbiBBc3NldFxuICpcbiAqIHR5cGVkZWYgc3RydWN0XG4qIHtcbiogICAgIHVpbnQ4X3QgaXNzdWVyWzMyXTtcbiogICAgIHVpbnQ4X3QgbmV3T3duZXJBbmRQb3NzZXNzb3JbMzJdO1xuKiAgICAgdW5zaWduZWQgbG9uZyBsb25nIGFzc2V0TmFtZTtcbiogICAgIGxvbmcgbG9uZyBudW1iZXJPZlVuaXRzO1xuKiB9IFRyYW5zZmVyQXNzZXRPd25lcnNoaXBBbmRQb3NzZXNzaW9uX2lucHV0O1xuICpcbiAqXG4gKlxuICovXG5jbGFzcyBRdWJpY1RyYW5zZmVyQXNzZXRQYXlsb2FkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxQYWNrYWdlU2l6ZSA9IDMyICsgMzIgKyA4ICsgODtcbiAgICB9XG4gICAgLy8gdG9kbzogdGhpbmsgYWJvdXQgYWRkaW5nIGdldHRlcnNcbiAgICBzZXRJc3N1ZXIoaXNzdWVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXNzdWVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLmlzc3VlciA9IG5ldyBQdWJsaWNLZXlfMS5QdWJsaWNLZXkoaXNzdWVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVyID0gaXNzdWVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXROZXdPd25lckFuZFBvc3Nlc3NvcihuZXdPd25lckFuZFBvc3Nlc3Nvcikge1xuICAgICAgICBpZiAodHlwZW9mIG5ld093bmVyQW5kUG9zc2Vzc29yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLm5ld093bmVyQW5kUG9zc2Vzc29yID0gbmV3IFB1YmxpY0tleV8xLlB1YmxpY0tleShuZXdPd25lckFuZFBvc3Nlc3Nvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5ld093bmVyQW5kUG9zc2Vzc29yID0gbmV3T3duZXJBbmRQb3NzZXNzb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldEFzc2V0TmFtZShhc3NldE5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhc3NldE5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHV0ZjhFbmNvZGUgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVCeXRlcyA9IHV0ZjhFbmNvZGUuZW5jb2RlKGFzc2V0TmFtZSk7XG4gICAgICAgICAgICB0aGlzLmFzc2V0TmFtZSA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgICAgICAgICAgbmFtZUJ5dGVzLmZvckVhY2goKGIsIGkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2V0TmFtZVtpXSA9IGI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXROYW1lID0gYXNzZXROYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRBc3NldE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2V0TmFtZTtcbiAgICB9XG4gICAgZ2V0SXNzdWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXI7XG4gICAgfVxuICAgIGdldE5ld093bmVyQW5kUG9zc2Vzc29yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdPd25lckFuZFBvc3Nlc3NvcjtcbiAgICB9XG4gICAgZ2V0TnVtYmVyT2ZVbml0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtYmVyT2ZVbml0cztcbiAgICB9XG4gICAgc2V0TnVtYmVyT2ZVbml0cyhudW1iZXJPZlVuaXRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtYmVyT2ZVbml0cyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy5udW1iZXJPZlVuaXRzID0gbmV3IExvbmdfMS5Mb25nKG51bWJlck9mVW5pdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5udW1iZXJPZlVuaXRzID0gbnVtYmVyT2ZVbml0cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0UGFja2FnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFBhY2thZ2VTaXplO1xuICAgIH1cbiAgICBnZXRQYWNrYWdlRGF0YSgpIHtcbiAgICAgICAgY29uc3QgYnVpbGRlciA9IG5ldyBRdWJpY1BhY2thZ2VCdWlsZGVyXzEuUXViaWNQYWNrYWdlQnVpbGRlcih0aGlzLmdldFBhY2thZ2VTaXplKCkpO1xuICAgICAgICBidWlsZGVyLmFkZCh0aGlzLmlzc3Vlcik7XG4gICAgICAgIGJ1aWxkZXIuYWRkKHRoaXMubmV3T3duZXJBbmRQb3NzZXNzb3IpO1xuICAgICAgICBidWlsZGVyLmFkZFJhdyh0aGlzLmFzc2V0TmFtZSk7XG4gICAgICAgIGJ1aWxkZXIuYWRkKHRoaXMubnVtYmVyT2ZVbml0cyk7XG4gICAgICAgIHJldHVybiBidWlsZGVyLmdldERhdGEoKTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb25QYXlsb2FkKCkge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gbmV3IER5bmFtaWNQYXlsb2FkXzEuRHluYW1pY1BheWxvYWQodGhpcy5nZXRQYWNrYWdlU2l6ZSgpKTtcbiAgICAgICAgcGF5bG9hZC5zZXRQYXlsb2FkKHRoaXMuZ2V0UGFja2FnZURhdGEoKSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZShkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5faW50ZXJuYWxQYWNrYWdlU2l6ZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIklOVkFMSUQgUEFDS0FHRSBTSVpFXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWxwZXIgPSBuZXcgcXViaWNIZWxwZXJfMS5RdWJpY0hlbHBlcigpO1xuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgZW5kID0gMzI7IC8vIHNpemUgZm9yIGlzc3VlciBhbmQgbmV3T3duZXJBbmRQb3NzZXNzb3JcbiAgICAgICAgdGhpcy5pc3N1ZXIgPSBuZXcgUHVibGljS2V5XzEuUHVibGljS2V5KGF3YWl0IGhlbHBlci5nZXRJZGVudGl0eShkYXRhLnNsaWNlKHN0YXJ0LCBlbmQpKSk7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICBlbmQgPSBzdGFydCArIDMyOyAvLyBzaXplIGZvciBuZXdPd25lckFuZFBvc3Nlc3NvclxuICAgICAgICB0aGlzLm5ld093bmVyQW5kUG9zc2Vzc29yID0gbmV3IFB1YmxpY0tleV8xLlB1YmxpY0tleShhd2FpdCBoZWxwZXIuZ2V0SWRlbnRpdHkoZGF0YS5zbGljZShzdGFydCwgZW5kKSkpO1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgZW5kID0gc3RhcnQgKyA4OyAvLyBzaXplIGZvciBhc3NldCBuYW1lXG4gICAgICAgIHRoaXMuYXNzZXROYW1lID0gZGF0YS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgbGV0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTsgLy8gQ3JlYXRlIGEgVGV4dERlY29kZXIgZm9yIFVURi04IGJ5IGRlZmF1bHRcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVjb2Rlci5kZWNvZGUodGhpcy5hc3NldE5hbWUpOyAvLyBDb252ZXJ0IFVpbnQ4QXJyYXkgdG8gc3RyaW5nXG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICBlbmQgPSBzdGFydCArIDg7IC8vIHNpemUgZm9yIG51bWJlciBvZiB1bml0c1xuICAgICAgICB0aGlzLm51bWJlck9mVW5pdHMgPSBuZXcgTG9uZ18xLkxvbmcoZGF0YS5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuUXViaWNUcmFuc2ZlckFzc2V0UGF5bG9hZCA9IFF1YmljVHJhbnNmZXJBc3NldFBheWxvYWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXViaWNUcmFuc2ZlclNlbmRNYW55UGF5bG9hZCA9IHZvaWQgMDtcbmNvbnN0IFF1YmljRGVmaW5pdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi8uLi9RdWJpY0RlZmluaXRpb25zXCIpO1xuY29uc3QgUXViaWNQYWNrYWdlQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uLy4uL1F1YmljUGFja2FnZUJ1aWxkZXJcIik7XG5jb25zdCBxdWJpY0hlbHBlcl8xID0gcmVxdWlyZShcIi4uLy4uL3F1YmljSGVscGVyXCIpO1xuY29uc3QgRHluYW1pY1BheWxvYWRfMSA9IHJlcXVpcmUoXCIuLi9EeW5hbWljUGF5bG9hZFwiKTtcbmNvbnN0IExvbmdfMSA9IHJlcXVpcmUoXCIuLi9Mb25nXCIpO1xuY29uc3QgUHVibGljS2V5XzEgPSByZXF1aXJlKFwiLi4vUHVibGljS2V5XCIpO1xuLyoqXG4gKlxuICogVHJhbnNhY3Rpb24gUGF5bG9hZCB0byB1c2UgUXV0aWwvU2VuZE1hbnkgU0NcbiAqXG4gKiBzdHJ1Y3QgU2VuZFRvTWFueVYxX2lucHV0IHtcbiAqICAgdWludDhfdCBhZGRyZXNzZXNbMjVdWzMyXTtcbiAqICAgaW50NjRfdCBhbW91bnRzWzI1XTtcbiAqIH07XG4gKlxuICpcbiAqXG4gKi9cbmNsYXNzIFF1YmljVHJhbnNmZXJTZW5kTWFueVBheWxvYWQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9pbnRlcm5hbFBhY2thZ2VTaXplID0gMTAwMDsgLyogMjUgKiAzMiAgKyAyNSAqIDggKi9cbiAgICAgICAgLy8gbWF4IDI1IHRyYW5zZmVycyBhbGxvd2VkXG4gICAgICAgIHRoaXMuc2VuZE1hbnlUcmFuc2ZlcnMgPSBbXTtcbiAgICB9XG4gICAgYWRkVHJhbnNmZXIodHJhbnNmZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VuZE1hbnlUcmFuc2ZlcnMubGVuZ3RoIDwgMjUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1hbnlUcmFuc2ZlcnMucHVzaCh0cmFuc2Zlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXggMjUgc2VuZCBtYW55IHRyYW5zZmVycyBhbGxvd2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRUcmFuZmVycyh0cmFuc2ZlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VuZE1hbnlUcmFuc2ZlcnMubGVuZ3RoICsgdHJhbnNmZXJzLmxlbmd0aCA+IDI1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYXggMjUgc2VuZCBtYW55IHRyYW5zZmVycyBhbGxvd2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zZmVycy5mb3JFYWNoKCh0cmFuc2ZlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRUcmFuc2Zlcih0cmFuc2Zlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgdHJhbnNmZXJzIGZvciB0aGlzIHNlbmQgbWFueSByZXF1ZXN0XG4gICAgICovXG4gICAgZ2V0VHJhbnNmZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kTWFueVRyYW5zZmVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGhlIGFjdW11bGF0ZWQgYW1vdW50IG9mIGFsbCB0cmFuc2ZlcnNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqXG4gICAgICovXG4gICAgZ2V0VG90YWxBbW91bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmRNYW55VHJhbnNmZXJzLnJlZHVjZSgoYSwgYikgPT4gKGEgKz0gYiAmJiBiLmFtb3VudCA/IGIuYW1vdW50LmdldE51bWJlcigpIDogQmlnSW50KDApKSwgQmlnSW50KDApKTtcbiAgICB9XG4gICAgZ2V0UGFja2FnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFBhY2thZ2VTaXplO1xuICAgIH1cbiAgICBnZXRQYWNrYWdlRGF0YSgpIHtcbiAgICAgICAgY29uc3QgYnVpbGRlciA9IG5ldyBRdWJpY1BhY2thZ2VCdWlsZGVyXzEuUXViaWNQYWNrYWdlQnVpbGRlcih0aGlzLmdldFBhY2thZ2VTaXplKCkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbmRNYW55VHJhbnNmZXJzLmxlbmd0aCA+IGkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRNYW55VHJhbnNmZXJzW2ldLmFtb3VudC5nZXROdW1iZXIoKSA+IDApIHtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZCh0aGlzLnNlbmRNYW55VHJhbnNmZXJzW2ldLmRlc3RJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChuZXcgUHVibGljS2V5XzEuUHVibGljS2V5KFF1YmljRGVmaW5pdGlvbnNfMS5RdWJpY0RlZmluaXRpb25zLkVNUFRZX0FERFJFU1MpKTsgLy8gYWRkIGVtcHR5IGFkZHJlc3MgdG8gaGF2ZSAwIGluIGJ5dGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1OyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbmRNYW55VHJhbnNmZXJzLmxlbmd0aCA+IGkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRNYW55VHJhbnNmZXJzW2ldLmFtb3VudC5nZXROdW1iZXIoKSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbW91bnQgPSB0aGlzLnNlbmRNYW55VHJhbnNmZXJzW2ldLmFtb3VudDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFtb3VudCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChuZXcgTG9uZ18xLkxvbmcoYW1vdW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChhbW91bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKG5ldyBMb25nXzEuTG9uZygwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZ2V0RGF0YSgpO1xuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvblBheWxvYWQoKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBuZXcgRHluYW1pY1BheWxvYWRfMS5EeW5hbWljUGF5bG9hZCh0aGlzLmdldFBhY2thZ2VTaXplKCkpO1xuICAgICAgICBwYXlsb2FkLnNldFBheWxvYWQodGhpcy5nZXRQYWNrYWdlRGF0YSgpKTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHBhcnNlcyByYXcgYmluYXJ5IHBhY2thZ2UgdG8ganMgb2JqZWN0XG4gICAgICogQHBhcmFtIGRhdGEgcmF3IHNlbmQgbWFueSBpbnB1dCAocGF5bG9hZClcbiAgICAgKiBAcmV0dXJucyBRdWJpY1RyYW5zZmVyU2VuZE1hbnlQYXlsb2FkXG4gICAgICovXG4gICAgYXN5bmMgcGFyc2UoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IHRoaXMuX2ludGVybmFsUGFja2FnZVNpemUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJTlZBTElEIFBBQ0tBR0UgU0laRVwiKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVscGVyID0gbmV3IHF1YmljSGVscGVyXzEuUXViaWNIZWxwZXIoKTtcbiAgICAgICAgY29uc3Qgc2VuZE1hbnlUcmFuc2ZlcnMgPSBbXTtcbiAgICAgICAgLy8gYSBzZW5kIG1hbnkgdHggY2FuIGhhdmUgbWF4aW11bSAyNSByZWNpcGllbnRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU7IGkrKykge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSBhbW91bnQgZm9yIHRoZSB0cmFuc2ZlclxuICAgICAgICAgICAgY29uc3QgYW1vdW50ID0gbmV3IExvbmdfMS5Mb25nKGRhdGEuc2xpY2UoODAwICsgaSAqIDgsIDgwMCArIGkgKiA4ICsgOCkpO1xuICAgICAgICAgICAgLy8gb25seSBhZGQgdHJhbnNmZXIgdG8gb3V0cHV0IGFycmF5IGlmIGFtb3VudCA+IDA7IDAgb3IgbG93ZXIgbWVhbnMsIG5vIHRyYW5zZmVyXG4gICAgICAgICAgICBpZiAoYW1vdW50LmdldE51bWJlcigpID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc3QgPSBkYXRhLnNsaWNlKDMyICogaSwgMzIgKiBpICsgMzIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZE1hbnlUcmFuc2ZlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGFtb3VudDogYW1vdW50LFxuICAgICAgICAgICAgICAgICAgICBkZXN0SWQ6IG5ldyBQdWJsaWNLZXlfMS5QdWJsaWNLZXkoYXdhaXQgaGVscGVyLmdldElkZW50aXR5KGRlc3QpKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFRyYW5mZXJzKHNlbmRNYW55VHJhbnNmZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5RdWJpY1RyYW5zZmVyU2VuZE1hbnlQYXlsb2FkID0gUXViaWNUcmFuc2ZlclNlbmRNYW55UGF5bG9hZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuLypcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgcGVycGV0dWFsLCB3b3JsZHdpZGUsIG5vbi1leGNsdXNpdmUsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbnRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG5hbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuXG4gIDEuIFRoZSBTb2Z0d2FyZSBjYW5ub3QgYmUgdXNlZCBpbiBhbnkgZm9ybSBvciBpbiBhbnkgc3Vic3RhbnRpYWwgcG9ydGlvbnMgZm9yIGRldmVsb3BtZW50LCBtYWludGVuYW5jZSBhbmQgZm9yIGFueSBvdGhlciBwdXJwb3NlcywgaW4gdGhlIG1pbGl0YXJ5IHNwaGVyZSBhbmQgaW4gcmVsYXRpb24gdG8gbWlsaXRhcnkgcHJvZHVjdHMsXG4gIGluY2x1ZGluZywgYnV0IG5vdCBsaW1pdGVkIHRvOlxuXG4gICAgYS4gYW55IGtpbmQgb2YgYXJtb3JlZCBmb3JjZSB2ZWhpY2xlcywgbWlzc2lsZSB3ZWFwb25zLCB3YXJzaGlwcywgYXJ0aWxsZXJ5IHdlYXBvbnMsIGFpciBtaWxpdGFyeSB2ZWhpY2xlcyAoaW5jbHVkaW5nIG1pbGl0YXJ5IGFpcmNyYWZ0cywgY29tYmF0IGhlbGljb3B0ZXJzLCBtaWxpdGFyeSBkcm9uZXMgYWlyY3JhZnRzKSxcbiAgICBhaXIgZGVmZW5zZSBzeXN0ZW1zLCByaWZsZSBhcm1hbWVudHMsIHNtYWxsIGFybXMsIGZpcmVhcm1zIGFuZCBzaWRlIGFybXMsIG1lbGVlIHdlYXBvbnMsIGNoZW1pY2FsIHdlYXBvbnMsIHdlYXBvbnMgb2YgbWFzcyBkZXN0cnVjdGlvbjtcblxuICAgIGIuIGFueSBzcGVjaWFsIHNvZnR3YXJlIGZvciBkZXZlbG9wbWVudCB0ZWNobmljYWwgZG9jdW1lbnRhdGlvbiBmb3IgbWlsaXRhcnkgcHVycG9zZXM7XG5cbiAgICBjLiBhbnkgc3BlY2lhbCBlcXVpcG1lbnQgZm9yIHRlc3RzIG9mIHByb3RvdHlwZXMgb2YgYW55IHN1YmplY3RzIHdpdGggbWlsaXRhcnkgcHVycG9zZSBvZiB1c2U7XG5cbiAgICBkLiBhbnkgbWVhbnMgb2YgcHJvdGVjdGlvbiBmb3IgY29uZHVjdGlvbiBvZiBhY3RzIG9mIGEgbWlsaXRhcnkgbmF0dXJlO1xuXG4gICAgZS4gYW55IHNvZnR3YXJlIG9yIGhhcmR3YXJlIGZvciBkZXRlcm1pbmluZyBzdHJhdGVnaWVzLCByZWNvbm5haXNzYW5jZSwgdHJvb3AgcG9zaXRpb25pbmcsIGNvbmR1Y3RpbmcgbWlsaXRhcnkgYWN0aW9ucywgY29uZHVjdGluZyBzcGVjaWFsIG9wZXJhdGlvbnM7XG5cbiAgICBmLiBhbnkgZHVhbC11c2UgcHJvZHVjdHMgd2l0aCBwb3NzaWJpbGl0eSB0byB1c2UgdGhlIHByb2R1Y3QgaW4gbWlsaXRhcnkgcHVycG9zZXM7XG5cbiAgICBnLiBhbnkgb3RoZXIgcHJvZHVjdHMsIHNvZnR3YXJlIG9yIHNlcnZpY2VzIGNvbm5lY3RlZCB0byBtaWxpdGFyeSBhY3Rpdml0aWVzO1xuXG4gICAgaC4gYW55IGF1eGlsaWFyeSBtZWFucyByZWxhdGVkIHRvIGFib3ZlbWVudGlvbmVkIHNwaGVyZXMgYW5kIHByb2R1Y3RzLlxuXG5cbiAgMi4gVGhlIFNvZnR3YXJlIGNhbm5vdCBiZSB1c2VkIGFzIGRlc2NyaWJlZCBoZXJlaW4gaW4gYW55IGNvbm5lY3Rpb24gdG8gdGhlIG1pbGl0YXJ5IGFjdGl2aXRpZXMuIEEgcGVyc29uLCBhIGNvbXBhbnksIG9yIGFueSBvdGhlciBlbnRpdHksIHdoaWNoIHdhbnRzIHRvIHVzZSB0aGUgU29mdHdhcmUsXG4gIHNoYWxsIHRha2UgYWxsIHJlYXNvbmFibGUgYWN0aW9ucyB0byBtYWtlIHN1cmUgdGhhdCB0aGUgcHVycG9zZSBvZiB1c2Ugb2YgdGhlIFNvZnR3YXJlIGNhbm5vdCBiZSBwb3NzaWJseSBjb25uZWN0ZWQgdG8gbWlsaXRhcnkgcHVycG9zZXMuXG5cblxuICAzLiBUaGUgU29mdHdhcmUgY2Fubm90IGJlIHVzZWQgYnkgYSBwZXJzb24sIGEgY29tcGFueSwgb3IgYW55IG90aGVyIGVudGl0eSwgYWN0aXZpdGllcyBvZiB3aGljaCBhcmUgY29ubmVjdGVkIHRvIG1pbGl0YXJ5IHNwaGVyZSBpbiBhbnkgbWVhbnMuIElmIGEgcGVyc29uLCBhIGNvbXBhbnksIG9yIGFueSBvdGhlciBlbnRpdHksXG4gIGR1cmluZyB0aGUgcGVyaW9kIG9mIHRpbWUgZm9yIHRoZSB1c2FnZSBvZiBTb2Z0d2FyZSwgd291bGQgZW5nYWdlIGluIGFjdGl2aXRpZXMsIGNvbm5lY3RlZCB0byBtaWxpdGFyeSBwdXJwb3Nlcywgc3VjaCBwZXJzb24sIGNvbXBhbnksIG9yIGFueSBvdGhlciBlbnRpdHkgc2hhbGwgaW1tZWRpYXRlbHkgc3RvcCB0aGUgdXNhZ2VcbiAgb2YgU29mdHdhcmUgYW5kIGFueSBpdHMgbW9kaWZpY2F0aW9ucyBvciBhbHRlcmF0aW9ucy5cblxuXG4gIDQuIEFib3ZlbWVudGlvbmVkIHJlc3RyaWN0aW9ucyBzaG91bGQgYXBwbHkgdG8gYWxsIG1vZGlmaWNhdGlvbiwgYWx0ZXJhdGlvbiwgbWVyZ2UsIGFuZCB0byBvdGhlciBhY3Rpb25zLCByZWxhdGVkIHRvIHRoZSBTb2Z0d2FyZSwgcmVnYXJkbGVzcyBvZiBob3cgdGhlIFNvZnR3YXJlIHdhcyBjaGFuZ2VkIGR1ZSB0byB0aGVcbiAgYWJvdmVtZW50aW9uZWQgYWN0aW9ucy5cblxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zLCBtb2RpZmljYXRpb25zIGFuZCBhbHRlcmF0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbklOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEhcblRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXViaWNIZWxwZXIgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jcnlwdG9cIikpO1xuY29uc3QgY29udmVydGVyX2pzXzEgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXIvY29udmVydGVyLmpzXCIpO1xuY29uc3QgYmlnbnVtYmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJpZ251bWJlci5qc1wiKSk7XG5jb25zdCBRdWJpY0RlZmluaXRpb25zXzEgPSByZXF1aXJlKFwiLi9RdWJpY0RlZmluaXRpb25zXCIpO1xuLy8gdG9kbzogcmVmYWN0b3Jcbi8qKlxuICogdGhpcyBjbGFzcyBjb250YWlucyBhIGxvdCBvZiBsZWdhY3kgY29kZSBhbmQgc2hvdWxkIGJlIHJlZmFjdG9yZWRcbiAqL1xuY2xhc3MgUXViaWNIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLlNFRURfQUxQSEFCRVQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xuICAgICAgICB0aGlzLlNISUZURURfSEVYX0NIQVJTID0gJ2FiY2RlZmdoaWprbG1ub3AnO1xuICAgICAgICB0aGlzLlBSSVZBVEVfS0VZX0xFTkdUSCA9IDMyO1xuICAgICAgICB0aGlzLlBVQkxJQ19LRVlfTEVOR1RIID0gMzI7XG4gICAgICAgIHRoaXMuU0VFRF9JTl9MT1dFUkNBU0VfTEFUSU5fTEVOR1RIID0gNTU7XG4gICAgICAgIHRoaXMuQ0hFQ0tTVU1fTEVOR1RIID0gMztcbiAgICAgICAgdGhpcy5nZXRJZGVudGl0eUJ5dGVzID0gZnVuY3Rpb24gKGlkZW50aXR5KSB7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXlCeXRlcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcocHVibGljS2V5Qnl0ZXMuYnVmZmVyLCAwKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRCaWdVaW50NjQoaSAqIDgsIDBuLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMTQ7IGotLSA+IDA7KSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuc2V0QmlnVWludDY0KGkgKiA4LCB2aWV3LmdldEJpZ1VpbnQ2NChpICogOCwgdHJ1ZSkgKiAyNm4gKyBCaWdJbnQoaWRlbnRpdHkuY2hhckNvZGVBdChpICogMTQgKyBqKSkgLSBCaWdJbnQoJ0EnLmNoYXJDb2RlQXQoMCkpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHVibGljS2V5Qnl0ZXM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuUkVRVUVTVF9SRVNQT05TRV9IRUFERVJfU0laRSA9IDg7XG4gICAgICAgIHRoaXMuVFJBTlNBQ1RJT05fU0laRSA9IDE0NDtcbiAgICAgICAgdGhpcy5JUE9fVFJBTlNBQ1RJT05fU0laRSA9IDE0NCArIDggLypwcmljZSovICsgMiAvKiBxdWFudGl0eSAqLyArIDYgLyogcGFkZGluZyAqLztcbiAgICAgICAgdGhpcy5TRVRfUFJPUE9TQUxfQU5EX0JBTExPVF9SRVFVRVNUX1NJWkUgPSA1OTI7XG4gICAgICAgIHRoaXMuVFJBTlNBQ1RJT05fSU5QVVRfU0laRV9PRkZTRVQgPSAwO1xuICAgICAgICB0aGlzLlRSQU5TQUNUSU9OX0lOUFVUX1NJWkVfTEVOR1RIID0gMDtcbiAgICAgICAgdGhpcy5TSUdOQVRVUkVfTEVOR1RIID0gNjQ7XG4gICAgICAgIHRoaXMuRElHRVNUX0xFTkdUSCA9IDMyO1xuICAgICAgICB0aGlzLlNQRUNJQUxfQ09NTUFORF9TSFVUX0RPV04gPSAwO1xuICAgICAgICB0aGlzLlNQRUNJQUxfQ09NTUFORF9HRVRfUFJPUE9TQUxfQU5EX0JBTExPVF9SRVFVRVNUID0gMTtcbiAgICAgICAgdGhpcy5TUEVDSUFMX0NPTU1BTkRfR0VUX1BST1BPU0FMX0FORF9CQUxMT1RfUkVTUE9OU0UgPSAyO1xuICAgICAgICB0aGlzLlNQRUNJQUxfQ09NTUFORF9TRVRfUFJPUE9TQUxfQU5EX0JBTExPVF9SRVFVRVNUID0gMztcbiAgICAgICAgdGhpcy5TUEVDSUFMX0NPTU1BTkRfU0VUX1BST1BPU0FMX0FORF9CQUxMT1RfUkVTUE9OU0UgPSA0O1xuICAgICAgICB0aGlzLlBST0NFU1NfU1BFQ0lBTF9DT01NQU5EID0gMjU1O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSBjb21wbGV0ZSBJRCBQYWNrYWdlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBzZWVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VlZFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlSWRQYWNrYWdlKHNlZWQpIHtcbiAgICAgICAgY29uc3QgeyBzY2hub3JycSwgSzEyIH0gPSBhd2FpdCBjcnlwdG9fMS5kZWZhdWx0O1xuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gdGhpcy5wcml2YXRlS2V5KHNlZWQsIDAsIEsxMik7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHNjaG5vcnJxLmdlbmVyYXRlUHVibGljS2V5KHByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCBwdWJsaWNJZCA9IGF3YWl0IHRoaXMuZ2V0SWRlbnRpdHkocHVibGljS2V5KTtcbiAgICAgICAgcmV0dXJuIHsgcHVibGljS2V5LCBwcml2YXRlS2V5LCBwdWJsaWNJZCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjcmVhdGVzIHRoZSBjaGVja3N1bSBmb3IgYSBnaXZlbiBrZXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwdWJsaWNLZXlcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGFzeW5jIGdldENoZWNrU3VtKHB1YmxpY0tleSkge1xuICAgICAgICBjb25zdCB7IEsxMiB9ID0gYXdhaXQgY3J5cHRvXzEuZGVmYXVsdDtcbiAgICAgICAgY29uc3QgZGlnZXN0ID0gbmV3IFVpbnQ4QXJyYXkoUXViaWNEZWZpbml0aW9uc18xLlF1YmljRGVmaW5pdGlvbnMuRElHRVNUX0xFTkdUSCk7XG4gICAgICAgIEsxMihwdWJsaWNLZXksIGRpZ2VzdCwgUXViaWNEZWZpbml0aW9uc18xLlF1YmljRGVmaW5pdGlvbnMuRElHRVNUX0xFTkdUSCk7XG4gICAgICAgIGNvbnN0IGNoZWNrc3VtID0gZGlnZXN0LnNsaWNlKDAsIHRoaXMuQ0hFQ0tTVU1fTEVOR1RIKTtcbiAgICAgICAgcmV0dXJuIGNoZWNrc3VtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgdGhlIGh1bWFuIHJlYWRhYmxlIHB1YmxpYyBrZXkgZnJvbSB0aGUgcHVibGlja2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHVibGljS2V5XG4gICAgICogQHBhcmFtIGxvd2VyQ2FzZVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgZ2V0SWRlbnRpdHkocHVibGljS2V5LCBsb3dlckNhc2UgPSBmYWxzZSkge1xuICAgICAgICBsZXQgbmV3SWQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsb25nTlVtYmVyID0gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQoMCk7XG4gICAgICAgICAgICBsb25nTlVtYmVyLmRlY2ltYWxQbGFjZXMoMCk7XG4gICAgICAgICAgICBwdWJsaWNLZXkuc2xpY2UoaSAqIDgsIChpICsgMSkgKiA4KS5mb3JFYWNoKCh2YWwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgbG9uZ05VbWJlciA9IGxvbmdOVW1iZXIucGx1cyhuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdCgodmFsICogMjU2ICoqIGluZGV4KS50b1N0cmluZygyKSwgMikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE0OyBqKyspIHtcbiAgICAgICAgICAgICAgICBuZXdJZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxvbmdOVW1iZXIubW9kKDI2KS5wbHVzKChsb3dlckNhc2UgPyAnYScgOiAnQScpLmNoYXJDb2RlQXQoMCkpLnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgICAgIGxvbmdOVW1iZXIgPSBsb25nTlVtYmVyLmRpdigyNik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsY3VsYXRlIGNoZWNrc3VtXG4gICAgICAgIGNvbnN0IGNoZWNrc3VtID0gYXdhaXQgdGhpcy5nZXRDaGVja1N1bShwdWJsaWNLZXkpO1xuICAgICAgICAvLyBjb252ZXJ0IHRvIGludFxuICAgICAgICBsZXQgaWRlbnRpdHlCeXRlc0NoZWNrc3VtID0gKGNoZWNrc3VtWzJdIDw8IDE2KSB8IChjaGVja3N1bVsxXSA8PCA4KSB8IGNoZWNrc3VtWzBdO1xuICAgICAgICBpZGVudGl0eUJ5dGVzQ2hlY2tzdW0gPSBpZGVudGl0eUJ5dGVzQ2hlY2tzdW0gJiAweDNGRkZGO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgbmV3SWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShpZGVudGl0eUJ5dGVzQ2hlY2tzdW0gJSAyNiArIChsb3dlckNhc2UgPyAnYScgOiAnQScpLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgaWRlbnRpdHlCeXRlc0NoZWNrc3VtID0gaWRlbnRpdHlCeXRlc0NoZWNrc3VtIC8gMjY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0lkO1xuICAgIH1cbiAgICBhc3luYyBnZXRIdW1hblJlYWRhYmxlQnl0ZXMocHVibGljS2V5KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldElkZW50aXR5KHB1YmxpY0tleSwgdHJ1ZSk7XG4gICAgfVxuICAgIHNlZWRUb0J5dGVzKHNlZWQpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShzZWVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYnl0ZXNbaV0gPSB0aGlzLlNFRURfQUxQSEFCRVQuaW5kZXhPZihzZWVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIDtcbiAgICBwcml2YXRlS2V5KHNlZWQsIGluZGV4LCBLMTIpIHtcbiAgICAgICAgY29uc3QgYnl0ZVNlZWQgPSB0aGlzLnNlZWRUb0J5dGVzKHNlZWQpO1xuICAgICAgICBjb25zdCBwcmVpbWFnZSA9IGJ5dGVTZWVkLnNsaWNlKCk7XG4gICAgICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVpbWFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgrK3ByZWltYWdlW2ldID4gdGhpcy5TRUVEX0FMUEhBQkVULmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwcmVpbWFnZVtpXSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5QUklWQVRFX0tFWV9MRU5HVEgpO1xuICAgICAgICBLMTIocHJlaW1hZ2UsIGtleSwgdGhpcy5QUklWQVRFX0tFWV9MRU5HVEgpO1xuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgaWYgYSBnaXZlbiBpZGVudGl0eSBpcyB2YWxpZFxuICAgICAqIEBwYXJhbSBpZGVudGl0eVxuICAgICAqL1xuICAgIGFzeW5jIHZlcmlmeUlkZW50aXR5KGlkZW50aXR5KSB7XG4gICAgICAgIGlmICghaWRlbnRpdHkgfHwgaWRlbnRpdHkubGVuZ3RoICE9IDYwIHx8ICEvXltBLVpdKyQvLnRlc3QoaWRlbnRpdHkpKSAvLyBtdXN0IGJlIDYwIHVwcGVyIGNhc2UgY2hhcmFjdGVyc1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSB0aGlzLmdldElkZW50aXR5Qnl0ZXMoaWRlbnRpdHkpO1xuICAgICAgICBjb25zdCBpZEZyb21CeXRlcyA9IGF3YWl0IHRoaXMuZ2V0SWRlbnRpdHkocHVibGljS2V5KTtcbiAgICAgICAgLy8gdG9kbzogaXQgd291bGQgYmUgZW5vdWdoIHRvIGp1c3QgY2hlY2sgY2hlY2tzdW0gYnl0ZXMgaW5zdGVhZCBvZiBjb21wYXJlIGNvbXBsZXRlIGlkXG4gICAgICAgIHJldHVybiBpZGVudGl0eSA9PT0gaWRGcm9tQnl0ZXM7XG4gICAgfVxuICAgIGNyZWF0ZVB1YmxpY0tleShwcml2YXRlS2V5LCBzY2hub3JycSwgSzEyKSB7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleVdpdGhDaGVja3N1bSA9IG5ldyBVaW50OEFycmF5KHRoaXMuUFVCTElDX0tFWV9MRU5HVEggKyB0aGlzLkNIRUNLU1VNX0xFTkdUSCk7XG4gICAgICAgIHB1YmxpY0tleVdpdGhDaGVja3N1bS5zZXQoc2Nobm9ycnEuZ2VuZXJhdGVQdWJsaWNLZXkocHJpdmF0ZUtleSkpO1xuICAgICAgICBLMTIocHVibGljS2V5V2l0aENoZWNrc3VtLnN1YmFycmF5KDAsIHRoaXMuUFVCTElDX0tFWV9MRU5HVEgpLCBwdWJsaWNLZXlXaXRoQ2hlY2tzdW0sIHRoaXMuQ0hFQ0tTVU1fTEVOR1RILCB0aGlzLlBVQkxJQ19LRVlfTEVOR1RIKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleVdpdGhDaGVja3N1bTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlSXBvKHNvdXJjZVNlZWQsIGNvbnRyYWN0SW5kZXgsIHByaWNlLCBxdWFudGl0eSwgdGljaykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuZGVmYXVsdC50aGVuKCh7IHNjaG5vcnJxLCBLMTIgfSkgPT4ge1xuICAgICAgICAgICAgLy8gc2VuZGVyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQcml2YXRlS2V5ID0gdGhpcy5wcml2YXRlS2V5KHNvdXJjZVNlZWQsIDAsIEsxMik7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQdWJsaWNLZXkgPSB0aGlzLmNyZWF0ZVB1YmxpY0tleShzb3VyY2VQcml2YXRlS2V5LCBzY2hub3JycSwgSzEyKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5JUE9fVFJBTlNBQ1RJT05fU0laRSkuZmlsbCgwKTtcbiAgICAgICAgICAgIGNvbnN0IHR4VmlldyA9IG5ldyBEYXRhVmlldyh0eC5idWZmZXIpO1xuICAgICAgICAgICAgLy8gZmlsbCBhbGwgd2l0aCB6ZXJvXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuSVBPX1RSQU5TQUNUSU9OX1NJWkU7IGkrKykge1xuICAgICAgICAgICAgICAgIHR4W2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNvdXJjZVB1YmxpY0tleSBieXRlW10gLy8gMzJcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuUFVCTElDX0tFWV9MRU5HVEg7IGkrKykge1xuICAgICAgICAgICAgICAgIHR4W2ldID0gc291cmNlUHVibGljS2V5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gaTtcbiAgICAgICAgICAgIHR4W29mZnNldF0gPSBjb250cmFjdEluZGV4O1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgdGhpcy5QVUJMSUNfS0VZX0xFTkdUSDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHhbb2Zmc2V0ICsgaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGkgLSAxO1xuICAgICAgICAgICAgdHhWaWV3LnNldEJpZ0ludDY0KG9mZnNldCwgQmlnSW50KDApLCB0cnVlKTsgLy8gZm9yIGlwbyB0eCBhbW91biBpcyBqdXN0IDBcbiAgICAgICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICAgICAgdHhWaWV3LnNldFVpbnQzMihvZmZzZXQsIHRpY2ssIHRydWUpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB0eFZpZXcuc2V0VWludDE2KG9mZnNldCwgMSwgdHJ1ZSk7IC8vIGlucHV0VHlwZSBmb3IgSVBPIGlzIDFcbiAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICAgICAgdHhWaWV3LnNldFVpbnQxNihvZmZzZXQsIDE2LCB0cnVlKTsgLy8gaW5wdXRTaXplIGZvciBJUE8gaXMgMTZcbiAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICAgICAgLy8gYWRkIGlwbyBzcGVjaWZpeCBzdHVmZlxuICAgICAgICAgICAgLy8gcHJpY2VcbiAgICAgICAgICAgIHR4Vmlldy5zZXRCaWdJbnQ2NChvZmZzZXQsIEJpZ0ludChwcmljZSksIHRydWUpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICAvLyBxdWFudGl0eVxuICAgICAgICAgICAgdHhWaWV3LnNldEludDE2KG9mZnNldCwgcXVhbnRpdHksIHRydWUpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAvLyBwYWRkaW5nXG4gICAgICAgICAgICBvZmZzZXQgKz0gNjtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2VzdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuRElHRVNUX0xFTkdUSCk7XG4gICAgICAgICAgICBjb25zdCB0b1NpZ24gPSB0eC5zbGljZSgwLCBvZmZzZXQpO1xuICAgICAgICAgICAgSzEyKHRvU2lnbiwgZGlnZXN0LCB0aGlzLkRJR0VTVF9MRU5HVEgpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkdHggPSBzY2hub3JycS5zaWduKHNvdXJjZVByaXZhdGVLZXksIHNvdXJjZVB1YmxpY0tleSwgZGlnZXN0KTtcbiAgICAgICAgICAgIHR4LnNldChzaWduZWR0eCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLlNJR05BVFVSRV9MRU5HVEg7XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVUcmFuc2FjdGlvbihzb3VyY2VTZWVkLCBkZXN0UHVibGljSWQsIGFtb3VudCwgdGljaykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuZGVmYXVsdC50aGVuKCh7IHNjaG5vcnJxLCBLMTIgfSkgPT4ge1xuICAgICAgICAgICAgLy8gc2VuZGVyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQcml2YXRlS2V5ID0gdGhpcy5wcml2YXRlS2V5KHNvdXJjZVNlZWQsIDAsIEsxMik7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VQdWJsaWNLZXkgPSB0aGlzLmNyZWF0ZVB1YmxpY0tleShzb3VyY2VQcml2YXRlS2V5LCBzY2hub3JycSwgSzEyKTtcbiAgICAgICAgICAgIGNvbnN0IGRlc3RQdWJsaWNLZXkgPSAoMCwgY29udmVydGVyX2pzXzEucHVibGljS2V5U3RyaW5nVG9CeXRlcykoZGVzdFB1YmxpY0lkKS5zbGljZSgwLCB0aGlzLlBVQkxJQ19LRVlfTEVOR1RIKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5UUkFOU0FDVElPTl9TSVpFKS5maWxsKDApO1xuICAgICAgICAgICAgY29uc3QgdHhWaWV3ID0gbmV3IERhdGFWaWV3KHR4LmJ1ZmZlcik7XG4gICAgICAgICAgICAvLyBzb3VyY2VQdWJsaWNLZXkgYnl0ZVtdIC8vIDMyXG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLlBVQkxJQ19LRVlfTEVOR1RIOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0eFtpXSA9IHNvdXJjZVB1YmxpY0tleVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5QVUJMSUNfS0VZX0xFTkdUSDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHhbb2Zmc2V0ICsgaV0gPSBkZXN0UHVibGljS2V5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGk7XG4gICAgICAgICAgICB0eFZpZXcuc2V0QmlnSW50NjQob2Zmc2V0LCBCaWdJbnQoYW1vdW50KSwgdHJ1ZSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgICAgIHR4Vmlldy5zZXRVaW50MzIob2Zmc2V0LCB0aWNrLCB0cnVlKTtcbiAgICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICAgICAgdHhWaWV3LnNldFVpbnQxNihvZmZzZXQsIDAsIHRydWUpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICB0eFZpZXcuc2V0VWludDE2KG9mZnNldCwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgICAgIGNvbnN0IGRpZ2VzdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuRElHRVNUX0xFTkdUSCk7XG4gICAgICAgICAgICBjb25zdCB0b1NpZ24gPSB0eC5zbGljZSgwLCBvZmZzZXQpO1xuICAgICAgICAgICAgSzEyKHRvU2lnbiwgZGlnZXN0LCB0aGlzLkRJR0VTVF9MRU5HVEgpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkdHggPSBzY2hub3JycS5zaWduKHNvdXJjZVByaXZhdGVLZXksIHNvdXJjZVB1YmxpY0tleSwgZGlnZXN0KTtcbiAgICAgICAgICAgIHR4LnNldChzaWduZWR0eCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLlNJR05BVFVSRV9MRU5HVEg7XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyB0b2RvOiByZW1vdmUgb24gbmV4dCB1cGRhdGVcbiAgICAvLyBwcml2YXRlIGdldEluY3JlYXNpbmdOb25jZUFuZENvbW1hbmRUeXBlKHR5cGU6IG51bWJlcik6IFVpbnQ4QXJyYXkge1xuICAgIC8vICAgICBsZXQgdGltZXN0YW1wID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgLy8gICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgIC8vICAgICBjb25zdCB0eFZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZUFycmF5LmJ1ZmZlcik7XG4gICAgLy8gICAgIHR4Vmlldy5zZXRVaW50MzIoMCwgdGltZXN0YW1wLCB0cnVlKTtcbiAgICAvLyAgICAgYnl0ZUFycmF5WzddID0gdHlwZTtcbiAgICAvLyAgICAgcmV0dXJuIGJ5dGVBcnJheTtcbiAgICAvLyB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBpbXBsZW1lbnRhdGlvbiBhbGlnbmVkIHdpdGggcXViaWMtY2xpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZ2V0SW5jcmVhc2luZ05vbmNlQW5kQ29tbWFuZFR5cGUodHlwZSkge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBCaWdJbnQoTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCkpO1xuICAgICAgICBjb25zdCBjb21tYW5kQnl0ZSA9IEJpZ0ludCh0eXBlKSA8PCBCaWdJbnQoNTYpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjb21tYW5kQnl0ZSB8IHRpbWVzdGFtcDtcbiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgICAgIGNvbnN0IHR4VmlldyA9IG5ldyBEYXRhVmlldyhieXRlQXJyYXkuYnVmZmVyKTtcbiAgICAgICAgdHhWaWV3LnNldEJpZ1VpbnQ2NCgwLCByZXN1bHQsIHRydWUpO1xuICAgICAgICByZXR1cm4gYnl0ZUFycmF5O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVQcm9wb3NhbChwcm90b2NvbCwgY29tcHV0b3JJbmRleCwgb3BlcmF0b3JTZWVkLCB1cmwpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b18xLmRlZmF1bHQudGhlbigoeyBzY2hub3JycSwgSzEyIH0pID0+IHtcbiAgICAgICAgICAgIC8vIG9wZXJhdG9yXG4gICAgICAgICAgICBjb25zdCBvcGVyYXRvclByaXZhdGVLZXkgPSB0aGlzLnByaXZhdGVLZXkob3BlcmF0b3JTZWVkLCAwLCBLMTIpO1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3JQdWJsaWNLZXkgPSB0aGlzLmNyZWF0ZVB1YmxpY0tleShvcGVyYXRvclByaXZhdGVLZXksIHNjaG5vcnJxLCBLMTIpO1xuICAgICAgICAgICAgLy8gcHJlcGFyZSB1cmxcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHVybEJ5dGVzID0gZW5jb2Rlci5lbmNvZGUodXJsKTtcbiAgICAgICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVaW50OEFycmF5KDI1NSk7XG4gICAgICAgICAgICBjb25zdCB1cmlTaXplID0gdXJsQnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgdXJpLnNldCh1cmxCeXRlcyk7XG4gICAgICAgICAgICBjb25zdCBwcm9wb3NhbCA9IG5ldyBVaW50OEFycmF5KHRoaXMuU0VUX1BST1BPU0FMX0FORF9CQUxMT1RfUkVRVUVTVF9TSVpFICsgdGhpcy5SRVFVRVNUX1JFU1BPTlNFX0hFQURFUl9TSVpFKS5maWxsKDApO1xuICAgICAgICAgICAgY29uc3QgdHhWaWV3ID0gbmV3IERhdGFWaWV3KHByb3Bvc2FsLmJ1ZmZlcik7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIC8vIGhlYWRlclxuICAgICAgICAgICAgLy8gYnl0ZVszXSBzaXplXG4gICAgICAgICAgICBjb25zdCBzaXplID0gNjAwO1xuICAgICAgICAgICAgcHJvcG9zYWxbMF0gPSBzaXplO1xuICAgICAgICAgICAgcHJvcG9zYWxbMV0gPSAoc2l6ZSA+PiA4KTtcbiAgICAgICAgICAgIHByb3Bvc2FsWzJdID0gKHNpemUgPj4gMTYpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAvLyBieXRlIHR5cGVcbiAgICAgICAgICAgIHByb3Bvc2FsW29mZnNldF0gPSB0aGlzLlBST0NFU1NfU1BFQ0lBTF9DT01NQU5EO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAvLyBieXRlWzNdIGRlamF2dSAod2UgbGV0IGl0IGVtcHR5KVxuICAgICAgICAgICAgcHJvcG9zYWxbb2Zmc2V0KytdID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU1KTtcbiAgICAgICAgICAgIHByb3Bvc2FsW29mZnNldCsrXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NSk7XG4gICAgICAgICAgICBwcm9wb3NhbFtvZmZzZXQrK10gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTUpO1xuICAgICAgICAgICAgLy8gYnl0ZSB0eXBlIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgIHByb3Bvc2FsW29mZnNldF0gPSB0aGlzLlBST0NFU1NfU1BFQ0lBTF9DT01NQU5EO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAvLyB1bG9uZyBldmVySW5jcmVhc2luZ05vbmNlQW5kQ29tbWFuZFR5cGUgLy8gOFxuICAgICAgICAgICAgdmFyIHRpbWVTdGFtcCA9IHRoaXMuZ2V0SW5jcmVhc2luZ05vbmNlQW5kQ29tbWFuZFR5cGUodGhpcy5TUEVDSUFMX0NPTU1BTkRfU0VUX1BST1BPU0FMX0FORF9CQUxMT1RfUkVRVUVTVCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVTdGFtcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3Bvc2FsW29mZnNldCArIGldID0gdGltZVN0YW1wW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IHRpbWVTdGFtcC5sZW5ndGg7XG4gICAgICAgICAgICAvLyB1c2hvcnQgY29tcHV0b3JJbmRleCAvLyAyXG4gICAgICAgICAgICB0eFZpZXcuc2V0VWludDE2KG9mZnNldCwgY29tcHV0b3JJbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgICAgICAgIC8vIHBhZGRpbmcgLy82XG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gNjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGluZzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvcG9zYWxbb2Zmc2V0ICsgaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IHBhZGRpbmc7XG4gICAgICAgICAgICAvLyBTdGFydCBDb21wdXRvclByb3Bvc2FsXG4gICAgICAgICAgICAvLyBieXRlIHVyaVNpemUgLy8gMVxuICAgICAgICAgICAgcHJvcG9zYWxbb2Zmc2V0XSA9IHVyaVNpemU7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIC8vIGJ5dGVbMjU1XSB1cmkgLy8gMjU1XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVyaVNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3Bvc2FsW29mZnNldCArIGldID0gdXJpW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IDI1NTtcbiAgICAgICAgICAgIC8vIFN0YXJ0IENvbXB1dG9yQmFsbG90XG4gICAgICAgICAgICAvLyBub3QgdXNlZCBmb3IgdGhpcyByZXF1ZXN0IHRoZXJlZm9yZSB3ZSBsZXQgaXQgZW1wdHlcbiAgICAgICAgICAgIG9mZnNldCArPSAyNTY7XG4gICAgICAgICAgICBjb25zdCBkaWdlc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLkRJR0VTVF9MRU5HVEgpO1xuICAgICAgICAgICAgY29uc3QgdG9TaWduID0gcHJvcG9zYWwuc2xpY2UodGhpcy5SRVFVRVNUX1JFU1BPTlNFX0hFQURFUl9TSVpFLCBvZmZzZXQpO1xuICAgICAgICAgICAgSzEyKHRvU2lnbiwgZGlnZXN0LCB0aGlzLkRJR0VTVF9MRU5HVEgpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXIgPSBzY2hub3JycS5zaWduKG9wZXJhdG9yUHJpdmF0ZUtleSwgb3BlcmF0b3JQdWJsaWNLZXksIGRpZ2VzdCk7XG4gICAgICAgICAgICBwcm9wb3NhbC5zZXQoc2lnbmF0dXIsIG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdGhpcy5TSUdOQVRVUkVfTEVOR1RIO1xuICAgICAgICAgICAgcmV0dXJuIHByb3Bvc2FsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgVm90ZXNUb0J5dGVBcnJheSh2b3Rlcykge1xuICAgICAgICB2YXIgYml0QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgY29tcHV0b3JJbmRleCA9IDA7IGNvbXB1dG9ySW5kZXggPCB2b3Rlcy5sZW5ndGg7IGNvbXB1dG9ySW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIHZvdGUgPSB2b3Rlc1tjb21wdXRvckluZGV4XTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJpdCA9ICh2b3RlID4+IGkpICYgMTtcbiAgICAgICAgICAgICAgICBiaXRBcnJheS5wdXNoKGJpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KE1hdGguY2VpbChiaXRBcnJheS5sZW5ndGggLyA4KSk7XG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYml0QXJyYXkubGVuZ3RoOyBrICs9IDgpIHtcbiAgICAgICAgICAgIHZhciBieXRlSW5kZXggPSBNYXRoLmZsb29yKGsgLyA4KTtcbiAgICAgICAgICAgIHZhciBieXRlVmFsdWUgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYml0ID0gYml0QXJyYXlbayArIGpdIHx8IDA7IC8vIFVzZSAwIGZvciBwYWRkaW5nIGlmIGJpdEFycmF5IGlzIGV4aGF1c3RlZFxuICAgICAgICAgICAgICAgIGJ5dGVWYWx1ZSB8PSAoYml0IDw8IGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0W2J5dGVJbmRleF0gPSBieXRlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQmFsbG90UmVxdWVzdHMocHJvdG9jb2wsIG9wZXJhdG9yU2VlZCwgY29tcHV0b3JJbmRpY2VzLCB2b3Rlcykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuZGVmYXVsdC50aGVuKCh7IHNjaG5vcnJxLCBLMTIgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgICAgICAvLyBvcGVyYXRvclxuICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3JQcml2YXRlS2V5ID0gdGhpcy5wcml2YXRlS2V5KG9wZXJhdG9yU2VlZCwgMCwgSzEyKTtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yUHVibGljS2V5ID0gdGhpcy5jcmVhdGVQdWJsaWNLZXkob3BlcmF0b3JQcml2YXRlS2V5LCBzY2hub3JycSwgSzEyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjb21wdXRvckluZGljZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcG9zYWwgPSBuZXcgVWludDhBcnJheSh0aGlzLlNFVF9QUk9QT1NBTF9BTkRfQkFMTE9UX1JFUVVFU1RfU0laRSArIHRoaXMuUkVRVUVTVF9SRVNQT05TRV9IRUFERVJfU0laRSkuZmlsbCgwKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eFZpZXcgPSBuZXcgRGF0YVZpZXcocHJvcG9zYWwuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAvLyBoZWFkZXJcbiAgICAgICAgICAgICAgICAvLyBieXRlWzNdIHNpemVcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gNjAwO1xuICAgICAgICAgICAgICAgIHByb3Bvc2FsWzBdID0gc2l6ZTtcbiAgICAgICAgICAgICAgICBwcm9wb3NhbFsxXSA9IChzaXplID4+IDgpO1xuICAgICAgICAgICAgICAgIHByb3Bvc2FsWzJdID0gKHNpemUgPj4gMTYpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgIC8vIGJ5dGUgdHlwZVxuICAgICAgICAgICAgICAgIHByb3Bvc2FsW29mZnNldF0gPSB0aGlzLlBST0NFU1NfU1BFQ0lBTF9DT01NQU5EO1xuICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgICAgIC8vIGJ5dGVbM10gZGVqYXZ1ICh3ZSBsZXQgaXQgZW1wdHkpXG4gICAgICAgICAgICAgICAgcHJvcG9zYWxbb2Zmc2V0KytdID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU1KTtcbiAgICAgICAgICAgICAgICBwcm9wb3NhbFtvZmZzZXQrK10gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTUpO1xuICAgICAgICAgICAgICAgIHByb3Bvc2FsW29mZnNldCsrXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NSk7XG4gICAgICAgICAgICAgICAgLy8gYnl0ZSB0eXBlIChkZXBjcmVjYXRlZClcbiAgICAgICAgICAgICAgICBwcm9wb3NhbFtvZmZzZXRdID0gdGhpcy5QUk9DRVNTX1NQRUNJQUxfQ09NTUFORDtcbiAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAvLyB1bG9uZyBldmVySW5jcmVhc2luZ05vbmNlQW5kQ29tbWFuZFR5cGUgLy8gOFxuICAgICAgICAgICAgICAgIHZhciB0aW1lU3RhbXAgPSB0aGlzLmdldEluY3JlYXNpbmdOb25jZUFuZENvbW1hbmRUeXBlKHRoaXMuU1BFQ0lBTF9DT01NQU5EX1NFVF9QUk9QT1NBTF9BTkRfQkFMTE9UX1JFUVVFU1QpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZVN0YW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3Bvc2FsW29mZnNldCArIGldID0gdGltZVN0YW1wW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gdGltZVN0YW1wLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyB1c2hvcnQgY29tcHV0b3JJbmRleCAvLyAyXG4gICAgICAgICAgICAgICAgdHhWaWV3LnNldFVpbnQxNihvZmZzZXQsIGNvbXB1dG9ySW5kaWNlc1tpbmRleF0sIHRydWUpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgIC8vIHBhZGRpbmcgLy82XG4gICAgICAgICAgICAgICAgY29uc3QgcGFkZGluZyA9IDY7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkaW5nOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWxbb2Zmc2V0ICsgaV0gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gcGFkZGluZztcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBDb21wdXRvclByb3Bvc2FsXG4gICAgICAgICAgICAgICAgLy8gYnl0ZSB1cmlTaXplIC8vIDFcbiAgICAgICAgICAgICAgICBwcm9wb3NhbFtvZmZzZXRdID0gMDtcbiAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAvLyBieXRlWzI1NV0gdXJpIC8vIDI1NSAvLyA9PiBpZ25vcmUgZm9yIGJhbGxvdCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgLy8gbm90IHVzZWQgZm9yIHRoaXMgcmVxdWVzdCB0aGVyZWZvcmUgd2UgbGV0IGl0IGVtcHR5XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDI1NTtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBDb21wdXRvckJhbGxvdFxuICAgICAgICAgICAgICAgIG9mZnNldCsrOyAvLyB6ZXJvXG4gICAgICAgICAgICAgICAgLy8gbWFwIHZvdGVzXG4gICAgICAgICAgICAgICAgdmFyIHZvdGVCeXRlcyA9IHRoaXMuVm90ZXNUb0J5dGVBcnJheSh2b3Rlcyk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2b3RlQnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcG9zYWxbb2Zmc2V0KytdID0gdm90ZUJ5dGVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQrKzsgLy8gcXVhc2lyYW5kb21udW1iZXJcbiAgICAgICAgICAgICAgICBjb25zdCBkaWdlc3QgPSBuZXcgVWludDhBcnJheSh0aGlzLkRJR0VTVF9MRU5HVEgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvU2lnbiA9IHByb3Bvc2FsLnNsaWNlKHRoaXMuUkVRVUVTVF9SRVNQT05TRV9IRUFERVJfU0laRSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBLMTIodG9TaWduLCBkaWdlc3QsIHRoaXMuRElHRVNUX0xFTkdUSCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXIgPSBzY2hub3JycS5zaWduKG9wZXJhdG9yUHJpdmF0ZUtleSwgb3BlcmF0b3JQdWJsaWNLZXksIGRpZ2VzdCk7XG4gICAgICAgICAgICAgICAgcHJvcG9zYWwuc2V0KHNpZ25hdHVyLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLlNJR05BVFVSRV9MRU5HVEg7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocHJvcG9zYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRvd25sb2FkQmxvYihmaWxlTmFtZSwgYmxvYikge1xuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKSB7XG4gICAgICAgICAgICB3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZUJsb2IoYmxvYiwgZmlsZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgIGFuY2hvci5ocmVmID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICBhbmNob3IuZG93bmxvYWQgPSBmaWxlTmFtZTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYW5jaG9yKTtcbiAgICAgICAgICAgIGFuY2hvci5jbGljaygpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChhbmNob3IpO1xuICAgICAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwoYW5jaG9yLmhyZWYpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5RdWJpY0hlbHBlciA9IFF1YmljSGVscGVyO1xuIiwiLypcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgcGVycGV0dWFsLCB3b3JsZHdpZGUsIG5vbi1leGNsdXNpdmUsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgXG50byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBcbmFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5cbiAgMS4gVGhlIFNvZnR3YXJlIGNhbm5vdCBiZSB1c2VkIGluIGFueSBmb3JtIG9yIGluIGFueSBzdWJzdGFudGlhbCBwb3J0aW9ucyBmb3IgZGV2ZWxvcG1lbnQsIG1haW50ZW5hbmNlIGFuZCBmb3IgYW55IG90aGVyIHB1cnBvc2VzLCBpbiB0aGUgbWlsaXRhcnkgc3BoZXJlIGFuZCBpbiByZWxhdGlvbiB0byBtaWxpdGFyeSBwcm9kdWN0cywgXG4gIGluY2x1ZGluZywgYnV0IG5vdCBsaW1pdGVkIHRvOlxuXG4gICAgYS4gYW55IGtpbmQgb2YgYXJtb3JlZCBmb3JjZSB2ZWhpY2xlcywgbWlzc2lsZSB3ZWFwb25zLCB3YXJzaGlwcywgYXJ0aWxsZXJ5IHdlYXBvbnMsIGFpciBtaWxpdGFyeSB2ZWhpY2xlcyAoaW5jbHVkaW5nIG1pbGl0YXJ5IGFpcmNyYWZ0cywgY29tYmF0IGhlbGljb3B0ZXJzLCBtaWxpdGFyeSBkcm9uZXMgYWlyY3JhZnRzKSwgXG4gICAgYWlyIGRlZmVuc2Ugc3lzdGVtcywgcmlmbGUgYXJtYW1lbnRzLCBzbWFsbCBhcm1zLCBmaXJlYXJtcyBhbmQgc2lkZSBhcm1zLCBtZWxlZSB3ZWFwb25zLCBjaGVtaWNhbCB3ZWFwb25zLCB3ZWFwb25zIG9mIG1hc3MgZGVzdHJ1Y3Rpb247XG5cbiAgICBiLiBhbnkgc3BlY2lhbCBzb2Z0d2FyZSBmb3IgZGV2ZWxvcG1lbnQgdGVjaG5pY2FsIGRvY3VtZW50YXRpb24gZm9yIG1pbGl0YXJ5IHB1cnBvc2VzO1xuXG4gICAgYy4gYW55IHNwZWNpYWwgZXF1aXBtZW50IGZvciB0ZXN0cyBvZiBwcm90b3R5cGVzIG9mIGFueSBzdWJqZWN0cyB3aXRoIG1pbGl0YXJ5IHB1cnBvc2Ugb2YgdXNlO1xuXG4gICAgZC4gYW55IG1lYW5zIG9mIHByb3RlY3Rpb24gZm9yIGNvbmR1Y3Rpb24gb2YgYWN0cyBvZiBhIG1pbGl0YXJ5IG5hdHVyZTtcblxuICAgIGUuIGFueSBzb2Z0d2FyZSBvciBoYXJkd2FyZSBmb3IgZGV0ZXJtaW5pbmcgc3RyYXRlZ2llcywgcmVjb25uYWlzc2FuY2UsIHRyb29wIHBvc2l0aW9uaW5nLCBjb25kdWN0aW5nIG1pbGl0YXJ5IGFjdGlvbnMsIGNvbmR1Y3Rpbmcgc3BlY2lhbCBvcGVyYXRpb25zO1xuXG4gICAgZi4gYW55IGR1YWwtdXNlIHByb2R1Y3RzIHdpdGggcG9zc2liaWxpdHkgdG8gdXNlIHRoZSBwcm9kdWN0IGluIG1pbGl0YXJ5IHB1cnBvc2VzO1xuXG4gICAgZy4gYW55IG90aGVyIHByb2R1Y3RzLCBzb2Z0d2FyZSBvciBzZXJ2aWNlcyBjb25uZWN0ZWQgdG8gbWlsaXRhcnkgYWN0aXZpdGllcztcblxuICAgIGguIGFueSBhdXhpbGlhcnkgbWVhbnMgcmVsYXRlZCB0byBhYm92ZW1lbnRpb25lZCBzcGhlcmVzIGFuZCBwcm9kdWN0cy5cblxuXG4gIDIuIFRoZSBTb2Z0d2FyZSBjYW5ub3QgYmUgdXNlZCBhcyBkZXNjcmliZWQgaGVyZWluIGluIGFueSBjb25uZWN0aW9uIHRvIHRoZSBtaWxpdGFyeSBhY3Rpdml0aWVzLiBBIHBlcnNvbiwgYSBjb21wYW55LCBvciBhbnkgb3RoZXIgZW50aXR5LCB3aGljaCB3YW50cyB0byB1c2UgdGhlIFNvZnR3YXJlLCBcbiAgc2hhbGwgdGFrZSBhbGwgcmVhc29uYWJsZSBhY3Rpb25zIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBwdXJwb3NlIG9mIHVzZSBvZiB0aGUgU29mdHdhcmUgY2Fubm90IGJlIHBvc3NpYmx5IGNvbm5lY3RlZCB0byBtaWxpdGFyeSBwdXJwb3Nlcy5cblxuXG4gIDMuIFRoZSBTb2Z0d2FyZSBjYW5ub3QgYmUgdXNlZCBieSBhIHBlcnNvbiwgYSBjb21wYW55LCBvciBhbnkgb3RoZXIgZW50aXR5LCBhY3Rpdml0aWVzIG9mIHdoaWNoIGFyZSBjb25uZWN0ZWQgdG8gbWlsaXRhcnkgc3BoZXJlIGluIGFueSBtZWFucy4gSWYgYSBwZXJzb24sIGEgY29tcGFueSwgb3IgYW55IG90aGVyIGVudGl0eSwgXG4gIGR1cmluZyB0aGUgcGVyaW9kIG9mIHRpbWUgZm9yIHRoZSB1c2FnZSBvZiBTb2Z0d2FyZSwgd291bGQgZW5nYWdlIGluIGFjdGl2aXRpZXMsIGNvbm5lY3RlZCB0byBtaWxpdGFyeSBwdXJwb3Nlcywgc3VjaCBwZXJzb24sIGNvbXBhbnksIG9yIGFueSBvdGhlciBlbnRpdHkgc2hhbGwgaW1tZWRpYXRlbHkgc3RvcCB0aGUgdXNhZ2UgXG4gIG9mIFNvZnR3YXJlIGFuZCBhbnkgaXRzIG1vZGlmaWNhdGlvbnMgb3IgYWx0ZXJhdGlvbnMuXG5cblxuICA0LiBBYm92ZW1lbnRpb25lZCByZXN0cmljdGlvbnMgc2hvdWxkIGFwcGx5IHRvIGFsbCBtb2RpZmljYXRpb24sIGFsdGVyYXRpb24sIG1lcmdlLCBhbmQgdG8gb3RoZXIgYWN0aW9ucywgcmVsYXRlZCB0byB0aGUgU29mdHdhcmUsIHJlZ2FyZGxlc3Mgb2YgaG93IHRoZSBTb2Z0d2FyZSB3YXMgY2hhbmdlZCBkdWUgdG8gdGhlIFxuICBhYm92ZW1lbnRpb25lZCBhY3Rpb25zLlxuXG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMsIG1vZGlmaWNhdGlvbnMgYW5kIGFsdGVyYXRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBcbklOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggXG5USEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBTSElGVEVEX0hFWF9DSEFSUyA9ICdhYmNkZWZnaGlqa2xtbm9wJztcbmNvbnN0IEFMUEhBQkVUID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JztcblxuZXhwb3J0IGNvbnN0IGJ5dGVzVG9TaGlmdGVkSGV4ID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gIGxldCBoZXggPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGhleCArPSBTSElGVEVEX0hFWF9DSEFSU1tieXRlc1tpXSA+PiA0XSArIFNISUZURURfSEVYX0NIQVJTW2J5dGVzW2ldICYgMTVdO1xuICB9XG5cbiAgcmV0dXJuIGhleC50b1VwcGVyQ2FzZSgpO1xufTtcblxuZXhwb3J0IGNvbnN0IHB1YmxpY0tleVN0cmluZ1RvQnl0ZXMgPSBmdW5jdGlvbiAocykge1xuICBjb25zdCBwdWJsaWNLZXlCeXRlcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhwdWJsaWNLZXlCeXRlcy5idWZmZXIsIDApO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgdmlldy5zZXRCaWdVaW50NjQoaSAqIDgsIDBuLCB0cnVlKTtcbiAgICBmb3IgKGxldCBqID0gMTQ7IGotLSA+IDA7ICkge1xuICAgICAgdmlldy5zZXRCaWdVaW50NjQoaSAqIDgsIHZpZXcuZ2V0QmlnVWludDY0KGkgKiA4LCB0cnVlKSAqIDI2biArIEJpZ0ludChzLmNoYXJDb2RlQXQoaSAqIDE0ICsgaikpIC0gQmlnSW50KCdBJy5jaGFyQ29kZUF0KDApKSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHB1YmxpY0tleUJ5dGVzO1xufTtcblxuZXhwb3J0IGNvbnN0IGJ5dGVzMzJUb1N0cmluZyA9IGZ1bmN0aW9uIChieXRlcykge1xuICBjb25zdCBoZXggPSBieXRlc1RvU2hpZnRlZEhleChieXRlcyk7XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIuYnVmZmVyLCAwKTtcbiAgbGV0IHMgPSAnJztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmlldy5zZXRVaW50OChcbiAgICAgIGksXG4gICAgICAoKGhleC5jaGFyQ29kZUF0KGkgPDwgMSkgLSAnQScuY2hhckNvZGVBdCgwKSkgPDwgNCkgfFxuICAgICAgICAoaGV4LmNoYXJDb2RlQXQoKGkgPDwgMSkgKyAxKSAtICdBJy5jaGFyQ29kZUF0KDApKSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNDsgaisrKSB7XG4gICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIE51bWJlcigodmlldy5nZXRCaWdVaW50NjQoaSAqIDgsIHRydWUpICUgMjZuKSArIEJpZ0ludCgnQScuY2hhckNvZGVBdCgwKSkpXG4gICAgICApO1xuICAgICAgdmlldy5zZXRCaWdVaW50NjQoaSAqIDgsIHZpZXcuZ2V0QmlnVWludDY0KGkgKiA4LCB0cnVlKSAvIDI2biwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHMudG9Mb3dlckNhc2UoKTtcbn07XG5cbmV4cG9ydCBjb25zdCBkaWdlc3RCeXRlc1RvU3RyaW5nID0gYnl0ZXMzMlRvU3RyaW5nO1xuXG5leHBvcnQgY29uc3QgcHVibGljS2V5Qnl0ZXNUb1N0cmluZyA9IGZ1bmN0aW9uIChieXRlcykge1xuICBpZiAoYnl0ZXMubGVuZ3RoID09PSAzMikge1xuICAgIHJldHVybiBieXRlczMyVG9TdHJpbmcoYnl0ZXMpLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICBjb25zdCBoZXggPSBieXRlc1RvU2hpZnRlZEhleChieXRlcyk7XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDQwKTtcbiAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIuYnVmZmVyLCAwKTtcbiAgbGV0IHMgPSAnJztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmlldy5zZXRVaW50OChcbiAgICAgIGksXG4gICAgICAoKGhleC5jaGFyQ29kZUF0KGkgPDwgMSkgLSAnQScuY2hhckNvZGVBdCgwKSkgPDwgNCkgfFxuICAgICAgICAoaGV4LmNoYXJDb2RlQXQoKGkgPDwgMSkgKyAxKSAtICdBJy5jaGFyQ29kZUF0KDApKSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNDsgaisrKSB7XG4gICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIE51bWJlcigodmlldy5nZXRCaWdVaW50NjQoaSAqIDgsIHRydWUpICUgMjZuKSArIEJpZ0ludCgnQScuY2hhckNvZGVBdCgwKSkpXG4gICAgICApO1xuICAgICAgdmlldy5zZXRCaWdVaW50NjQoaSAqIDgsIHZpZXcuZ2V0QmlnVWludDY0KGkgKiA4LCB0cnVlKSAvIDI2biwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmlldy5zZXRCaWdVaW50NjQoMzIsIHZpZXcuZ2V0QmlnVWludDY0KDMyLCB0cnVlKSAmIDB4M2ZmZmZuLCB0cnVlKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgIE51bWJlcigodmlldy5nZXRCaWdVaW50NjQoMzIsIHRydWUpICUgMjZuKSArIEJpZ0ludCgnQScuY2hhckNvZGVBdCgwKSkpXG4gICAgKTtcbiAgICB2aWV3LnNldEJpZ1VpbnQ2NCgzMiwgdmlldy5nZXRCaWdVaW50NjQoMzIsIHRydWUpIC8gMjZuLCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiBzLnRvVXBwZXJDYXNlKCk7XG59O1xuXG5leHBvcnQgY29uc3Qgc2VlZFN0cmluZ1RvQnl0ZXMgPSBmdW5jdGlvbiAoc2VlZCkge1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KHNlZWQubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWVkLmxlbmd0aDsgaSsrKSB7XG4gICAgYnl0ZXNbaV0gPSBBTFBIQUJFVC5pbmRleE9mKHNlZWRbaV0pO1xuICB9XG4gIHJldHVybiBieXRlcztcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgTW9kdWxlIGZyb20gJy4vbGliRm91clFfSzEyLmpzJztcbmltcG9ydCB7IGtlY2Nha1AxNjAwMTIgfSBmcm9tICcuL2tlY2Nha3AuanMnXG5cblxuY29uc3QgYWxsb2NVOCA9IGZ1bmN0aW9uIChsLCB2KSB7XG4gIGxldCBwdHIgPSBNb2R1bGUuX21hbGxvYyhsKTtcbiAgbGV0IGNodW5rID0gTW9kdWxlLkhFQVBVOC5zdWJhcnJheShwdHIsIHB0ciArIGwpO1xuICBpZiAodikge1xuICAgIGNodW5rLnNldCh2KTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59O1xuXG5jb25zdCBhbGxvY1UxNiA9IGZ1bmN0aW9uIChsLCB2KSB7XG4gIGxldCBwdHIgPSBNb2R1bGUuX21hbGxvYyhsKTtcbiAgbGV0IGNodW5rID0gTW9kdWxlLkhFQVBVMTYuc3ViYXJyYXkocHRyLCBwdHIgKyBsKTtcbiAgY2h1bmsuc2V0KHYpO1xuICByZXR1cm4gY2h1bms7XG59O1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgQ3J5cHRvXG4gKi9cblxuLyoqXG4gKiBBIHByb21pc2Ugd2hpY2ggYWx3YXlzIHJlc29sdmVzIHRvIG9iamVjdCB3aXRoIGNyeXB0byBmdW5jdGlvbnMuXG4gKlxuICogQGNvbnN0YW50IHtQcm9taXNlPENyeXB0bz59XG4gKiBAbWVtYmVyb2YgbW9kdWxlOnF1YmljXG4gKi9cbmNvbnN0IGNyeXB0byA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gIE1vZHVsZS5vblJ1bnRpbWVJbml0aWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgQ3J5cHRvLnNjaG5vcnJxXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBzZWNyZXRLZXlcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBjb25zdCBnZW5lcmF0ZVB1YmxpY0tleSA9IGZ1bmN0aW9uIChzZWNyZXRLZXkpIHtcbiAgICAgIGNvbnN0IHNrID0gYWxsb2NVOChzZWNyZXRLZXkubGVuZ3RoLCBzZWNyZXRLZXkpO1xuICAgICAgY29uc3QgcGsgPSBhbGxvY1U4KDMyKTtcblxuICAgICAgY29uc3QgZnJlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgTW9kdWxlLl9mcmVlKHNrLmJ5dGVPZmZzZXQpO1xuICAgICAgICBNb2R1bGUuX2ZyZWUocGsuYnl0ZU9mZnNldCk7XG4gICAgICB9O1xuXG4gICAgICBNb2R1bGUuX1NjaG5vcnJRX0tleUdlbmVyYXRpb24oc2suYnl0ZU9mZnNldCwgcGsuYnl0ZU9mZnNldCk7XG4gICAgICBjb25zdCBrZXkgPSBway5zbGljZSgpO1xuICAgICAgZnJlZSgpO1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlcm9mIENyeXB0by5zY2hub3JycVxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gc2VjcmV0S2V5XG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBwdWJsaWNLZXlcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBjb25zdCBzaWduID0gZnVuY3Rpb24gKHNlY3JldEtleSwgcHVibGljS2V5LCBtZXNzYWdlKSB7XG4gICAgICBjb25zdCBzayA9IGFsbG9jVTgoc2VjcmV0S2V5Lmxlbmd0aCwgc2VjcmV0S2V5KTtcbiAgICAgIGNvbnN0IHBrID0gYWxsb2NVOChwdWJsaWNLZXkubGVuZ3RoLCBwdWJsaWNLZXkpO1xuICAgICAgY29uc3QgbSA9IGFsbG9jVTgobWVzc2FnZS5sZW5ndGgsIG1lc3NhZ2UpO1xuICAgICAgY29uc3QgcyA9IGFsbG9jVTgoNjQpO1xuXG4gICAgICBjb25zdCBmcmVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBNb2R1bGUuX2ZyZWUoc2suYnl0ZU9mZnNldCk7XG4gICAgICAgIE1vZHVsZS5fZnJlZShway5ieXRlT2Zmc2V0KTtcbiAgICAgICAgTW9kdWxlLl9mcmVlKG0uYnl0ZU9mZnNldCk7XG4gICAgICAgIE1vZHVsZS5fZnJlZShzLmJ5dGVPZmZzZXQpO1xuICAgICAgfTtcblxuICAgICAgTW9kdWxlLl9TY2hub3JyUV9TaWduKFxuICAgICAgICBzay5ieXRlT2Zmc2V0LFxuICAgICAgICBway5ieXRlT2Zmc2V0LFxuICAgICAgICBtLmJ5dGVPZmZzZXQsXG4gICAgICAgIG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgICBzLmJ5dGVPZmZzZXRcbiAgICAgICk7XG4gICAgICBjb25zdCBzaWcgPSBzLnNsaWNlKCk7XG4gICAgICBmcmVlKCk7XG4gICAgICByZXR1cm4gc2lnO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgQ3J5cHRvLnNjaG5vcnJxXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBwdWJsaWNLZXlcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHNpZ25hdHVyZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IDEgaWYgdmFsaWQsIDAgaWYgaW52YWxpZFxuICAgICAqL1xuICAgIGNvbnN0IHZlcmlmeSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIG1lc3NhZ2UsIHNpZ25hdHVyZSkge1xuICAgICAgY29uc3QgcGsgPSBhbGxvY1U4KHB1YmxpY0tleS5sZW5ndGgsIHB1YmxpY0tleSk7XG4gICAgICBjb25zdCBtID0gYWxsb2NVOChtZXNzYWdlLmxlbmd0aCwgbWVzc2FnZSk7XG4gICAgICBjb25zdCBzID0gYWxsb2NVOChzaWduYXR1cmUubGVuZ3RoLCBzaWduYXR1cmUpO1xuICAgICAgY29uc3QgdiA9IGFsbG9jVTE2KDEsIG5ldyBVaW50MTZBcnJheSgxKSk7XG5cbiAgICAgIGNvbnN0IGZyZWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE1vZHVsZS5fZnJlZShway5ieXRlT2Zmc2V0KTtcbiAgICAgICAgTW9kdWxlLl9mcmVlKG0uYnl0ZU9mZnNldCk7XG4gICAgICAgIE1vZHVsZS5fZnJlZShzLmJ5dGVPZmZzZXQpO1xuICAgICAgICBNb2R1bGUuX2ZyZWUodi5ieXRlT2Zmc2V0KTtcbiAgICAgIH07XG5cbiAgICAgIE1vZHVsZS5fU2Nobm9yclFfVmVyaWZ5KFxuICAgICAgICBway5ieXRlT2Zmc2V0LFxuICAgICAgICBtLmJ5dGVPZmZzZXQsXG4gICAgICAgIG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgICBzLmJ5dGVPZmZzZXQsXG4gICAgICAgIHYuYnl0ZU9mZnNldFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHZlciA9IHZbMF07XG4gICAgICBmcmVlKCk7XG4gICAgICByZXR1cm4gdmVyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgQ3J5cHRvLmtleFxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gc2VjcmV0S2V5XG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBjb25zdCBnZW5lcmF0ZUNvbXByZXNzZWRQdWJsaWNLZXkgPSBmdW5jdGlvbiAoc2VjcmV0S2V5KSB7XG4gICAgICBjb25zdCBzayA9IGFsbG9jVTgoc2VjcmV0S2V5Lmxlbmd0aCwgc2VjcmV0S2V5KTtcbiAgICAgIGNvbnN0IHBrID0gYWxsb2NVOCgzMik7XG5cbiAgICAgIGNvbnN0IGZyZWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE1vZHVsZS5fZnJlZShzay5ieXRlT2Zmc2V0KTtcbiAgICAgICAgTW9kdWxlLl9mcmVlKHBrLmJ5dGVPZmZzZXQpO1xuICAgICAgfTtcblxuICAgICAgTW9kdWxlLl9Db21wcmVzc2VkUHVibGljS2V5R2VuZXJhdGlvbihzay5ieXRlT2Zmc2V0LCBway5ieXRlT2Zmc2V0KTtcbiAgICAgIGNvbnN0IGtleSA9IHBrLnNsaWNlKCk7XG4gICAgICBmcmVlKCk7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgQ3J5cHRvLmtleFxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gc2VjcmV0S2V5XG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBwdWJsaWNLZXlcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gU2hhcmVkIGtleVxuICAgICAqL1xuICAgIGNvbnN0IGNvbXByZXNzZWRTZWNyZXRBZ3JlZW1lbnQgPSBmdW5jdGlvbiAoc2VjcmV0S2V5LCBwdWJsaWNLZXkpIHtcbiAgICAgIGNvbnN0IHNrID0gYWxsb2NVOChzZWNyZXRLZXkubGVuZ3RoLCBzZWNyZXRLZXkpO1xuICAgICAgY29uc3QgcGsgPSBhbGxvY1U4KHB1YmxpY0tleS5sZW5ndGgsIHB1YmxpY0tleSk7XG4gICAgICBjb25zdCBzaGsgPSBhbGxvY1U4KDMyKTtcblxuICAgICAgY29uc3QgZnJlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgTW9kdWxlLl9mcmVlKHNrLmJ5dGVPZmZzZXQpO1xuICAgICAgICBNb2R1bGUuX2ZyZWUocGsuYnl0ZU9mZnNldCk7XG4gICAgICAgIE1vZHVsZS5fZnJlZShzaGsuYnl0ZU9mZnNldCk7XG4gICAgICB9O1xuXG4gICAgICBNb2R1bGUuX0NvbXByZXNzZWRTZWNyZXRBZ3JlZW1lbnQoc2suYnl0ZU9mZnNldCwgcGsuYnl0ZU9mZnNldCwgc2hrLmJ5dGVPZmZzZXQpO1xuICAgICAgY29uc3Qga2V5ID0gc2hrLnNsaWNlKCk7XG4gICAgICBmcmVlKCk7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgQ3J5cHRvXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dFxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gb3V0cHV0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG91dHB1dExlbmd0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvdXRwdXRPZmZzZXRcbiAgICAgKi9cbiAgICBjb25zdCBLMTIgPSBmdW5jdGlvbiAoaW5wdXQsIG91dHB1dCwgb3V0cHV0TGVuZ3RoLCBvdXRwdXRPZmZzZXQgPSAwKSB7XG4gICAgICBjb25zdCBpID0gYWxsb2NVOChpbnB1dC5sZW5ndGgsIGlucHV0KTtcbiAgICAgIGNvbnN0IG8gPSBhbGxvY1U4KG91dHB1dExlbmd0aCwgbmV3IFVpbnQ4QXJyYXkob3V0cHV0TGVuZ3RoKSk7XG5cbiAgICAgIGNvbnN0IGZyZWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIE1vZHVsZS5fZnJlZShpLmJ5dGVPZmZzZXQpO1xuICAgICAgICBNb2R1bGUuX2ZyZWUoby5ieXRlT2Zmc2V0KTtcbiAgICAgIH07XG5cbiAgICAgIE1vZHVsZS5fS2FuZ2Fyb29Ud2VsdmUoaS5ieXRlT2Zmc2V0LCBpbnB1dC5sZW5ndGgsIG8uYnl0ZU9mZnNldCwgb3V0cHV0TGVuZ3RoLCAwLCAwKTtcbiAgICAgIG91dHB1dC5zZXQoby5zbGljZSgpLCBvdXRwdXRPZmZzZXQpO1xuICAgICAgZnJlZSgpO1xuICAgIH07XG5cbiAgICByZXNvbHZlKHtcbiAgICAgIC8qKlxuICAgICAgICogQG5hbWVzcGFjZSBDcnlwdG8uc2Nobm9ycnFcbiAgICAgICAqL1xuICAgICAgc2Nobm9ycnE6IHtcbiAgICAgICAgZ2VuZXJhdGVQdWJsaWNLZXksXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lc3BhY2UgQ3J5cHRvLmtleFxuICAgICAgICovXG4gICAgICBrZXg6IHtcbiAgICAgICAgZ2VuZXJhdGVDb21wcmVzc2VkUHVibGljS2V5LFxuICAgICAgICBjb21wcmVzc2VkU2VjcmV0QWdyZWVtZW50LFxuICAgICAgfSxcbiAgICAgIEsxMixcbiAgICAgIGtlY2Nha1AxNjAwMTIsXG4gICAgICBLRUNDQUtfU1RBVEVfTEVOR1RIOiAyMDAsXG4gICAgfSk7XG4gIH07XG59KTtcblxuY3J5cHRvLmtlY2Nha1AxNjAwMTIgPSBrZWNjYWtQMTYwMDEyO1xuZXhwb3J0IGNvbnN0IEtFQ0NBS19TVEFURV9MRU5HVEggPSAyMDA7XG5leHBvcnQgY29uc3QgU0lHTkFUVVJFX0xFTkdUSCA9IDY0O1xuZXhwb3J0IGNvbnN0IFBSSVZBVEVfS0VZX0xFTkdUSCA9IDMyO1xuZXhwb3J0IGNvbnN0IFBVQkxJQ19LRVlfTEVOR1RIID0gMzI7XG5leHBvcnQgY29uc3QgRElHRVNUX0xFTkdUSCA9IDMyO1xuZXhwb3J0IGNvbnN0IE5PTkNFX0xFTkdUSCA9IDMyO1xuZXhwb3J0IGNvbnN0IENIRUNLU1VNX0xFTkdUSCA9IDM7XG5cbmV4cG9ydCBkZWZhdWx0IGNyeXB0bztcbiIsIlxuLy8gU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLWhhc2hlcy9ibG9iLzI5OTkwNWM5OGJkZjFhMTk3MDIzMTk4YzhmZTY3ODkyMzQ4Mzg5NmQvc3JjL3NoYTMudHNcblxuLypcblRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG5Db3B5cmlnaHQgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKGh0dHBzOi8vcGF1bG1pbGxyLmNvbSlcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUg4oCcU29mdHdhcmXigJ0pLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIOKAnEFTIElT4oCdLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cbiovXG5cbmNvbnN0IFUzMl9NQVNLNjQgPSBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG5cbi8vIFdlIGFyZSBub3QgdXNpbmcgQmlnVWludDY0QXJyYXksIGJlY2F1c2UgdGhleSBhcmUgZXh0cmVtZWx5IHNsb3cgYXMgcGVyIDIwMjJcbmZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICBpZiAobGUpIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cblxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgfVxuICByZXR1cm4gW0FoLCBBbF07XG59XG5cbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgbCkgPT4gaDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RsU0ggPSAoaCwgbCwgcykgPT4gKGggPDwgcykgfCAobCA+Pj4gKDMyIC0gcykpO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcblxuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuLy8gUmVtb3ZpbmcgXCJleHBvcnRcIiBoYXMgNSUgcGVyZiBwZW5hbHR5IC1fLVxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+XG4gIChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PlxuICAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT5cbiAgKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+XG4gIChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+XG4gIChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsXG4gIHNoclNILCBzaHJTTCxcbiAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICByb3RyMzJILCByb3RyMzJMLFxuICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5cbmNvbnN0IFtTSEEzX1BJLCBTSEEzX1JPVEwsIF9TSEEzX0lPVEFdID0gW1tdLCBbXSwgW11dO1xuXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBfN24gPSBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gQmlnSW50KDB4NzEpO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgLy8gUGlcbiAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgLy8gUm90YXRpb25hbFxuICBTSEEzX1JPVEwucHVzaCgoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikpIC8gMikgJSA2NCk7XG4gIC8vIElvdGFcbiAgbGV0IHQgPSBfMG47XG4gIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgUiA9ICgoUiA8PCBfMW4pIF4gKChSID4+IF83bikgKiBfMHg3MW4pKSAlIF8yNTZuO1xuICAgIGlmIChSICYgXzJuKSB0IF49IF8xbiA8PCAoKF8xbiA8PCBCaWdJbnQoaikpIC0gXzFuKTtcbiAgfVxuICBfU0hBM19JT1RBLnB1c2godCk7XG59XG5jb25zdCBbU0hBM19JT1RBX0gsIFNIQTNfSU9UQV9MXSA9IHU2NC5zcGxpdChfU0hBM19JT1RBLCB0cnVlKTtcblxuY29uc3Qgcm90bEggPSAoaCwgbCwgcykgPT5cbiAgcyA+IDMyID8gdTY0LnJvdGxCSChoLCBsLCBzKSA6IHU2NC5yb3RsU0goaCwgbCwgcyk7XG5jb25zdCByb3RsTCA9IChoLCBsLCBzKSA9PlxuICBzID4gMzIgPyB1NjQucm90bEJMKGgsIGwsIHMpIDogdTY0LnJvdGxTTChoLCBsLCBzKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGtlY2Nha1AxNjAwMTIoczEpIHtcbiAgY29uc3QgcyA9IG5ldyBVaW50MzJBcnJheShzMS5idWZmZXIpO1xuICBjb25zdCByb3VuZHMgPSAxMjtcbiAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBUaGV0YSDOuFxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKykgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XG4gICAgICBjb25zdCBpZHgxID0gKHggKyA4KSAlIDEwO1xuICAgICAgY29uc3QgaWR4MCA9ICh4ICsgMikgJSAxMDtcbiAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcbiAgICAgIGNvbnN0IEIxID0gQltpZHgwICsgMV07XG4gICAgICBjb25zdCBUaCA9IHJvdGxIKEIwLCBCMSwgMSkgXiBCW2lkeDFdO1xuICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgIHNbeCArIHldIF49IFRoO1xuICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXG4gICAgbGV0IGN1ckggPSBzWzJdO1xuICAgIGxldCBjdXJMID0gc1szXTtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcbiAgICAgIGNvbnN0IHNoaWZ0ID0gU0hBM19ST1RMW3RdO1xuICAgICAgY29uc3QgVGggPSByb3RsSChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgIGNvbnN0IFBJID0gU0hBM19QSVt0XTtcbiAgICAgIGN1ckggPSBzW1BJXTtcbiAgICAgIGN1ckwgPSBzW1BJICsgMV07XG4gICAgICBzW1BJXSA9IFRoO1xuICAgICAgc1tQSSArIDFdID0gVGw7XG4gICAgfVxuICAgIC8vIENoaSAoz4cpXG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKSBCW3hdID0gc1t5ICsgeF07XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgfVxuICAgIC8vIElvdGEgKM65KVxuICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICB9XG4gIEIuZmlsbCgwKTtcbn1cbiIsInZhciBlbmNvZGVkV2FzbUZpbGUgPSAnQUdGemJRRUFBQUFCZEJGZ0FuOS9BR0FEZjM5L0FHQUJmd0JnQTM5L2Z3Ri9ZQUYvQVg5Z0FuOS9BWDlnQkg5L2YzOEFZQVIvZjM5L0FYOWdCbjk4ZjM5L2Z3Ri9ZQVYvZjM5L2Z3Ri9ZQVYvZjM5L2Z3QmdBbjUvQVg5Z0JuOS9mMzkvZndGL1lBQUFZQUo4ZndGOFlBUi9mbjkvQVg5Z0EzOStmd0YrQXFvQkJSWjNZWE5wWDNOdVlYQnphRzkwWDNCeVpYWnBaWGN4Q0daa1gzZHlhWFJsQUFjV2QyRnphVjl6Ym1Gd2MyaHZkRjl3Y21WMmFXVjNNUWRtWkY5elpXVnJBQThXZDJGemFWOXpibUZ3YzJodmRGOXdjbVYyYVdWM01RaG1aRjlqYkc5elpRQUVGbmRoYzJsZmMyNWhjSE5vYjNSZmNISmxkbWxsZHpFSmNISnZZMTlsZUdsMEFBSVdkMkZ6YVY5emJtRndjMmh2ZEY5d2NtVjJhV1YzTVFkbVpGOXlaV0ZrQUFjRFZWUUJBUUVBQVFvQUJnRUJBZ01BQVFBR0FnRUFBd0VFQVFBQ0N3d0FBQUFCQVFFRkFBUUNEUUFFQWdNQUFBQUNBUVFHQVFRSERnVURCQVFFQmdZQ0FBVUNBQUlDQUFJQUFBZ1FBd1FEQlFVREJRVUpDUVVFQlFGd0FRY0hCUVlCQVlBQ2dBSUdDUUYvQVVHZ21NSUNDd2VlQWc4R2JXVnRiM0o1QWdBV1UyTm9ibTl5Y2xGZlMyVjVSMlZ1WlhKaGRHbHZiZ0JZRGt0aGJtZGhjbTl2VkhkbGJIWmxBQjhOVTJOb2JtOXljbEZmVTJsbmJnQlhCR1p5WldVQUxROVRZMmh1YjNKeVVWOVdaWEpwWm5rQVZoMURiMjF3Y21WemMyVmtVSFZpYkdsalMyVjVSMlZ1WlhKaGRHbHZiZ0JWRjBOdmJYQnlaWE56WldSTFpYbEhaVzVsY21GMGFXOXVBRlFaUTI5dGNISmxjM05sWkZObFkzSmxkRUZuY21WbGJXVnVkQUJURTFCMVlteHBZMHRsZVVkbGJtVnlZWFJwYjI0QVVnMUxaWGxIWlc1bGNtRjBhVzl1QUZFUFUyVmpjbVYwUVdkeVpXVnRaVzUwQUZBTFgybHVhWFJwWVd4cGVtVUFLaGxmWDJsdVpHbHlaV04wWDJaMWJtTjBhVzl1WDNSaFlteGxBUUFHYldGc2JHOWpBRDBKREFFQVFRRUxCaXBQVGsxTVN3ck8rUU5VckFnQkZYOGpBRUVnYXlJRlFnQTNBeGdnQlVJQU53TVFJQVZDQURjRENDQUZRZ0EzQXdBZ0FTZ0NEQ0lEUVJCMklRNGdBMEgvL3dOeElSQWdBU2dDQ0NJRFFSQjJJUkVnQTBILy93TnhJUklnQVNnQ0JDSURRUkIySVJNZ0EwSC8vd054SVJRZ0FTZ0NBQ0lCUVJCMklSVWdBVUgvL3dOeElSWURRQ0FGSUF4QkFuUWlBV29pQmlBV0lBQWdBV29vQWdBaUEwSC8vd054SWdGc0lnZEJFSFlnRmlBRFFSQjJJZ05zSWdoQi8vOERjV29nQVNBVmJDSUpRZi8vQTNGcUlnMUJFSFFpQ2lBSFFmLy9BM0Z5SUFScUlnYzJBZ0FnQlNBTVFRRnFJZ3hCQW5ScUloY2dDRUVRZGlBSlFSQjJhaUFESUJWc0lnaEIvLzhEY1dvZ0RVRVFkbW9pQ1VHQWdCeHhJQWhCZ0lCOGNXb2dDVUgvL3dOeGNpQUVJQWR6SUFRZ0NuTnlJQWR6UVI5MmFpSU5JQU1nRkd3aUNrSC8vd054SUFFZ0ZHd2lCRUVRZG1vZ0FTQVRiQ0lMUWYvL0EzRnFJZzlCRUhRaUJ5QUVRZi8vQTNGeWFpSUVJQmNvQWdBaUNHb2lDVFlDQUNBR0lBcEJFSFlnQzBFUWRtb2dBeUFUYkNJS1FmLy9BM0ZxSUE5QkVIWnFJZ3RCZ0lBY2NTQUtRWUNBZkhGcUlBdEIvLzhEY1hJZ0JDQUhjeUFISUExemNpQUVjMEVmZG1vZ0NDQUpjeUFFSUFoemNpQUpjMEVmZG1vaURTQURJQkpzSWdwQi8vOERjU0FCSUJKc0lnUkJFSFpxSUFFZ0VXd2lDMEgvL3dOeGFpSVBRUkIwSWdjZ0JFSC8vd054Y21vaUJDQUdLQUlJSWdocUlnazJBZ2dnQmlBS1FSQjJJQXRCRUhacUlBTWdFV3dpQ2tILy93TnhhaUFQUVJCMmFpSUxRWUNBSEhFZ0NrR0FnSHh4YWlBTFFmLy9BM0Z5SUFRZ0IzTWdCeUFOYzNJZ0JITkJIM1pxSUFnZ0NYTWdCQ0FJYzNJZ0NYTkJIM1pxSWdrZ0F5QVFiQ0lOUWYvL0EzRWdBU0FRYkNJSFFSQjJhaUFCSUE1c0lncEIvLzhEY1dvaUMwRVFkQ0lFSUFkQi8vOERjWEpxSWdFZ0JpZ0NEQ0lIYWlJSU5nSU1JQVlnRFVFUWRpQUtRUkIyYWlBRElBNXNJZ05CLy84RGNXb2dDMEVRZG1vaUJrR0FnQnh4SUFOQmdJQjhjV29nQmtILy93TnhjaUFCSUFSeklBUWdDWE55SUFGelFSOTJhaUFISUFoeklBRWdCM055SUFoelFSOTJhallDRUNBTVFRUkdSUVJBSUJjb0FnQWhCQXdCQ3dzZ0FpQUZLQUlBSWdFZ0JTZ0NFQ0lEUVFGMElnWWdCU2dDRENJRVFSOTJjbW9pQUNBRVFmLy8vLzhIY1NBRktBSUlJZ1FnQlNnQ0JDSU1JQUFnQUNBQmN5QUJJQVp6Y25OQkgzWnFJZ0VnQlNnQ0ZDSUdRUUYwSUFOQkgzWnlJZzVxSWdNZ0FYTWdBU0FPYzNJZ0EzTWdEQ0FCUVg5emNYSkJIM1pxSWdFZ0JTZ0NHQ0lNUVFGMElBWkJIM1p5SWc1cUlnWWdBWE1nQVNBT2MzSWdCbk1nQkNBQlFYOXpjWEpCSDNacUlBVW9BaHhCQVhRZ0RFRWZkbkpxSWdGQkgzWnFJZ1UyQWdBZ0FpQURJQUFnQlVGL2MzRkJIM1pxSWdBMkFnUWdBaUFHSUFNZ0FFRi9jM0ZCSDNacUlnQTJBZ2dnQWlBQlFmLy8vLzhIY1NBR0lBQkJmM054UVI5MmFqWUNEQXY3QndFT2Z5TUFRVUJxSWdZa0FDQUFJQUVnQmtFd2FoQUZJQUJCRUdvZ0FVRVFhaUFHUVNCcUVBVWdCaUFBS0FJY0lBQW9BZ3hxSUFBb0FnZ2lDQ0FBS0FJRUlnY2dBQ2dDRUNJRUlBQW9BZ0FpQldvaUF5QUZjeUFFSUFWemNpQURjMEVmZG1vaUJTQUFLQUlVSWdwcUlnUWdCWE1nQlNBS2MzSWdCSE1nQnlBRlFYOXpjWEpCSDNacUlnVWdBQ2dDR0NJSGFpSUFJQVZ6SUFVZ0IzTnlJQUJ6SUFnZ0JVRi9jM0Z5UVI5MmFpSUZRUjkySUFOcUlnZzJBaEFnQmlBRElBaEJmM054UVI5MklBUnFJZ00yQWhRZ0JpQUVJQU5CZjNOeFFSOTJJQUJxSWdNMkFoZ2dCaUFGUWYvLy8vOEhjU0FBSUFOQmYzTnhRUjkyYWpZQ0hDQUdJQUVvQWh3Z0FTZ0NER29nQVNnQ0NDSUVJQUVvQWdRaUNDQUJLQUlRSWdVZ0FTZ0NBQ0lEYWlJQUlBTnpJQU1nQlhOeUlBQnpRUjkyYWlJRElBRW9BaFFpQjJvaUJTQURjeUFESUFkemNpQUZjeUFJSUFOQmYzTnhja0VmZG1vaUF5QUJLQUlZSWdocUlnRWdBM01nQXlBSWMzSWdBWE1nQkNBRFFYOXpjWEpCSDNacUlnTkJIM1lnQUdvaUJEWUNBQ0FHSUFBZ0JFRi9jM0ZCSDNZZ0JXb2lBRFlDQkNBR0lBVWdBRUYvYzNGQkgzWWdBV29pQURZQ0NDQUdJQU5CLy8vLy93ZHhJQUVnQUVGL2MzRkJIM1pxTmdJTUlBSWdCaWdDTUNJQUlBWW9BaUFpQVdzaUJ5QUdLQUk4SWd3Z0JpZ0NMQ0lPSUFZb0FqZ2lBeUFHS0FJb0lnVnJJZ29nQlhNZ0F5QUZjM0lnQTNOQkgzWWdCaWdDTkNJRUlBWW9BaVFpQ0dzaUNTQUljeUFFSUFoemNpQUVjMEVmZGlBQklBZHpJQUFnQVhOeUlBQnpRUjkySWdzZ0NVVnhjaUlOSUFwRmNYSnFheUlQUVI5MkloQnJOZ0lBSUFJZ0NTQUxheUlKSUJBZ0IwVnhJZ2RyTmdJRUlBSWdDaUFOYXlJS0lBY2dDVVZ4SWdkck5nSUlJQUlnRDBILy8vLy9CM0VnQnlBS1JYRnJOZ0lNSUFaQkVHb2lCeUFHSUFjUUJTQUNJQVlvQWhBaUJ5QUFheUlLSUFZb0Fod2dEQ0FESUFZb0FoZ2lDU0FEYXlJTGN5QURJQWx6Y2lBSmMwRWZkaUFFSUFZb0FoUWlBeUFFYXlJSmN5QURJQVJ6Y2lBRGMwRWZkaUFBSUFweklBQWdCM055SUFkelFSOTJJZ1FnQ1VWeGNpSUhJQXRGY1hKcWF5SU1RUjkySWcxcklnQWdBV3NpQXlBTVFmLy8vLzhIY1NBTklBcEZjU0lLSUFrZ0JHc2lCRVZ4SWdrZ0N5QUhheUlMUlhFZ0RpQUlJQVFnQ21zaUJDQUlheUlIY3lBRUlBaHpjaUFFYzBFZmRpQUJJQU56SUFBZ0FYTnlJQUJ6UVI5MklnUWdCMFZ4Y2lJSUlBc2dDV3NpQUNBRmF5SUJSWEVnQVNBRmN5QUFJQVZ6Y2lBQWMwRWZkbkpxYW1zaUFFRWZkaUlGYXpZQ0VDQUNJQWNnQkdzaUJDQUZJQU5GY1NJRGF6WUNGQ0FDSUFFZ0NHc2lBU0FESUFSRmNTSURhellDR0NBQ0lBQkIvLy8vL3dkeElBTWdBVVZ4YXpZQ0hDQUdRVUJySkFBTDNBTUJCbjhnQWlBQktBSUFJZ01nQUNnQ0FDSUVhaUlGTmdJQUlBSWdBQ2dDQkNJR0lBUWdCWE1nQXlBRWMzSWdCWE5CSDNacUlnTWdBU2dDQkNJSGFpSUVOZ0lFSUFJZ0FDZ0NDQ0lJSUFZZ0EwRi9jM0VnQXlBRWN5QURJQWR6Y2lBRWMzSkJIM1pxSWdZZ0FTZ0NDQ0lIYWlJRE5nSUlJQUlnQVNnQ0RDQUFLQUlNYWlBSUlBWkJmM054SUFNZ0JuTWdCaUFIYzNJZ0EzTnlRUjkyYWlJR1FSOTJJQVZxSWdjMkFnQWdBaUFGSUFkQmYzTnhRUjkySUFScUlnVTJBZ1FnQWlBRUlBVkJmM054UVI5MklBTnFJZ1UyQWdnZ0FpQUdRZi8vLy84SGNTQURJQVZCZjNOeFFSOTJhallDRENBQ0lBRW9BaEFpQXlBQUtBSVFJZ1JxSWdVMkFoQWdBaUFBS0FJVUlnWWdCQ0FGY3lBRElBUnpjaUFGYzBFZmRtb2lBeUFCS0FJVUlnZHFJZ1EyQWhRZ0FpQUFLQUlZSWdnZ0JpQURRWDl6Y1NBRElBUnpJQU1nQjNOeUlBUnpja0VmZG1vaUJpQUJLQUlZSWdkcUlnTTJBaGdnQWlBQktBSWNJQUFvQWh4cUlBZ2dCa0YvYzNFZ0F5QUdjeUFHSUFkemNpQURjM0pCSDNacUlnQkJIM1lnQldvaUFUWUNFQ0FDSUFVZ0FVRi9jM0ZCSDNZZ0JHb2lBVFlDRkNBQ0lBUWdBVUYvYzNGQkgzWWdBMm9pQVRZQ0dDQUNJQUJCLy8vLy93ZHhJQU1nQVVGL2MzRkJIM1pxTmdJY0M4QUVBUkovSXdCQk1Hc2lCQ1FBSUFRZ0FDZ0NBQ0lDSUFCQkVHb2lEQ2dDQUNJSGF5SUZJQUFvQWd3aURTQUFLQUljSWc0Z0FDZ0NDQ0lESUFBb0FoZ2lDR3NpQ2lBSWN5QURJQWh6Y2lBRGMwRWZkaUFBS0FJRUlnWWdBQ2dDRkNJSmF5SUxJQWx6SUFZZ0NYTnlJQVp6UVI5MklBSWdCM01pRHlBRklBZHpjaUFDYzBFZmRpSVFJQXRGY1hJaUVTQUtSWEZ5YW1zaUVrRWZkaUlUYXpZQ0VDQUVJQXNnRUdzaUN5QVRJQVZGY1NJRmF6WUNGQ0FFSUFvZ0VXc2lDaUFGSUF0RmNTSUZhellDR0NBRUlCSkIvLy8vL3dkeElBVWdDa1Z4YXpZQ0hDQUVJQTBnRG1vZ0NDQURJQWtnQmlBQ0lBSWdCMm9pQjNNZ0QzSWdCM05CSDNacUlnSnFJZ1VnQW5NZ0FpQUpjM0lnQlhNZ0JpQUNRWDl6Y1hKQkgzWnFJZ0pxSWdZZ0FuTWdBaUFJYzNJZ0JuTWdBeUFDUVg5emNYSkJIM1pxSWdKQkgzWWdCMm9pQXpZQ0lDQUVJQWNnQTBGL2MzRkJIM1lnQldvaUF6WUNKQ0FFSUFVZ0EwRi9jM0ZCSDNZZ0Jtb2lBellDS0NBRUlBSkIvLy8vL3dkeElBWWdBMEYvYzNGQkgzWnFOZ0lzSUFBZ0RDQUVFQVVnQkVFZ2FpQUVRUkJxSUFFUUJTQUVLQUlNSVFZZ0JDZ0NDQ0VBSUFFZ0JDZ0NCQ0lDSUFRb0FnQWlDVUVmZG1vaUF5QUNhaUlJTmdJVUlBRWdBQ0FBSUFJZ0EwRi9jM0VnQXlBSWN5QUNJQU56Y2lBSWMzSkJIM1pxSWdKcUlnTTJBaGdnQVNBR1FRRjBJQUFnQWtGL2MzRWdBaUFEY3lBQUlBSnpjaUFEYzNKQkgzWnlJZ0JCLy8vLy93ZHhOZ0ljSUFFZ0NVRUJkQ0FBUVI5MmNqWUNFQ0FFUVRCcUpBQUx2Z0VCQTM4Z0FDMEFBRUVnY1VVRVFBSkFJQUVoQXdKQUlBSWdBQ0lCS0FJUUlnQUVmeUFBQlNBQkVEUU5BU0FCS0FJUUN5QUJLQUlVSWdWclN3UkFJQUVnQXlBQ0lBRW9BaVFSQXdBYURBSUxBa0FnQVNnQ1VFRUFTQTBBSUFJaEFBTkFJQUFpQkVVTkFTQURJQVJCQVdzaUFHb3RBQUJCQ2tjTkFBc2dBU0FESUFRZ0FTZ0NKQkVEQUNBRVNRMEJJQU1nQkdvaEF5QUNJQVJySVFJZ0FTZ0NGQ0VGQ3lBRklBTWdBaEFZR2lBQklBRW9BaFFnQW1vMkFoUUxDd3NMYmdFQmZ5TUFRWUFDYXlJRkpBQUNRQ0FFUVlEQUJIRU5BQ0FDSUFOTURRQWdCU0FCUWY4QmNTQUNJQU5ySWdKQmdBSWdBa0dBQWtraUFSc1FEaUFCUlFSQUEwQWdBQ0FGUVlBQ0VBa2dBa0dBQW1zaUFrSC9BVXNOQUFzTElBQWdCU0FDRUFrTElBVkJnQUpxSkFBTDR3Z0JJSDhqQUVGQWFpSURKQUFnQVVIZ0FHb2lEU0FCUVlBQmFpSVFJQTBRQmlBQktBSk1JUXNnQVNnQ1NDRU1JQUVvQWtRaENDQUJRVUJySWhNb0FnQWhCQ0FESUFFb0FseEJBWFFnQVNnQ1dDSUhJQUVvQWxRaUFpQUJLQUpRSWc1QkgzWnFJZ1VnQW1vaUJpQUZjeUFDSUFWemNpQUdjeUFDSUFWQmYzTnhja0VmZG1vaUJTQUhhaUlDSUFWeklBVWdCM055SUFKeklBY2dCVUYvYzNGeVFSOTJjaUlSUWYvLy8vOEhjVFlDUENBTklBQkJRR3NnRFJBR0lBRWdBVUVnYWlJWElCTVFCeUFYSUFFZ0VCQU5JQU1nQkVFQmRDSVlJQXRCQVhRZ0RDQU1JQWdnQ0NBRVFSOTJhaUlGYWlJSElBVnpJQVVnQ0hOeUlBZHpJQWdnQlVGL2MzRnlRUjkyYWlJRmFpSUlJQVZ6SUFVZ0RITnlJQWh6SUF3Z0JVRi9jM0Z5UVI5MmNpSU1RUjkyY2lJWklBMG9BZ0FpRkdzaUJDQU1RZi8vLy84SGNTSWFJQUVvQW13aUd5QUlJQUVvQW1naURHc2lDeUFNY3lBSUlBeHpjaUFJYzBFZmRpQUhJQUVvQW1RaUJXc2lDU0FGY3lBRklBZHpjaUFIYzBFZmRpQVVJQmx6SWh3Z0JDQVVjM0lnR0hOQkgzWWlDaUFKUlhGeUloSWdDMFZ4Y21wcklnOUJIM1lpRldzMkFnQWdBeUFKSUFwcklna2dGU0FFUlhFaUJHczJBZ1FnQXlBTElCSnJJZ3NnQkNBSlJYRWlCR3MyQWdnZ0F5QVBRZi8vLy84SGNTQUVJQXRGY1dzMkFnd2dBeUFHSUFFb0FuUWlCR3NpQ2lBT1FRRjBJZzRnRVVFZmRuSWlFU0FCS0FKd0lnbHJJaElnQ1hNZ0NTQVJjeUlWY2lBT2MwRWZkaUlXYXlJZElBTW9BandpSGlBQktBSjhJaDhnQWlBQktBSjRJZ3RySWc4Z0MzTWdBaUFMYzNJZ0FuTkJIM1lnRmlBS1JYRWdCQ0FLY3lBRUlBWnpjaUFHYzBFZmRuSWlDaUFQUlhGeWFtc2lGa0VmZGlJZ0lCSkZjU0loYXpZQ0ZDQURJQThnQ21zaUNpQWhJQjFGY1NJUGF6WUNHQ0FESUJaQi8vLy8vd2R4SUE4Z0NrVnhhellDSENBRElCNGdIMm9nQ3lBRUlBa2dFV29pQ1NBT2N5QVZjaUFKYzBFZmRpQUdhaUlLYWlJT0lBcHpJQVFnQ25OeUlBNXpJQVlnQ2tGL2MzRnlRUjkySUFKcUlnWnFJZ1FnQm5NZ0JpQUxjM0lnQkhNZ0FpQUdRWDl6Y1hKQkgzWnFJZ1pCSDNZZ0NXb2lBallDTUNBRElBa2dBa0YvYzNGQkgzWWdEbW9pQWpZQ05DQURJQTRnQWtGL2MzRkJIM1lnQkdvaUFqWUNPQ0FESUFaQi8vLy8vd2R4SUFRZ0FrRi9jM0ZCSDNacU5nSThJQU1nRWlBZ2F6WUNFQ0FESUJvZ0cyb2dEQ0FGSUJRZ0dXb2lCaUFZY3lBY2NpQUdjMEVmZGlBSGFpSUNhaUlFSUFKeklBSWdCWE55SUFSeklBY2dBa0YvYzNGeVFSOTJJQWhxSWdKcUlnY2dBbk1nQWlBTWMzSWdCM01nQ0NBQ1FYOXpjWEpCSDNacUlnSkJIM1lnQm1vaUNEWUNJQ0FESUFZZ0NFRi9jM0ZCSDNZZ0JHb2lCallDSkNBRElBUWdCa0YvYzNGQkgzWWdCMm9pQmpZQ0tDQURJQUpCLy8vLy93ZHhJQWNnQmtGL2MzRkJIM1pxTmdJc0lBQWdFeUFORUFZZ0FFRWdhaUFRSUFFUUJpQURRU0JxSWdBZ0F5QVRFQVlnRFNBQklCQVFEU0FOSUFFZ0RSQUhJQkFnQXlBQkVBWWdEU0FBSUJjUUJpQURRVUJySkFBTHZRSUJEbjhDUUFKQUlBTkIvLy8vL3dkeEJFQWdBa0VBSUFOQkEzUVFEZ3dCQ3lBRFJRMEJDd05BSUFBZ0JFRUNkR29oRFVFQUlRZEJBQ0VJQTBBZ0FpQUVJQWRxUVFKMGFpSUpJQUVnQjBFQ2RHb29BZ0FpQlVILy93TnhJZ29nRFNnQ0FDSUxRZi8vQTNFaUJtd2lERUVRZGlBS0lBdEJFSFlpRG13aUQwSC8vd054YWlBR0lBVkJFSFlpQm13aUVFSC8vd054YWlJUlFSQjBJZ29nREVILy93TnhjaUFJYWlJRklBa29BZ0FpQ1dvaUN6WUNBQ0FQUVJCMklCQkJFSFpxSUFZZ0Rtd2lCa0gvL3dOeGFpQVJRUkIyYWlJTVFZQ0FISEVnQmtHQWdIeHhhaUFNUWYvL0EzRnlJQVVnQ25NZ0NDQUtjM0lnQlhOQkgzWnFJQWtnQzNNZ0JTQUpjM0lnQzNOQkgzWnFJUWdnQjBFQmFpSUhJQU5IRFFBTElBSWdBeUFFYWtFQ2RHb2dDRFlDQUNBRVFRRnFJZ1FnQTBjTkFBc0xDNzREQVFsL0lBSWdBQ2dDQUNJRUlBRW9BZ0FpQTJzaUJUWUNBQ0FDSUFBb0FnUWlCaUFCS0FJRUlnZHJJZ2dnQkNBRElBVnpJQU1nQkhOeWMwRWZkaUlMYXlJRU5nSUVJQUlnQUNnQ0NDSURJQUVvQWdnaUNXc2lDaUFMSUFoRmNTQUdJQWNnQ0hNZ0JpQUhjM0p6UVI5MmNpSUhheUlHTmdJSUlBSWdCU0FBS0FJTUlBRW9BZ3dnQnlBS1JYRWdBeUFKSUFweklBTWdDWE55YzBFZmRuSnFheUlEUVI5MklnZHJOZ0lBSUFJZ0JDQUhJQVZGY1NJRmF6WUNCQ0FDSUFZZ0JTQUVSWEVpQldzMkFnZ2dBaUFEUWYvLy8vOEhjU0FGSUFaRmNXczJBZ3dnQWlBQUtBSVFJZ1FnQVNnQ0VDSURheUlGTmdJUUlBSWdBQ2dDRkNJR0lBRW9BaFFpQjJzaUNDQUVJQU1nQlhNZ0F5QUVjM0p6UVI5MklndHJJZ1EyQWhRZ0FpQUFLQUlZSWdNZ0FTZ0NHQ0lKYXlJS0lBc2dDRVZ4SUFZZ0J5QUljeUFHSUFkemNuTkJIM1p5SWdkcklnWTJBaGdnQWlBRklBQW9BaHdnQVNnQ0hDQUhJQXBGY1NBRElBa2dDbk1nQXlBSmMzSnpRUjkyY21wcklnQkJIM1lpQVdzMkFoQWdBaUFFSUFFZ0JVVnhJZ0ZyTmdJVUlBSWdCaUFCSUFSRmNTSUJhellDR0NBQ0lBQkIvLy8vL3dkeElBRWdCa1Z4YXpZQ0hBdndBZ0lDZndGK0FrQWdBa1VOQUNBQUlBRTZBQUFnQUNBQ2FpSURRUUZySUFFNkFBQWdBa0VEU1EwQUlBQWdBVG9BQWlBQUlBRTZBQUVnQTBFRGF5QUJPZ0FBSUFOQkFtc2dBVG9BQUNBQ1FRZEpEUUFnQUNBQk9nQURJQU5CQkdzZ0FUb0FBQ0FDUVFsSkRRQWdBRUVBSUFCclFRTnhJZ1JxSWdNZ0FVSC9BWEZCZ1lLRUNHd2lBRFlDQUNBRElBSWdCR3RCZkhFaUFtb2lBVUVFYXlBQU5nSUFJQUpCQ1VrTkFDQURJQUEyQWdnZ0F5QUFOZ0lFSUFGQkNHc2dBRFlDQUNBQlFReHJJQUEyQWdBZ0FrRVpTUTBBSUFNZ0FEWUNHQ0FESUFBMkFoUWdBeUFBTmdJUUlBTWdBRFlDRENBQlFSQnJJQUEyQWdBZ0FVRVVheUFBTmdJQUlBRkJHR3NnQURZQ0FDQUJRUnhySUFBMkFnQWdBaUFEUVFSeFFSaHlJZ0ZySWdKQklFa05BQ0FBclVLQmdJQ0FFSDRoQlNBQklBTnFJUUVEUUNBQklBVTNBeGdnQVNBRk53TVFJQUVnQlRjRENDQUJJQVUzQXdBZ0FVRWdhaUVCSUFKQklHc2lBa0VmU3cwQUN3c0x4QXNCRzM4akFFRkFhaUlCSkFBZ0FDQUJRU0JxSWhJUUNDQUFRU0JxSWhNZ0FSQUlJQUFnRXlBQUVBY2dBRUdBQVdvaUZDQUJLQUlNSWhVZ0FTZ0NMQ0lXYWlBQktBSW9JZ1FnQVNnQ0pDSUNJQUVvQWdBaUR5QUJLQUlnSWd0cUlnVWdDM01nQ3lBUGN5SVhjaUFGYzBFZmRtb2lBeUFCS0FJRUlnWnFJZ2NnQTNNZ0F5QUdjM0lnQjNNZ0FpQURRWDl6Y1hKQkgzWnFJZ2dnQVNnQ0NDSURhaUlKSUFoeklBTWdDSE55SUFseklBUWdDRUYvYzNGeVFSOTJhaUlJUVI5MklBVnFJZ28yQWdBZ0FDQUZJQXBCZjNOeFFSOTJJQWRxSWdVMkFvUUJJQUFnQnlBRlFYOXpjVUVmZGlBSmFpSUZOZ0tJQVNBQUlBaEIvLy8vL3dkeElBa2dCVUYvYzNGQkgzWnFOZ0tNQVNBQUlBRW9BaHdpR0NBQktBSThJaGxxSUFFb0FqZ2lCU0FCS0FJMElnY2dBU2dDRUNJTklBRW9BakFpQ0dvaURDQUljeUFJSUExeklocHlJQXh6UVI5MmFpSUtJQUVvQWhRaUNXb2lFQ0FLY3lBSklBcHpjaUFRY3lBSElBcEJmM054Y2tFZmRtb2lEaUFCS0FJWUlncHFJaEVnRG5NZ0NpQU9jM0lnRVhNZ0JTQU9RWDl6Y1hKQkgzWnFJZzVCSDNZZ0RHb2lHellDa0FFZ0FDQU1JQnRCZjNOeFFSOTJJQkJxSWd3MkFwUUJJQUFnRUNBTVFYOXpjVUVmZGlBUmFpSU1OZ0tZQVNBQUlBNUIvLy8vL3dkeElCRWdERUYvYzNGQkgzWnFOZ0tjQVNBQklCZ2dHU0FLSUFVZ0NpQUZheUlNY3lBRklBcHpjbk5CSDNZZ0NTQUhJQWtnQjJzaUJYTWdCeUFKYzNKelFSOTJJQTBnQ0NBTklBaHJJZ2R6SUJweWMwRWZkaUlJSUFWRmNYSWlDU0FNUlhGeWFtc2lDa0gvLy8vL0IzRWdDa0VmZGlJS0lBZEZjU0lOSUFVZ0NHc2lCVVZ4SWdnZ0RDQUpheUlKUlhGck5nSThJQUVnQ1NBSWF6WUNPQ0FCSUFVZ0RXczJBalFnQVNBSElBcHJOZ0l3SUFFZ0ZTQVdJQU1nQkNBRElBUnJJZ1Z6SUFNZ0JITnljMEVmZGlBR0lBSWdCaUFDYXlJRWN5QUNJQVp6Y25OQkgzWWdEeUFMSUE4Z0Myc2lBbk1nRjNKelFSOTJJZ3NnQkVWeGNpSUdJQVZGY1hKcWF5SURRZi8vLy84SGNTQURRUjkySWdNZ0FrVnhJZ2NnQkNBTGF5SUVSWEVpQ3lBRklBWnJJZ1pGY1dzMkFpd2dBU0FHSUF0ck5nSW9JQUVnQkNBSGF6WUNKQ0FCSUFJZ0EyczJBaUFnQUNBQVFlQUFhaUlMRUFnZ0FFRkFheUlKSUFFUUNDQUxJQlFnQ3hBTklBRWdBU2dDREVFQmRDQUJLQUlJSWdZZ0FTZ0NCQ0lDSUFFb0FnQWlCVUVmZG1vaUF5QUNhaUlFSUFOeklBSWdBM055SUFSeklBSWdBMEYvYzNGeVFSOTJhaUlESUFacUlnSWdBM01nQXlBR2MzSWdBbk1nQmlBRFFYOXpjWEpCSDNaeUlnZEJIM1lnQlVFQmRDSUdjaUFCS0FJZ0lnTnJJZ1VnQjBILy8vLy9CM0VnQVNnQ0xDQUNJQUVvQWlnaUIyc2lDQ0FIY3lBQ0lBZHpjaUFDYzBFZmRpQUVJQUVvQWlRaUFtc2lCeUFDY3lBQ0lBUnpjaUFFYzBFZmRpQURJQVZ6SUFNZ0JuTnlJQVp6UVI5MklnUWdCMFZ4Y2lJQ0lBaEZjWEpxYXlJR1FSOTJJZ05yTmdJQUlBRWdCeUFFYXlJRUlBTWdCVVZ4SWdOck5nSUVJQUVnQ0NBQ2F5SUNJQU1nQkVWeElnUnJOZ0lJSUFFZ0JrSC8vLy8vQjNFZ0JDQUNSWEZyTmdJTUlBRWdBU2dDSEVFQmRDQUJLQUlZSWdZZ0FTZ0NGQ0lDSUFFb0FoQWlCVUVmZG1vaUF5QUNhaUlFSUFOeklBSWdBM055SUFSeklBSWdBMEYvYzNGeVFSOTJhaUlESUFacUlnSWdBM01nQXlBR2MzSWdBbk1nQmlBRFFYOXpjWEpCSDNaeUlnZEIvLy8vL3dkeElBRW9BandnQWlBQktBSTRJZ1pySWdNZ0JuTWdBaUFHYzNJZ0FuTkJIM1lnQkNBQktBSTBJZ0pySWdZZ0FuTWdBaUFFYzNJZ0JITkJIM1lnQlVFQmRDSUVJQWRCSDNaeUlBRW9BakFpQW1zaUJTQUNjeUFDSUFSemNpQUVjMEVmZGlJRUlBWkZjWElpQWlBRFJYRnlhbXNpQjBILy8vLy9CM0VnQjBFZmRpSUhJQVZGY1NJSUlBWWdCR3NpQkVWeElnWWdBeUFDYXlJQ1JYRnJOZ0ljSUFFZ0FpQUdhellDR0NBQklBUWdDR3MyQWhRZ0FTQUZJQWRyTmdJUUlCSWdGQ0FURUFZZ0FTQUxJQUFRQmlBU0lBRWdDUkFHSUFGQlFHc2tBQXRnQVFaL0EwQWdBaUFGUVFKMElnTnFJQUVnQTJvb0FnQWlCeUFBSUFOcUtBSUFJZ2dnQkdvaUEyb2lCallDQUNBRElBWnpJQU1nQjNOeUlBWnpJQU1nQkhNZ0JDQUljM0lnQTNOeVFSOTJJUVFnQlVFQmFpSUZRUVJIRFFBTElBUUxrUWNCRTM4akFFR0FBV3NpQWlRQUlBSWdBU2dDTENJT0lBRW9BZ3dpRUdvZ0FTZ0NDQ0lFSUFFb0FnUWlCU0FCS0FJZ0lnc2dBU2dDQUNJSWFpSUhJQWh6SUFnZ0MzTWlFWElnQjNOQkgzWnFJZ01nQVNnQ0pDSU1haUlHSUFOeklBTWdESE55SUFaeklBVWdBMEYvYzNGeVFSOTJhaUlESUFFb0FpZ2lDbW9pQ1NBRGN5QURJQXB6Y2lBSmN5QUVJQU5CZjNOeGNrRWZkbW9pQTBFZmRpQUhhaUlOTmdJQUlBSWdCeUFOUVg5emNVRWZkaUFHYWlJSE5nSUVJQUlnQmlBSFFYOXpjVUVmZGlBSmFpSUhOZ0lJSUFJZ0EwSC8vLy8vQjNFZ0NTQUhRWDl6Y1VFZmRtbzJBZ3dnQVNnQ1BDRVNJQUVvQWh3aEV5QUJLQUk0SVFjZ0FTZ0NHQ0VESUFFb0FqQWhEeUFCS0FJUUlRWWdBU2dDTkNFSklBRW9BaFFoRFNBQ0lBNGdFQ0FLSUFRZ0NpQUVheUlPY3lBRUlBcHpjbk5CSDNZZ0RDQUZJQXdnQldzaUJITWdCU0FNYzNKelFSOTJJQXNnQ0NBTElBaHJJZ3h6SUJGeWMwRWZkaUlGSUFSRmNYSWlDQ0FPUlhGeWFtc2lDa0gvLy8vL0IzRWdDa0VmZGlJS0lBeEZjU0lMSUFRZ0JXc2lCRVZ4SWdVZ0RpQUlheUlJUlhGck5nSXNJQUlnQ0NBRmF6WUNLQ0FDSUFRZ0MyczJBaVFnQWlBUElBWnJJZ1FnRWlBVElBY2dBeUFISUFOcklnVnpJQU1nQjNOeWMwRWZkaUFKSUEwZ0NTQU5heUlJY3lBSklBMXpjbk5CSDNZZ0R5QUdJQTl6SWdzZ0JDQUdjM0p6UVI5MklnNGdDRVZ4Y2lJUUlBVkZjWEpxYXlJUlFSOTJJaFJyTmdJd0lBSWdDQ0FPYXlJSUlCUWdCRVZ4SWdSck5nSTBJQUlnQlNBUWF5SUZJQVFnQ0VWeElnUnJOZ0k0SUFJZ0VVSC8vLy8vQjNFZ0JDQUZSWEZyTmdJOElBSWdFaUFUYWlBSElBTWdDU0FOSUFZZ0JpQVBhaUlFY3lBTGNpQUVjMEVmZG1vaUJtb2lCU0FHY3lBR0lBbHpjaUFGY3lBTklBWkJmM054Y2tFZmRtb2lCbW9pQ1NBR2N5QUdJQWR6Y2lBSmN5QURJQVpCZjNOeGNrRWZkbW9pQjBFZmRpQUVhaUlETmdJUUlBSWdCQ0FEUVg5emNVRWZkaUFGYWlJRE5nSVVJQUlnQlNBRFFYOXpjVUVmZGlBSmFpSUROZ0lZSUFJZ0IwSC8vLy8vQjNFZ0NTQURRWDl6Y1VFZmRtbzJBaHdnQWlBTUlBcHJOZ0lnSUFGQjRBQnFJQUZCZ0FGcUlBSkI0QUJxRUFZZ0FpQUJRVUJyS0FJQU5nSkFJQUlnQVNnQ1JEWUNSQ0FDSUFFb0FrZzJBa2dnQWlBQktBSk1OZ0pNSUFJZ0FTZ0NVRFlDVUNBQ0lBRW9BbFEyQWxRZ0FpQUJLQUpZTmdKWUlBSWdBU2dDWERZQ1hDQUFJQUlnQVJBV0lBSkJnQUZxSkFBTHZ3SUJCWDhnQUNBQ1FYaHhhaUlESUFNb0FnQWdBU0FDUVFkeElnTkJBM1FpQkhSQkFDQURRUVJKSWdZYklnTkJBWFlnQTNOQm9zU0lrUUp4SWdVZ0EzTWlBeUFGUVFGMGN5SUZJQU5CQW5aelFZeVlzT0FBY1NJRElBVnpJZ1VnQTBFQ2RITWlBeUFGUVFSMmMwSHdnY0FIY1NJRklBTnpJZ2NnQlVFRWRITWlBeUFIUVFoMmMwR0EvZ054SWdVZ0EwSC8vd054YzBFQUlBRWdCRUVnYTNRZ0Joc2lBVUVCZGlBQmMwR2l4SWlSQW5FaUJDQUJjeUlCSUFSQkFYUnpJZ1FnQVVFQ2RuTkJqSml3NEFCeElnRWdCSE1pQkNBQlFRSjBjeUlCSUFSQkJIWnpRZkNCd0FkeElnUWdBWE1pQmlBRVFRUjBjeUlCSUFaQkNIWnpRWUQrQTNFaUJDQUJjMEVRZEhKek5nSUFJQUFnQWtFRWNrRjhjV29pQUNBQUtBSUFJQUZCZ0lCOGNTQUVRUWgwY3lBRlFRaDBJQU56UVJCMmNuTTJBZ0FMeXdFQkJYOENRQ0FCUlEwQUlBRkJBV3RCQjA4RVFDQUJRWGh4SVFZRFFDQUFJQUpCQW5RaUEycEJBRFlDQUNBQUlBTkJCSEpxUVFBMkFnQWdBQ0FEUVFoeWFrRUFOZ0lBSUFBZ0EwRU1jbXBCQURZQ0FDQUFJQU5CRUhKcVFRQTJBZ0FnQUNBRFFSUnlha0VBTmdJQUlBQWdBMEVZY21wQkFEWUNBQ0FBSUFOQkhISnFRUUEyQWdBZ0FrRUlhaUVDSUFWQkNHb2lCU0FHUncwQUN3c2dBVUVIY1NJQlJRMEFBMEFnQUNBQ1FRSjBha0VBTmdJQUlBSkJBV29oQWlBRVFRRnFJZ1FnQVVjTkFBc0xDNmdIQVJ0L0lBQW9BbHdoQ2lBQUtBSllJUmdnQUNnQ1ZDRVpJQUFvQWxBaEdpQUFLQUpNSVFzZ0FDZ0NTQ0ViSUFBb0FrUWhIQ0FBUVVCcktBSUFJUjBnQUNnQ1BDRUdJQUFvQWpnaEJ5QUFLQUkwSVFnZ0FDZ0NNQ0VKSUFBb0Fpd2hEQ0FBS0FJb0lRMGdBQ2dDSkNFT0lBQW9BaUFoRHlBQUtBSWNJUkFnQUNnQ0dDRVJJQUFvQWhRaEVpQUFLQUlRSVJNZ0FDZ0NEQ0VVSUFBb0FnZ2hGU0FBS0FJRUlSWWdBQ2dDQUNFWFFRRWhIZ05BSUFKQkFXc2lBa0VmZGtFQmF5SUVJQUFnSGtIZ0FHeHFJZ1VvQWdBZ0YzTnhJQmR6SVJjZ0JTZ0NYQ0FLY3lBRWNTQUtjeUVLSUFVb0Frd2dDM01nQkhFZ0MzTWhDeUFGS0FJOElBWnpJQVJ4SUFaeklRWWdCU2dDTENBTWN5QUVjU0FNY3lFTUlBVW9BaHdnRUhNZ0JIRWdFSE1oRUNBRktBSU1JQlJ6SUFSeElCUnpJUlFnQlNnQ1dDQVljeUFFY1NBWWN5RVlJQVVvQWtnZ0czTWdCSEVnRzNNaEd5QUZLQUk0SUFkeklBUnhJQWR6SVFjZ0JTZ0NLQ0FOY3lBRWNTQU5jeUVOSUFVb0FoZ2dFWE1nQkhFZ0VYTWhFU0FGS0FJSUlCVnpJQVJ4SUJWeklSVWdCU2dDVkNBWmN5QUVjU0FaY3lFWklBVW9Ba1FnSEhNZ0JIRWdISE1oSENBRktBSTBJQWh6SUFSeElBaHpJUWdnQlNnQ0pDQU9jeUFFY1NBT2N5RU9JQVVvQWhRZ0VuTWdCSEVnRW5NaEVpQUZLQUlFSUJaeklBUnhJQlp6SVJZZ0JTZ0NVQ0FhY3lBRWNTQWFjeUVhSUFWQlFHc29BZ0FnSFhNZ0JIRWdIWE1oSFNBRktBSXdJQWx6SUFSeElBbHpJUWtnQlNnQ0lDQVBjeUFFY1NBUGN5RVBJQVVvQWhBZ0UzTWdCSEVnRTNNaEV5QWVRUUZxSWg1QkVFY05BQXNnQVNBRElCaHpOZ0pZSUFFZ0F5QVpjellDVkNBQklBTWdHbk0yQWxBZ0FTQURJQnR6TmdKSUlBRWdBeUFjY3pZQ1JDQUJRVUJySUFNZ0hYTTJBZ0FnQVNBR0lCQnpJQU54SWdBZ0JuTTJBandnQVNBSElCRnpJQU54SWdJZ0IzTTJBamdnQVNBSUlCSnpJQU54SWdRZ0NITTJBalFnQVNBSklCTnpJQU54SWdVZ0NYTTJBakFnQVNBTUlCUnpJQU54SWdZZ0RITTJBaXdnQVNBTklCVnpJQU54SWdjZ0RYTTJBaWdnQVNBT0lCWnpJQU54SWdnZ0RuTTJBaVFnQVNBUElCZHpJQU54SWdrZ0QzTTJBaUFnQVNBQUlCQnpOZ0ljSUFFZ0FpQVJjellDR0NBQklBUWdFbk0yQWhRZ0FTQUZJQk56TmdJUUlBRWdCaUFVY3pZQ0RDQUJJQWNnRlhNMkFnZ2dBU0FJSUJaek5nSUVJQUVnQ1NBWGN6WUNBQ0FCUWYvLy8vOEhJQXBySUFweklBTnhJQXB6TmdKY0lBRkIvLy8vL3djZ0Myc2dDM01nQTNFZ0MzTTJBa3dML1RVQlAzOUJvSVlDSVJFRFFDQUFLQUxFQVNFRElBQW9BcHdCSVFFZ0FDZ0NkQ0VFSUFBb0Frd2hBaUFBS0FJa0lRVWdBQ2dDdkFFaEdDQUFLQUpzSVFvZ0FDZ0NSQ0VTSUFBb0Fod2hEeUFBS0FLb0FTRVpJQUFvQW9BQklSMGdBQ2dDV0NFVElBQW9BZ2doR2lBQUtBS3dBU0VWSUFBb0FvZ0JJU0lnQUNnQ1lDRUhJQUFvQWpnaEl5QUFLQUlRSVNRZ0FDZ0NsQUVoRUNBQUtBS2tBU0VySUFBb0Fud2hMQ0FBS0FKVUlSc2dBQ2dDTENFdElBQW9BZ1FoQmlBQUlBQW9BcmdCSWk0Z0FDZ0NrQUVpSlNBQUtBSm9JaVlnQUNnQ1FDSW5JQUFvQWhnaUZuTnpjM01pQ3lBQUtBS3NBU0lvSUFBb0FvUUJJaFFnQUNnQ1hDSXZJQUFvQWpRaU1DQUFLQUlNSWpKemMzTnpJZzF6SWd3Z0FDZ0NaQ0lJYzBFV2R5SU9JQUFvQXFBQklqTWdBQ2dDZUNJMElBQW9BbEFpS1NBQUtBSW9JalVnQUNnQ0FDSUpjM056Y3lJMklBQW9BclFCSWpjZ0FDZ0NqQUVpT0NBQUtBSThJamtnQUNnQ0ZDSTZjeUFJYzNOekloZEJBWGR6SWdnZ0FDZ0NNQ0l4YzBFV2R5SWVRWDl6Y1NBSklBQW9Bc0FCSWh3Z0FDZ0NtQUVpS2lBQUtBSndJanNnQUNnQ1NDSThJQUFvQWlBaVBYTnpjM01pSHlBTlFRRjNjeUlOY3lJZ2N5SWhOZ0lBSUJFb0FnQWhQaUFBSUJ3Z0N5QXJJQ3dnR3lBR0lDMXpjM056SWo5QkFYZHpJZ3R6UVFkM0lod2dIaUFnUVg5emNYTTJBc0FCSUFBZ0VDQVhJQjl6SWdselFRdDNJaGNnSUNBY1FYOXpjWE0yQXBRQklBQWdIQ0FYUVg5emNTQU9jellDWkNBQUlCY2dEa0YvYzNFZ0huTTJBakFnQUNBSElCa2dIU0FUSUJvZ01YTnpjM01pRGlBWUlCQWdDaUFQSUJKemMzTnpJaGRCQVhkekloQnpRUlYzSWg0Z01DQS9JQlVnSWlBSElDTWdKSE56YzNNaU1YTWlCM05CRm5jaUlFRi9jM0VnQmlBT0lBTWdBU0FFSUFJZ0JYTnpjM01pTUhNaURuTWlISE1pSHpZQ0JDQUFJQ0VnUG5NMkFnQWdFU2dDQkNFaElBQWdBeUFYSURaeklnWnpRUWQzSWhjZ0lDQWNRWDl6Y1hNMkFzUUJJQUFnSlNBeElEQkJBWGR6SWdOelFRcDNJaVVnSENBWFFYOXpjWE0yQXBBQklBQWdGeUFsUVg5emNTQWVjellDWUNBQUlDVWdIa0YvYzNFZ0lITTJBalFnQUNBT0lCdHpRUUozSWhzZ0RDQTNjMEVmZHlJZUlBY2dGSE5CRjNjaUlFRi9jM0Z6TmdLMEFTQUFJQXNnUEhOQkNuY2lIQ0FnSUJ0QmYzTnhjellDaEFFZ0FDQURJQlp6UVE1M0loY2dHeUFjUVg5emNYTTJBbFFnQUNBTklDbHpRUUYzSWhzZ0VDQVZjMEVlZHlJVklBZ2dIWE5CRm5jaUhVRi9jM0Z6TmdLd0FTQUFJQUlnQm5OQkNuY2lBaUFkSUJ0QmYzTnhjellDZ0FFZ0FDQUpJQTl6UVE1M0lnOGdHeUFDUVg5emNYTTJBbEFnQUNBY0lCZEJmM054SUI1ek5nSklJQUFnRnlBZVFYOXpjU0FnY3pZQ0dDQUFJQWNnTW5OQkFYY2lHeUFKSUFwelFRMTNJZ29nRUNBamMwRURkeUlqUVg5emNYTTJBcUFCSUFBZ0ZTQUNJQTlCZjNOeGN6WUNUQ0FBSUE4Z0ZVRi9jM0VnSFhNMkFod2dBQ0FJSUJweklnSWdBeUFtYzBFTWR5SVBJQXdnT1hOQkEzY2lIVUYvYzNGek5nS2tBU0FBSUEwZ00zTkJDWGNpR2lBaklCdEJmM054Y3pZQ21BRWdBQ0FMSUNwelFRUjNJaFVnR3lBYVFYOXpjWE0yQW13Z0FDQWFJQlZCZjNOeElBcHpOZ0k0SUFBZ0ZTQUtRWDl6Y1NBamN6WUNEQ0FBSUI4Z0lYTTJBZ1FnQUNBT0lDdHpRUWwzSWdvZ0hTQUNRWDl6Y1hNMkFwd0JJQUFnQVNBR2MwRUVkeUlCSUFJZ0NrRi9jM0Z6TmdKb0lBQWdEeUFLSUFGQmYzTnhjellDUENBQUlCMGdBU0FQUVg5emNYTTJBZ2dnQUNBRklBWnpRUTUzSWdFZ0NDQVRjMEVGZHlJQ0lBMGdOWE5CRW5jaUJVRi9jM0Z6TmdJb0lBQWdEQ0E0YzBFSWR5SUtJQUpCZjNOeElBVnpOZ0pZSUFBZ0FpQURJQzV6UVJ4M0lnOGdDa0YvYzNGek5nS01BU0FBSUFvZ0FTQVBRWDl6Y1hNaUFqWUN1QUVnQUNBUElBVWdBVUYvYzNGeklnRTJBaVFnQUNBTElEMXpRUTEzSWdVZ0J5QXZjMEVGZHlJS0lBNGdMWE5CRW5jaUQwRi9jM0Z6SWgwMkFpd2dBQ0FRSUNKelFRZDNJaE1nQ2tGL2MzRWdEM01pR2pZQ1hDQUFJQWtnR0hOQkhIY2lHQ0FUUVg5emNTQUtjeUlLTmdLSUFTQUFJQVVnR0VGL2MzRWdFM01pRXpZQ3ZBRWdBQ0FQSUFWQmYzTnhJQmh6SWdVMkFpQWdBQ0FRSUNSelFSOTNJaEFnQkNBR2MwRVVkeUlHSUFrZ0VuTkJISGNpQ1VGL2MzRnpJZ1EyQW53Z0FDQU9JQ3h6UVJWM0lnNGdCa0YvYzNFZ0NYTWlHRFlDcUFFZ0FDQURJQ2R6UVJ0M0lnTWdEU0EwYzBFVWR5SU5JQXNnTzNOQkUzY2lDMEYvYzNGekloSTJBcXdCSUFBZ0RDQTZjMEVmZHlJTUlBc2dBMEYvYzNGeklnODJBbmdnQUNBSUlCbHpRUUYzSWdnZ0NTQVFRWDl6Y1hNaUNUWUNkQ0FBSUJBZ0NFRi9jM0VnRG5NMkFrUWdBQ0FHSUFnZ0RrRi9jM0Z6SWhrMkFoQWdBQ0FISUNoelFRRjNJZ2dnQXlBTVFYOXpjWE1pQXpZQ2NDQUFJQXdnQ0VGL2MzRWdEWE1pRlRZQ1FDQUFJQXNnQ0NBTlFYOXpjWE1pSWpZQ0ZDQUFLQUtjQVNFaklBQW9Ba3doSkNBQUtBTEVBU0VySUFBb0FtZ2hMQ0FBS0FJY0lSc2dBQ2dDa0FFaExTQUFLQUpZSVI0Z0FDZ0NEQ0VnSUFBb0FqQWhIQ0FBS0FLTUFTRVhJQUFvQWpnaEVDQUFLQUswQVNFbElBQW9BbVFoTGlBQUtBS2tBU0VtSUFBb0FsQWhKeUFBS0FJRUlRNGdBQ0FBS0FKRUlpOGdBQ2dDYkNJd0lBQW9BaGdpTWlBQUtBS1VBU0l6YzNNZ0FuTnpJZ3NnQUNnQ0NDSTBJQUFvQW9BQklpa2dBQ2dDTkNJMWMzTWdHbk1nRW5NaURYTWlEQ0FBS0FJOElnaHpRUlozSWdjZ0FDZ0NLQ0kySUFBb0FxQUJJamNnQUNnQ1ZDSTRJQUFvQWdBaUZuTnpjeUFFY3lJNUlBQW9BckFCSWpvZ0FDZ0NZQ0l4Y3lBSWN5QUtjeUFpY3lJVVFRRjNjeUlJSUFBb0FvUUJJaXB6UVJaM0lnWkJmM054SUJZZ0FDZ0NtQUVpT3lBQUtBSklJandnQUNnQ3dBRWlQWE56SUFGeklBbHpJaDhnRFVFQmQzTWlEWE1pRm5NaUlUWUNBQ0FSUVFocUlpZ29BZ0FoUGlBQUlCTWdGQ0FmY3lJUmMwRUxkeUlVSUFkQmYzTnhJQVp6TmdLRUFTQUFJQllnQ1NBTElDWWdEaUFuYzNNZ0hYTWdEM01pSDBFQmQzTWlDM05CQjNjaUNVRi9jM0VnRkhNMkFyd0JJQUFnQ1NBVVFYOXpjU0FIY3pZQ1BDQUFJQWtnQmlBV1FYOXpjWE0yQW5RZ0FDQVFJQjRnSUNBY0lDcHpjM01nR0hNaUJ5QXNJQnNnTFhOeklCTnpJQlZ6SWdaQkFYZHpJZ2x6UVJWM0loTWdLU0FmSUJjZ0VDQWxJQzV6YzNNZ0dYTWlLbk1pRUhOQkZuY2lGa0YvYzNFZ0RpQUhJQ01nSkNBcmMzTWdCWE1nQTNNaUtYTWlCM01pRkhNaUh6WUNCQ0FBSUNFZ1BuTTJBZ0FnS0NnQ0JDRWhJQUFnQWlBcUlDbEJBWGR6SWc1elFRcDNJZ0lnRTBGL2MzRWdGbk0yQW9BQklBQWdBaUFVSUFNZ0JpQTVjeUlHYzBFSGR5SURRWDl6Y1hNMkFyZ0JJQUFnQXlBQ1FYOXpjU0FUY3pZQ09DQUFJQTRnTTNOQkRuY2lBaUFISUNaelFRSjNJaE1nQ3lBOGMwRUtkeUltUVg5emNYTTJBcVFCSUFBZ0F5QVdJQlJCZjNOeGN6WUNjQ0FBSUNZZ0VDQWFjMEVYZHlJRElCTkJmM054Y3pZQ1hDQUFJQUlnRENBaWMwRWZkeUlhUVg5emNTQURjellDbEFFZ0FDQWFJQU5CZjNOeElCTnpOZ0lVSUFBZ0VTQXRjMEVPZHlJRElBMGdOM05CQVhjaUV5QUdJQ1J6UVFwM0lpSkJmM054Y3pZQ29BRWdBQ0FtSUFKQmYzTnhJQnB6TmdKSUlBQWdJaUFJSUI1elFSWjNJZ0lnRTBGL2MzRnpOZ0pZSUFBZ0F5QUpJQmx6UVI1M0lobEJmM054SUFKek5nS1FBU0FBSUJrZ0FrRi9jM0VnRTNNMkFoQWdBQ0FRSURWelFRRjNJZ0lnRVNBc2MwRU5keUlUSUFrZ0pYTkJBM2NpR2tGL2MzRnpOZ0o4SUFBZ0dTQWlJQU5CZjNOeGN6WUNUQ0FBSUFRZ0RYTkJDWGNpQXlBQklBdHpRUVIzSWdGQmYzTnhJQk56TmdLMEFTQUFJQUVnRTBGL2MzRWdHbk0yQWpRZ0FDQUJJQUlnQTBGL2MzRnpOZ0pvSUFBZ0h5QWhjellDQkNBQUlBZ2dISE1pQVNBT0lEQnpRUXgzSWdRZ0RDQTZjMEVEZHlJWlFYOXpjWE0yQW5nZ0FDQWFJQUpCZjNOeElBTnpOZ0lrSUFBZ0dTQUZJQVp6UVFSM0lnTWdCRUYvYzNGek5nSXdJQUFnQkNBSElBOXpRUWwzSWdJZ0EwRi9jM0Z6TmdLd0FTQUFJQU1nQVNBQ1FYOXpjWE0yQW13Z0FDQUdJQ3R6UVE1M0lnTWdDQ0FnYzBFRmR5SUVJQTBnT0hOQkVuY2lCVUYvYzNGek5nSlVJQUFnR1NBQlFYOXpjU0FDY3pZQ0lDQUFJQW9nREhOQkNIY2lBU0FFUVg5emNTQUZjellDRENBQUlBUWdEaUF2YzBFY2R5SUNJQUZCZjNOeGN6WUNpQUVnQUNBQklBTWdBa0YvYzNGeklnRTJBa1FnQUNBQ0lBVWdBMEYvYzNGeklnTTJBc1FCSUFBZ0VDQTBjMEVGZHlJRUlCRWdGWE5CSEhjaUFpQUpJQmR6UVFkM0lnVkJmM054Y3lJS05nS01BU0FBSUFzZ1BYTkJEWGNpRHlBRUlBY2dKM05CRW5jaUdVRi9jM0Z6SWhNMkFsQWdBQ0FGSUFSQmYzTnhJQmx6SWdRMkFnZ2dBQ0FQSUFKQmYzTnhJQVZ6SWdVMkFrQWdBQ0FaSUE5QmYzTnhJQUp6SWdJMkFzQUJJQUFnQ1NBdWMwRWZkeUlKSUFZZ0kzTkJGSGNpQmlBUklCdHpRUngzSWhGQmYzTnhjeUlQTmdJc0lBQWdCeUFkYzBFVmR5SUhJQVpCZjNOeElCRnpJaGsyQXFnQklBQWdCaUFJSUJoelFRRjNJZ2dnQjBGL2MzRnpJaGcyQW1RZ0FDQVJJQWxCZjNOeElBaHpJZ1kyQXB3QklBQWdDU0FJUVg5emNTQUhjellDSENBQUlBNGdNbk5CRzNjaUVTQU5JRFp6UVJSM0lnZ2dDeUE3YzBFVGR5SU5RWDl6Y1hNaUhUWUNyQUVnQUNBTUlERnpRUjkzSWd3Z0RTQVJRWDl6Y1hNaUdqWUNLQ0FBSUEwZ0VDQVNjMEVCZHlJTElBaEJmM054Y3lJU05nSmdJQUFnRVNBTVFYOXpjU0FMY3lJVk5nS1lBU0FBSUF3Z0MwRi9jM0VnQ0hNaUlqWUNHQ0FBS0FJZ0lTTWdBQ2dDVENFa0lBQW9BbkFoS3lBQUtBSnNJU3dnQUNnQ2tBRWhHeUFBS0FLNEFTRXRJQUFvQWd3aEhpQUFLQUkwSVNBZ0FDZ0NoQUVoSENBQUtBS0lBU0VYSUFBb0FyUUJJUkFnQUNnQ0ZDRWxJQUFvQWp3aExpQUFLQUo0SVNZZ0FDZ0NvQUVoSnlBQUtBSUVJUTRnQUNBQUtBSWNJaThnQUNnQ2FDSXdJQUFvQXBRQklqSWdBQ2dDdkFFaU0zTnpJQUZ6Y3lJTklBQW9BakFpTkNBQUtBSllJaWtnQUNnQ2dBRWlOWE56SUFSeklCMXpJZ2h6SWhFZ0FDZ0NzQUVpREhOQkZuY2lDU0FBS0FKVUlqWWdBQ2dDZkNJM0lBQW9BcVFCSWpnZ0FDZ0NBQ0lMYzNOeklBOXpJamtnQUNnQ0VDSTZJQUFvQWpnaU1YTWdESE1nQ25NZ0VuTWlGRUVCZDNNaURDQUFLQUpjSWlwelFSWjNJZ2RCZjNOeElBc2dBQ2dDSkNJN0lBQW9Ba2dpUENBQUtBSjBJajF6Y3lBRGN5QUdjeUlmSUFoQkFYZHpJZ2h6SWhaeklpRTJBZ0FnS0VFSWFpSW9LQUlBSVQ0Z0FDQUdJQTBnSmlBT0lDZHpjeUFUY3lBYWN5SS9RUUYzY3lJTmMwRUhkeUlHSUFVZ0ZDQWZjeUlMYzBFTGR5SVVRWDl6Y1NBSmN6WUNzQUVnQUNBVUlBbEJmM054SUFkek5nSmNJQUFnQmlBSElCWkJmM054Y3pZQ25BRWdBQ0FXSUFaQmYzTnhJQlJ6TmdKQUlBQWdFQ0FlSUNBZ0hDQXFjM056SUJseklnY2dMQ0FiSUMxemN5QUZjeUFpY3lJR1FRRjNjeUlKYzBFVmR5SUZJQ2tnUHlBWElCQWdKU0F1YzNOeklCaHpJaXB6SWhCelFSWjNJaFpCZjNOeElBNGdCeUFqSUNRZ0szTnpJQUp6SUJWeklpbHpJZ2R6SWhSekloODJBZ1FnQUNBaElENXpOZ0lBSUNnb0FnUWhJU0FBSUJVZ0JpQTVjeUlPYzBFSGR5SVZJQUVnS2lBcFFRRjNjeUlHYzBFS2R5SUJRWDl6Y1NBRmN6WUN0QUVnQUNBQklBVkJmM054SUJaek5nSllJQUFnRlNBV0lCUkJmM054Y3pZQ21BRWdBQ0FCSUJRZ0ZVRi9jM0Z6TmdKRUlBQWdCaUF6YzBFT2R5SUJJQWNnSm5OQkFuY2lCU0FOSUR4elFRcDNJaFZCZjNOeGN6WUNlQ0FBSUFRZ0VITkJGM2NpQkNBQklCRWdFbk5CSDNjaUVrRi9jM0Z6TmdLOEFTQUFJQklnQkVGL2MzRWdCWE0yQW1BZ0FDQVZJQVFnQlVGL2MzRnpOZ0lJSUFBZ0N5QXRjMEVPZHlJRUlBZ2dOM05CQVhjaUJTQU9JQ1J6UVFwM0lpUkJmM054Y3pZQ2ZDQUFJQlVnQVVGL2MzRWdFbk0yQWtnZ0FDQU1JQjV6UVJaM0lnRWdCQ0FKSUJoelFSNTNJaGhCZjNOeGN6WUN1QUVnQUNBWUlBRkJmM054SUFWek5nSmtJQUFnSkNBQklBVkJmM054Y3pZQ0RDQUFJQmdnSkNBRVFYOXpjWE0yQWt3Z0FDQUpJQ1Z6UVFOM0lnRWdBeUFOYzBFRWR5SURJQXNnTEhOQkRYY2lCRUYvYzNGek5nS0FBU0FBSUJBZ05YTkJBWGNpQlNBRUlBRkJmM054Y3pZQ0xDQUFJQWdnRDNOQkNYY2lHQ0FCSUFWQmYzTnhjellDeEFFZ0FDQURJQVVnR0VGL2MzRnpOZ0pzSUFBZ0dDQURRWDl6Y1NBRWN6WUNGQ0FBSUI4Z0lYTTJBZ1FnQUNBUklEcHpRUU4zSWdNZ0FpQU9jMEVFZHlJQklBWWdNSE5CREhjaUJFRi9jM0Z6TmdLRUFTQUFJQXdnSEhNaUFpQUVJQU5CZjNOeGN6WUNLQ0FBSUFRZ0J5QWFjMEVKZHlJRklBRkJmM054Y3pZQ0VDQUFJQUVnQWlBRlFYOXpjWE0yQW1nZ0FDQURJQUpCZjNOeElBVnpOZ0xBQVNBQUlBNGdLM05CRG5jaUF5QU1JQ0J6UVFWM0lnRWdDQ0E0YzBFU2R5SUVRWDl6Y1hNMkFxUUJJQUFnQmlBdmMwRWNkeUlDSUFvZ0VYTkJDSGNpQlVGL2MzRWdBWE0yQW93QklBQWdCU0FCUVg5emNTQUVjellDTkNBQUlBVWdBeUFDUVg5emNYTWlBVFlDSENBQUlBSWdCQ0FEUVg5emNYTWlCRFlDY0NBQUlBMGdQWE5CRFhjaUF5QVFJRFJ6UVFWM0lnSWdCeUFuYzBFU2R5SUZRWDl6Y1hNaUdEWUNvQUVnQUNBSklCZHpRUWQzSWdvZ0FrRi9jM0VnQlhNaUVqWUNNQ0FBSUFJZ0N5QWljMEVjZHlJUElBcEJmM054Y3lJQ05nS0lBU0FBSUFNZ0QwRi9jM0VnQ25NaUNqWUNHQ0FBSUFVZ0EwRi9jM0VnRDNNaUJUWUNkQ0FBSUFrZ0xuTkJIM2NpQ1NBT0lDTnpRUlIzSWc0Z0N5QWJjMEVjZHlJTFFYOXpjWE1pRHpZQ1VDQUFJQWNnRTNOQkZYY2lCeUFPUVg5emNTQUxjeUlUTmdLb0FTQUFJQTRnRENBWmMwRUJkeUlNSUFkQmYzTnhjeUlaTmdJOElBQWdDU0FNUVg5emNTQUhjellDa0FFZ0FDQUdJREp6UVJ0M0lnY2dDQ0EyYzBFVWR5SUlJQTBnTzNOQkUzY2lEVUYvYzNGeklobzJBcXdCSUFBZ0VTQXhjMEVmZHlJUklBMGdCMEYvYzNGekloVTJBbFFnQUNBTElBbEJmM054SUF4eklnczJBaUFnQUNBUklCQWdIWE5CQVhjaURFRi9jM0VnQ0hNaUhUWUNsQUVnQUNBTklBd2dDRUYvYzNGeklnNDJBamdnQUNBSElCRkJmM054SUF4eklpSTJBaVFnQUNnQ3dBRWhJeUFBS0FKTUlTUWdBQ2dDbUFFaEt5QUFLQUpvSVN3Z0FDZ0N1QUVoR3lBQUtBSkVJUzBnQUNnQ05DRWVJQUFvQW9BQklTQWdBQ2dDWENFY0lBQW9Bb3dCSVJjZ0FDZ0NGQ0VRSUFBb0FtQWhKU0FBS0FLd0FTRXVJQUFvQWlnaEJpQUFLQUo4SVNZZ0FDZ0NCQ0VuSUFBZ0FDZ0NrQUVpTUNBQUtBSnNJaklnQUNnQ3ZBRWlNeUFBS0FKQUlpOXpjeUFCYzNNaURTQUFLQUtFQVNJMElBQW9BZ3dpS1NBQUtBSllJalZ6Y3lBU2N5QWFjeUlJY3lJUklBQW9BaEFpREhOQkZuY2lDU0FBS0FLa0FTSTJJQUFvQWl3aU55QUFLQUo0SWpnZ0FDZ0NBQ0lEYzNOeklBOXpJamtnQUNnQ1pDSTZJQUFvQXJRQklqRnpJQXh6SUFKeklBNXpJaFJCQVhkeklnd2dBQ2dDQ0NJcWMwRVdkeUlIUVg5emNTQURJQUFvQXNRQklqc2dBQ2dDU0NJOElBQW9BcHdCSWoxemN5QUVjeUFMY3lJZklBaEJBWGR6SWdoekloWnpJaUUyQWdBZ0tFRUlhaUlES0FJQUlUNGdBQ0FMSUEwZ0JpQW1JQ2R6Y3lBWWN5QVZjeUkvUVFGM2N5SU5jMEVIZHlJb0lBY2dGa0YvYzNGek5nSWdJQUFnQ2lBVUlCOXpJZ3R6UVF0M0loUWdGaUFvUVg5emNYTTJBaGdnQUNBb0lCUkJmM054SUFsek5nSVFJQUFnRkNBSlFYOXpjU0FIY3pZQ0NDQUFJQkFnSGlBZ0lCd2dLbk56Y3lBVGN5SUhJQ3dnR3lBdGMzTWdDbk1nSFhNaUtrRUJkM01pQ1hOQkZYY2lDaUFwSUQ4Z0Z5QVFJQ1VnTG5OemN5QVpjeUlmY3lJUWMwRVdkeUlXUVg5emNTQW5JQWNnSXlBa0lDdHpjeUFGY3lBaWN5SXBjeUlIY3lJbmN5SS9OZ0lFSUFBZ0lTQStjellDQUNBREtBSUVJU0VnQUNBT0lCRnpRUjkzSWlnZ0RTQThjMEVLZHlJVUlDOGdIeUFwUVFGM2N5SU9jMEVPZHlJdlFYOXpjWE0yQWtnZ0FDQVFJQkp6UVJkM0loSWdMeUFvUVg5emNYTTJBa0FnQUNBR0lBZHpRUUozSWdZZ0tDQVNRWDl6Y1hNMkFqZ2dBQ0FVSUJJZ0JrRi9jM0Z6TmdJd0lBQWdCaUFVUVg5emNTQXZjellDS0NBQUlDSWdLaUE1Y3lJR2MwRUhkeUlTSUJZZ0owRi9jM0Z6TmdJa0lBQWdBU0FPYzBFS2R5SUJJQ2NnRWtGL2MzRnpOZ0ljSUFBZ0VpQUJRWDl6Y1NBS2N6WUNGQ0FBSUFFZ0NrRi9jM0VnRm5NMkFnd2dBQ0FJSUE5elFRbDNJZ0VnQ1NBbGMwRURkeUlLSUJBZ05YTkJBWGNpRWtGL2MzRnpOZ0p3SUFBZ0JDQU5jMEVFZHlJRUlCSWdBVUYvYzNGek5nSm9JQUFnQ3lBc2MwRU5keUlQSUFFZ0JFRi9jM0Z6TmdKZ0lBQWdCQ0FQUVg5emNTQUtjellDV0NBQUlBOGdDa0YvYzNFZ0VuTTJBbEFnQUNBSklCbHpRUjUzSWdFZ0JpQWtjMEVLZHlJRUlBc2dMWE5CRG5jaUNrRi9jM0Z6TmdKTUlBQWdEQ0FlYzBFV2R5SVNJQW9nQVVGL2MzRnpOZ0pFSUFBZ0NDQTNjMEVCZHlJUElBRWdFa0YvYzNGek5nSThJQUFnQkNBU0lBOUJmM054Y3pZQ05DQUFJQThnQkVGL2MzRWdDbk0yQWl3Z0FDQWhJRDl6TmdJRUlBQWdEaUF3YzBFY2R5SUJJQWdnT0hOQkVuY2lCQ0FHSUN0elFRNTNJZ3BCZjNOeGN6WUNtQUVnQUNBQ0lCRnpRUWgzSWdJZ0NpQUJRWDl6Y1hNMkFwQUJJQUFnRENBZ2MwRUZkeUlTSUFFZ0FrRi9jM0Z6TmdLSUFTQUFJQUlnRWtGL2MzRWdCSE0yQW9BQklBQWdDaUFTSUFSQmYzTnhjellDZUNBQUlBY2dGWE5CQ1hjaUFTQVJJRHB6UVFOM0lnUWdEQ0FjY3lJQ1FYOXpjWE0yQW5RZ0FDQUZJQVp6UVFSM0lnVWdBaUFCUVg5emNYTTJBbXdnQUNBT0lESnpRUXgzSWdvZ0FTQUZRWDl6Y1hNMkFtUWdBQ0FFSUFVZ0NrRi9jM0Z6TmdKY0lBQWdDaUFFUVg5emNTQUNjellDVkNBQUlBMGdQWE5CRFhjaUFTQVFJRFJ6UVFWM0lnUWdCeUFtYzBFU2R5SUNRWDl6Y1hNMkFud2dBQ0FKSUJkelFRZDNJZ1VnQkVGL2MzRWdBbk0yQW9RQklBQWdCQ0FMSUIxelFSeDNJZ29nQlVGL2MzRnpOZ0tNQVNBQUlBRWdDa0YvYzNFZ0JYTTJBcFFCSUFBZ0FpQUJRWDl6Y1NBS2N6WUNuQUVnQUNBSklDNXpRUjkzSWdrZ0JpQWpjMEVVZHlJR0lBc2dHM05CSEhjaUMwRi9jM0Z6TmdLZ0FTQUFJQWNnR0hOQkZYY2lCeUFHUVg5emNTQUxjellDcUFFZ0FDQUdJQXdnRTNOQkFYY2lEQ0FIUVg5emNYTTJBckFCSUFBZ0NTQU1RWDl6Y1NBSGN6WUN1QUVnQUNBTElBbEJmM054SUF4ek5nTEFBU0FBSUJBZ0duTkJBWGNpRENBT0lETnpRUnQzSWdzZ0VTQXhjMEVmZHlJUlFYOXpjWE0yQXNRQklBQWdDQ0EyYzBFVWR5SUlJQkVnREVGL2MzRnpOZ0s4QVNBQUlBMGdPM05CRTNjaURTQU1JQWhCZjNOeGN6WUN0QUVnQUNBSUlBMUJmM054SUF0ek5nS3NBU0FBSUEwZ0MwRi9jM0VnRVhNMkFxUUJJQU5CQ0dvaEVTQURLQUlJUWY4QlJ3MEFDd3VIQndFYmZ5TUFRVUJxSWdNa0FDQUFRZUFBYWlBQlFlQUFhaUFDUVVCckloSVFCaUFBUVVCcklBRkJRR3NnQTBFZ2FpSVRFQVlnQUNBQklBSVFCaUFBUVNCcUlBRkJJR29nQWtFZ2FpSVBFQVlnQXlBREtBSWdJZ0FnRWlnQ0FDSVFheUlFSUFNb0Fpd2lGU0FDS0FKTUloWWdBeWdDS0NJQklBSW9Ba2dpREdzaUJpQU1jeUFCSUF4emNpQUJjMEVmZGlBREtBSWtJZ2tnQWlnQ1JDSU5heUlGSUExeklBa2dEWE55SUFselFSOTJJQUFnRUhNaUZ5QUVJQkJ6Y2lBQWMwRWZkaUlLSUFWRmNYSWlDeUFHUlhGeWFtc2lDRUVmZGlJSGF6WUNBQ0FESUFVZ0Ntc2lCU0FISUFSRmNTSUVhellDQkNBRElBWWdDMnNpQmlBRUlBVkZjU0lFYXpZQ0NDQURJQWhCLy8vLy93ZHhJQVFnQmtWeGF6WUNEQ0FESUFNb0FqUWlCQ0FDS0FKVUlnWnJJZ2NnQXlnQ01DSUZJQUlvQWxBaUNHc2lGQ0FJY3lBRklBaHpJaGh5SUFWelFSOTJJaEZySWhrZ0F5Z0NQQ0lhSUFJb0Fsd2lHeUFES0FJNElnb2dBaWdDV0NJTGF5SU9JQXR6SUFvZ0MzTnlJQXB6UVI5MklCRWdCMFZ4SUFZZ0IzTWdCQ0FHYzNJZ0JITkJIM1p5SWdjZ0RrVnhjbXBySWhGQkgzWWlIQ0FVUlhFaUhXczJBaFFnQXlBT0lBZHJJZ2NnSFNBWlJYRWlEbXMyQWhnZ0F5QVJRZi8vLy84SGNTQU9JQWRGY1dzMkFod2dBeUFhSUJ0cUlBc2dDaUFHSUFRZ0JTQUZJQWhxSWdoeklCaHlJQWh6UVI5MmFpSUZhaUlISUFWeklBVWdCbk55SUFkeklBUWdCVUYvYzNGeVFSOTJhaUlFYWlJR0lBUnpJQVFnQzNOeUlBWnpJQW9nQkVGL2MzRnlRUjkyYWlJRVFSOTJJQWhxSWdVMkFqQWdBeUFJSUFWQmYzTnhRUjkySUFkcUlnVTJBalFnQXlBSElBVkJmM054UVI5MklBWnFJZ1UyQWpnZ0F5QUVRZi8vLy84SGNTQUdJQVZCZjNOeFFSOTJhallDUENBRElCUWdIR3MyQWhBZ0F5QVZJQlpxSUF3Z0FTQU5JQWtnQUNBQUlCQnFJZ1J6SUJkeUlBUnpRUjkyYWlJQWFpSUdJQUJ6SUFBZ0RYTnlJQVp6SUFrZ0FFRi9jM0Z5UVI5MmFpSUFhaUlKSUFCeklBQWdESE55SUFseklBRWdBRUYvYzNGeVFSOTJhaUlBUVI5MklBUnFJZ0UyQWlBZ0F5QUVJQUZCZjNOeFFSOTJJQVpxSWdFMkFpUWdBeUFHSUFGQmYzTnhRUjkySUFscUlnRTJBaWdnQXlBQVFmLy8vLzhIY1NBSklBRkJmM054UVI5MmFqWUNMQ0FDSUE4Z0FrR0FBV29pQUJBTklBSWdEeUFDUWVBQWFpSUJFQWNnQUNBRElBSVFCaUFUSUFNZ0VoQUdJQUVnRXlBUEVBWWdBMEZBYXlRQUMxVUJBbjhnQUVIZ0FHb2lBaUFDSUFGQjRBQnFJZ0lRQnlBQUlBQkJJR29pQXlBQkVBY2dBeUFBSUFGQklHb1FEU0FDSUFCQmdBRnFJQUlRQmlBQVFVQnJJZ0FnQUNBQlFVQnJFQWNnQWtIZ0NDQUNFQVlMNUFNQkEzOGdBQ0FDYWlFREFrQUNRQUpBSUFBZ0FYTkJBM0ZGQkVBZ0FFRURjVVVOQVNBQ1FRQk1EUUVnQUNFQ0EwQWdBaUFCTFFBQU9nQUFJQUZCQVdvaEFTQUNRUUZxSWdKQkEzRkZEUU1nQWlBRFNRMEFDd3dDQ3dKQUlBTkJCRWtOQUNBRFFRUnJJZ1FnQUVrTkFDQUFJUUlEUUNBQ0lBRXRBQUE2QUFBZ0FpQUJMUUFCT2dBQklBSWdBUzBBQWpvQUFpQUNJQUV0QUFNNkFBTWdBVUVFYWlFQklBSkJCR29pQWlBRVRRMEFDd3dEQ3lBQUlRSU1BZ3NnQUNFQ0N3SkFJQU5CZkhFaUJFSEFBRWtOQUNBQ0lBUkJRR29pQlVzTkFBTkFJQUlnQVNnQ0FEWUNBQ0FDSUFFb0FnUTJBZ1FnQWlBQktBSUlOZ0lJSUFJZ0FTZ0NERFlDRENBQ0lBRW9BaEEyQWhBZ0FpQUJLQUlVTmdJVUlBSWdBU2dDR0RZQ0dDQUNJQUVvQWh3MkFod2dBaUFCS0FJZ05nSWdJQUlnQVNnQ0pEWUNKQ0FDSUFFb0FpZzJBaWdnQWlBQktBSXNOZ0lzSUFJZ0FTZ0NNRFlDTUNBQ0lBRW9BalEyQWpRZ0FpQUJLQUk0TmdJNElBSWdBU2dDUERZQ1BDQUJRVUJySVFFZ0FrRkFheUlDSUFWTkRRQUxDeUFDSUFSUERRQURRQ0FDSUFFb0FnQTJBZ0FnQVVFRWFpRUJJQUpCQkdvaUFpQUVTUTBBQ3dzZ0FpQURTUVJBQTBBZ0FpQUJMUUFBT2dBQUlBRkJBV29oQVNBQ1FRRnFJZ0lnQTBjTkFBc0xJQUFMNGdFQkEzOGdBQzBBeVFGRkJFQWdBZ1JBQTBBZ0FpQUZheUVEQWtBQ1FDQUFMUURJQVNJRURRQWdCVUdvQVdvZ0Frc05BQ0FEUWFnQlR3UkFBMEFnQUNBQlFRQkJxQUVRUUFKQUlBQVFGUXNnQVVHb0FXb2hBU0FEUWFnQmF5SURRYWNCU3cwQUN3c2dBaUFEYXlFRkRBRUxJQUFnQVNBRVFhZ0JJQVJySUFNZ0F5QUVha0dvQVVzYklnUkIvd0Z4SWdNUVFDQUFJQUF0QU1nQklBUnFJZ1E2QU1nQklBRWdBMm9oQVNBRElBVnFJUVVnQkVIL0FYRkJxQUZIRFFBQ1FDQUFFQlVMSUFCQkFEb0F5QUVMSUFJZ0JVc05BQXNMRHd0QkxVR1JpQUlRS3dBTFNnRUNmMEhra1FJb0FnQWlBU0FBUVFOcVFYeHhJZ0pxSVFBQ1FDQUNRUUFnQUNBQlRSc05BQ0FBUHdCQkVIUkxEUUJCNUpFQ0lBQTJBZ0FnQVE4TFFmaVNBa0V3TmdJQVFYOExxZ3dDRW44RGZpTUFRY0FCYXlJREpBQWdBQ0FCSUFOQmdBRnFJZ0JCQ0JBTUlBQkJvQWdnQTBGQWF5SUFRUWdRRENBQVFZQUlJQU5CQ0JBTUlBTWdBeWdDSUNJRUlBTW9BcUFCSWdVZ0F5Z0NIQ0lCSUFNb0Fwd0JJZ1lnQXlnQ0dDSUhJQU1vQXBnQklnd2dBeWdDRkNJSUlBTW9BcFFCSWdvZ0F5Z0NFQ0lKSUFNb0FwQUJJZzBnQXlnQ0RDSU9JQU1vQW93Qklnc2dBeWdDQ0NJUElBTW9Bb2dCSWhBZ0F5Z0NCQ0lSSUFNb0FvUUJJaE1nQXlnQ0FDSVNJQU1vQW9BQklnQnFJaFFnQUhNZ0FDQVNjM0lnRkhOQkgzWnFJZ0JxSWhJZ0FITWdBQ0FSYzNJZ0VuTWdFeUFBUVg5emNYSkJIM1pxSWdCcUloRWdBSE1nQUNBUGMzSWdFWE1nRUNBQVFYOXpjWEpCSDNacUlnQnFJZzhnQUhNZ0FDQU9jM0lnRDNNZ0N5QUFRWDl6Y1hKQkgzWnFJZ0JxSWc0Z0FITWdBQ0FKYzNJZ0RuTWdEU0FBUVg5emNYSkJIM1pxSWdCcUlna2dBSE1nQUNBSWMzSWdDWE1nQ2lBQVFYOXpjWEpCSDNacUlnQnFJZ2dnQUhNZ0FDQUhjM0lnQ0hNZ0RDQUFRWDl6Y1hKQkgzWnFJZ0JxSWdjZ0FITWdBQ0FCYzNJZ0IzTWdCaUFBUVg5emNYSkJIM1pxSWdCcUlnRTJBaUFnQXlBREtBSWtJZ1lnQXlnQ3BBRWlCeUFGSUFCQmYzTnhJQUFnQVhNZ0FDQUVjM0lnQVhOeVFSOTJhaUlBYWlJQk5nSWtJQU1nQXlnQ0tDSUVJQU1vQXFnQklnVWdCeUFBUVg5emNTQUFJQUZ6SUFBZ0JuTnlJQUZ6Y2tFZmRtb2lBR29pQVRZQ0tDQURJQU1vQWl3aUJpQURLQUtzQVNJSElBVWdBRUYvYzNFZ0FDQUJjeUFBSUFSemNpQUJjM0pCSDNacUlnQnFJZ0UyQWl3Z0F5QURLQUl3SWdRZ0F5Z0NzQUVpQlNBSElBQkJmM054SUFBZ0FYTWdBQ0FHYzNJZ0FYTnlRUjkyYWlJQWFpSUJOZ0l3SUFNZ0F5Z0NOQ0lHSUFNb0FyUUJJZ2NnQlNBQVFYOXpjU0FBSUFGeklBQWdCSE55SUFGemNrRWZkbW9pQUdvaUFUWUNOQ0FESUFNb0FqZ2lCQ0FES0FLNEFTSUZJQWNnQUVGL2MzRWdBQ0FCY3lBQUlBWnpjaUFCYzNKQkgzWnFJZ0JxSWdFMkFqZ2dBeUFES0FJOElnMGdBeWdDdkFFaURpQUZJQUJCZjNOeElBQWdBWE1nQUNBRWMzSWdBWE55UVI5MmFpSUFhaUlHTmdJOElBSWdBeWtESUNJVk53SUFJQUlnQXlrREtDSVdOd0lJSUFJZ0F5a0RNQ0lYTndJUUlBSWdBeWtET0RjQ0dDQUNJQlduSWdGQm1lYWx4QU5xSWdRMkFnQWdBaUFDS0FJRUlneEJqcWpKL1FKcklnVkI1cG5hdTN3Z0FXc2dBVUYvYzNJZ0FYTkJIM1lpQ0dzaUJ6WUNCQ0FDSUJhbklnRkI1NHpDRDJvaUNpQUlJQVZGY1NBRklBeEJmM054UVI5MmNpSUlheUlNTmdJSUlBSWdBaWdDRENJRlFiUC9pNElDYWlJSklBZ2dDa1Z4UVpqenZYQWdBV3NnQVVGL2MzSWdBWE5CSDNaeUlncHJJZ2cyQWd3Z0FpQVhweUlCUVp2V2o1b0dhaUlMSUFvZ0NVVnhJQVZCeklEMC9YMGdCV3NnQlVGL2MzSnpRUjkyY2lJSmF5SUtOZ0lRSUFJZ0FpZ0NGQ0lGUWY3UXNmMEFhaUlQSUFrZ0MwVnhRZVNwOE9WNUlBRnJJQUZCZjNOeUlBRnpRUjkyY2lJTGF5SUpOZ0lVSUFJZ0FpZ0NHQ0lRUWZLVStQSUVheUlCSUFzZ0QwVnhJQVZCZ2EvT2duOGdCV3NnQlVGL2MzSnpRUjkyY2lJTGF5SUZOZ0lZSUFJZ0RpQUFRWDl6Y1NBQUlBWnpJQUFnRFhOeUlBWnpja0VmZGlBQ0tBSWNJZ0JCd1plbkFXc2lCaUFBUVg5emNVRWZkaUFMSUFGRmNTQUJJQkJCZjNOeFFSOTJjaUlOSUFaRmNYSnJJZ0JCNTVuYXUzeHhJQVJxSWdFMkFnQWdBaUFISUFFZ0JITWdBQ0FFYzNJZ0FYTkJIM1pxSWdFZ0FFR09xTW45QW5GcUlnUTJBZ1FnQWlBTUlBRWdCRUYvYzNFZ0J5QUJRWDl6Y1hKQkgzWnFJZ0VnQUVHWjg3MXdjV29pQkRZQ0NDQUNJQWdnRENBQlFYOXpjU0FCSUFSeklBQWdBWE55SUFSemNrRWZkbW9pQVNBQVFjMkE5UDE5Y1dvaUJEWUNEQ0FDSUFvZ0NDQUJRWDl6Y1NBQklBUnpJQUFnQVhOeUlBUnpja0VmZG1vaUFTQUFRZVdwOE9WNWNXb2lCRFlDRUNBQ0lBa2dDaUFCUVg5emNTQUJJQVJ6SUFBZ0FYTnlJQVJ6Y2tFZmRtb2lBU0FBUVlLdnpvSi9jV29pQkRZQ0ZDQUNJQVVnQ1NBQlFYOXpjU0FCSUFSeklBQWdBWE55SUFSemNrRWZkbW9pQVNBQVFmS1UrUElFY1dvaUJEWUNHQ0FDSUFZZ0RXc2dBU0FFUVg5emNTQUZJQUZCZjNOeGNrRWZkbW9nQUVIQmw2Y0JjV28yQWh3Z0EwSEFBV29rQUFzS0FDQUFJQUFnQVJBRkN6b0FJQUFnQUNnQ0FFRi9jellDQUNBQUlBQW9BZ1JCZjNNMkFnUWdBQ0FBS0FJSVFYOXpOZ0lJSUFCQi8vLy8vd2NnQUNnQ0RHczJBZ3dMZ3dFQ0EzOEJmZ0pBSUFCQ2dJQ0FnQkJVQkVBZ0FDRUZEQUVMQTBBZ0FVRUJheUlCSUFBZ0FFSUtnQ0lGUWdwK2ZhZEJNSEk2QUFBZ0FFTC8vLy8vbndGV0lRSWdCU0VBSUFJTkFBc0xJQVduSWdJRVFBTkFJQUZCQVdzaUFTQUNJQUpCQ200aUEwRUtiR3RCTUhJNkFBQWdBa0VKU3lFRUlBTWhBaUFFRFFBTEN5QUJDNUVHQVFSL0l3QkJzQU5ySWdZa0FBSi9RUUVnQTBVTkFCb2dCaUFETmdLY0F5QUdRUUUyQXFnRElBWkNBRGNEb0FNZ0JrSFFBV29RUVNBR1FRQTdBWmdEUVFFZ0JpQUFJQUVRTGcwQUdnSi9RUUFoQXlNQVFUQnJJZ2drQUVFQklRY0NRQUpBSUFZb0FxZ0RRUUZIRFFBQ1FDQUZSUVJBUVFBaEFRd0JDeUFHSUFRZ0JSQXVEUUVnQ0NBRkFuOUJBU0FGUVlBQ1NRMEFHaUFGUVlDQUJFa0VRRUVCSVFsQkFDRUhRUUlNQVF0QkFDRUhRWDlCQUNBRlFZQ0FnQWhKR3lFRFFRUkJBeUFGUWYvLy93ZExHd3NpQVVFRGRDSUFRUWhyZGpvQUtTQUhEUUFnQ0NBRklBQkJFR3QyT2dBcUlBa05BQ0FJSUFVZ0FVRURkQ0lBUVJocmRqb0FLeUFEUVFGeERRQWdDQ0FGSUFCQklHdDJPZ0FzQ3lBSVFTbHFJZ0FnQVdvZ0FUb0FBRUVCSVFjZ0JpQUFJQUZCQVdvUUxnMEFJQVlvQXFBRElnQUVmeUFHSUFZb0FxUURCSDhnQmlBQVFRRnFOZ0tnQXlBR0xRREpBUTBESUFaQkN5QUdMUURJQVJBU0lBWkJnQUZCcHdFUUVpQUdFQlVnQmtHQUFqc0F5QUVnQmlBSVFTQVFKU0FHUWRBQmFpQUlRU0FRR1NBR0tBS2dBd1VnQUF0QkFXc2lCRFlDb0FNQ1FDQUVSUVJBUVFBaEJ3d0JDd0ovSUFSQmdBSkpCRUJCQUNFSlFRQWhBMEVCREFFTElBUkJnSUFFU1FSQVFRSWhCMEVCSVFsQkFDRURRUUFNQVF0QkJFRURJQVJCLy8vL0Iwc2JJUWRCZjBFQUlBUkJnSUNBQ0VrYklRTkJBQ0VKUVFBTElRRWdDQ0FFSUFkQkEzUWlBRUVJYTNZNkFDa2dBUTBBSUFnZ0JDQUFRUkJyZGpvQUtpQUpEUUFnQ0NBRUlBZEJBM1FpQUVFWWEzWTZBQ3NnQTBFQmNRMEFJQWdnQkNBQVFTQnJkam9BTEFzZ0NFRXBhaUlCSUFkcUlnQWdCem9BQUNBQVFmLy9BenNBQVNBR1FkQUJhaUFCSUFkQkEyb1FHVUVHQlVFSEN5RUFJQVl0QUprRERRRWdCa0hRQVdvaUFTQUFJQVl0QUpnREVCSWdBVUdBQVVHbkFSQVNJQUVRRlNBR1FZQUNPd0NZQXdKQUlBWW9BcHdESWdBRVFDQUdRUUkyQXFnRElBRWdBaUFBRUNVTUFRc2dCa0VETmdLb0F3dEJBQ0VIQ3lBSVFUQnFKQUFnQnd3QkMwSFlBRUd0aHdJUUt3QUxDeUVBSUFaQnNBTnFKQUFnQUF2QkZ3SVVmd1orSXdCQjRBcHJJZ0lrQUNBQ1FhQUNha0VBUWJ3SUVBNGdBa0lBTndNWUlBSkNBRGNERUNBQ1FnQTNBd0FnQWtJQU53TUlJQUpCQVRZQ0FDQUFRY0FJSUFKQjRBQnFJZ0FRR3lBQUlBSWdBa0dBQW1vUUd5QUNJQUlvQW9BQ0lnUkJBWEZCQVdzaUFFSG5tZHE3ZkhFZ0JHb2lCVFlDZ0FJZ0FpQUNLQUtFQWlJR0lBQkJqcWpKL1FKeElBQWdCWE1nQUNBRWMzSWdCWE5CSDNaeWFpSUVOZ0tFQWlBQ0lBQkJtZk85Y0hFZ0JpQUVRWDl6Y1VFZmRtb2lCQ0FDS0FLSUFpSUdhaUlGTmdLSUFpQUNJQUJCellEMC9YMXhJQUFnQkVGL2MzRWdCQ0FGY3lBRUlBWnpjaUFGYzNKQkgzWnFJZ1FnQWlnQ2pBSWlCbW9pQlRZQ2pBSWdBaUFBUWVXcDhPVjVjU0FBSUFSQmYzTnhJQVFnQlhNZ0JDQUdjM0lnQlhOeVFSOTJhaUlFSUFJb0FwQUNJZ1pxSWdVMkFwQUNJQUlnQWlnQ2xBSWlDQ0FBUVlLdnpvSi9jU0FBSUFSQmYzTnhJQVFnQlhNZ0JDQUdjM0lnQlhOeVFSOTJjbW9pQkRZQ2xBSWdBaUFDS0FLWUFpSUZJQUJCOHBUNDhnUnhJQUFnQkhNZ0FDQUljM0lnQkhOQkgzWnlhaUlFTmdLWUFpQUNJQUlvQXB3Q0lBQkJ3WmVuQVhGcUlBVWdCRUYvYzNGQkgzWnFOZ0tjQWlBQ1FRQTJBdVFESUFJcEE0Z0NJaFpDUDRZZ0Fpa0RnQUpDQVlpRUlSa2dBaWtEa0FJaUYwSS9oaUFXUWdHSWhDRVdJQUlwQTVnQ0loaENQNFlnRjBJQmlJUWhGeUFZUWdHSUlSZ0RRQ0FDUWFBQ2FpQURRUUowYWlBWnAwRUJjVUVCYXpZQ0FDQVlRaitHSVJvZ0YwSS9oaUViSUJaQ1A0WWdHVUlCaUlRaEdTQVlRZ0dJSVJnZ0dpQVhRZ0dJaENFWElCc2dGa0lCaUlRaEZpQURRUUZxSWdOQk1VY05BQXRCTWlFREEwQWdBa0dnQW1vaUFDQURRUUowYWlBWnAwRUJjU0lFTmdJQUlBUkJBQ0FEUVRKd1FRSjBJQUJxS0FJQWEzRWlBQ0FBclNBV1FqK0dJQmxDQVlpRWZDSVpwMFZ4clNJYUlCZENQNFlnRmtJQmlJUjhJaGFuUmEwZ0dvTWlHaUFhSUJoQ1A0WWdGMElCaUlSOEloZW5SYTJESUJoQ0FZaDhJUmdnQTBFQmFpSURRZm9CUncwQUN5QUNJQmczQTVnQ0lBSWdGemNEa0FJZ0FpQVdOd09JQWlBQ0lCazNBNEFDUVlBNUlBSWdBaWdDckFVZ0FpZ0M5QVlnQWlnQ3ZBZ2dBaWdDaEFwQkFYUnFRUUYwYWtFQmRHb2dBaWdDNUFNUUZDQUNJQUlvQWdBaUNDQUNLQUlnSWdwcklnQWdBaWdDRENJTUlBSW9BaXdpRUNBQ0tBSUlJZzBnQWlnQ0tDSUpheUlESUFseklBa2dEWE55SUExelFSOTJJQUlvQWdRaUJ5QUNLQUlrSWc1cklnUWdEbk1nQnlBT2MzSWdCM05CSDNZZ0NDQUtjeUlTSUFBZ0NuTnlJQWh6UVI5MklnVWdCRVZ4Y2lJR0lBTkZjWEpxYXlJUFFSOTJJZ3RyTmdKZ0lBSWdCQ0FGYXlJRUlBc2dBRVZ4SWdCck5nSmtJQUlnQXlBR2F5SURJQUFnQkVWeElnQnJOZ0pvSUFJZ0QwSC8vLy8vQjNFZ0FDQURSWEZyTmdKc0lBSW9BaHdoQ3lBQ0tBSThJUkVnQWlnQ09DRUFJQUlvQWhnaEF5QUNLQUkwSVFRZ0FpZ0NGQ0VGSUFJb0FqQWhEeUFDS0FJUUlRWWdBaUFJSUFwcUlnb2dDaUFNSUJCcUlBa2dEU0FPSUFjZ0NpQUlJQXB6SUJKeWMwRWZkbW9pQ0dvaURDQUljeUFJSUE1emNpQU1jeUFISUFoQmYzTnhja0VmZG1vaUNHb2lCeUFJY3lBSUlBbHpjaUFIY3lBTklBaEJmM054Y2tFZmRtb2lEVUVmZG1vaUVFRi9jM0ZCSDNZZ0RHb2lDRFlDaEFFZ0FpQU5RZi8vLy84SGNTQUhJQWNnRENBSVFYOXpjVUVmZG1vaURVRi9jM0ZCSDNacUloSTJBb3dCSUFJZ0RUWUNpQUVnQWlBTElCRnFJQUFnQXlBRUlBVWdCaUFQY3lJVUlBWWdCaUFQYWlJSmMzSWdDWE5CSDNacUlnZHFJZzRnQjNNZ0JDQUhjM0lnRG5NZ0JTQUhRWDl6Y1hKQkgzWnFJZ2RxSWdvZ0IzTWdBQ0FIYzNJZ0NuTWdBeUFIUVg5emNYSkJIM1pxSWhOQkgzWWdDV29pQnpZQ2tBRWdBaUFKSUFkQmYzTnhRUjkySUE1cUloVTJBcFFCSUFKQkFDQUdJQTlySWdrZ0N5QVJJQU1nQUNBRElBQnJJZ2R6SUFBZ0EzTnljMEVmZGlBRklBUWdCU0FFYXlJTWN5QUVJQVZ6Y25OQkgzWWdCaUFKSUE5eklCUnljMEVmZGlJRUlBeEZjWElpQmlBSFJYRnlhbXNpRDBFZmRpSUxheUlSUVFGeElnVnJJZ0JCSDNZZ0JXc2lBeUFNSUFScklnd2dDeUFKUlhFaUNXc2lDMm9pQkNBRGN5QURJQXR6Y2lBRWN5QURRWDl6SUFCeGNrRWZkaUFGYXlJRElBY2dCbXNpQmlBSklBeEZjU0lKYXlJSGFpSUZRUjkwSUFSQkFYWnlJZ3cyQW5RZ0FpQU9JQlZCZjNOeFFSOTJJQXBxSWc0MkFwZ0JJQUlnRDBILy8vLy9CM0VnQ1NBR1JYRnJJQUJCQVhacUlBTkJmM01nQUhFZ0F5QUZjeUFESUFkemNpQUZjM0pCSDNacUlnQkJBWFlpQ1RZQ2ZDQUNJQUJCSDNRZ0JVRUJkbklpQnpZQ2VDQUNJQk5CLy8vLy93ZHhJQW9nRGtGL2MzRkJIM1pxTmdLY0FTQUNJQWhCQUNBUVFRRnhJZ1pySWdCQkgzWWdCbXNpQTJvaUJTQURjeUFESUFoemNpQUZjeUFEUVg5eklBQnhja0VmZGlBR2F5SURJQTFxSWdaQkgzUWdCVUVCZG5JaUNEWUNoQUVnQWlBU0lBQkJBWFpxSUFOQmYzTWdBSEVnQXlBR2N5QURJQTF6Y2lBR2MzSkJIM1pxSWdCQkFYWWlEVFlDakFFZ0FpQUFRUjkwSUFaQkFYWnlJZzQyQW9nQklBSWdCRUVmZENBUlFRRjJjaUlQTmdKd0lBSkJBQ0FDS0FKZ0lncEJBWEVpQm1zaUFFRWZkaUFHYXlJRElBSW9BbVFpQzJvaUJFRWZkQ0FLUVFGMmNpSUtOZ0pnSUFJZ0EwRi9jeUFBY1NBRElBUnpJQU1nQzNOeUlBUnpja0VmZGlBR2F5SURJQUlvQW1naUMyb2lCa0VmZENBRVFRRjJjaUlSTmdKa0lBSWdBaWdDYkNBQVFRRjJhaUFEUVg5eklBQnhJQU1nQm5NZ0F5QUxjM0lnQm5OeVFSOTJhaUlBUVFGMklnczJBbXdnQWlBQVFSOTBJQVpCQVhaeUloSTJBbWdnQWlBRlFSOTBJQkJCQVhaeUloQTJBb0FCSUFJb0Fwd0JJUlFnQWlnQ21BRWhCaUFDUVFBZ0FpZ0NrQUVpRTBFQmNTSUZheUlBUVI5MklBVnJJZ01nQWlnQ2xBRWlGV29pQkVFZmRDQVRRUUYyY2lJVE5nS1FBU0FDSUFZZ0EwRi9jeUFBY1NBRElBUnpJQU1nRlhOeUlBUnpja0VmZGlBRmF5SURhaUlGUVI5MElBUkJBWFp5SWdRMkFwUUJJQUlnRkNBQVFRRjJhaUFEUVg5eklBQnhJQU1nQlhNZ0F5QUdjM0lnQlhOeVFSOTJhaUlBUVFGMklnTTJBcHdCSUFJZ0FFRWZkQ0FGUVFGMmNpSUFOZ0tZQVNBQ1FRQTJBcndCSUFKQ0FEY0N0QUVnQWtJQU53S3NBU0FDUWdBM0FxUUJJQUlnQXpZQy9BRWdBaUFBTmdMNEFTQUNJQVEyQXZRQklBSWdFellDOEFFZ0FpQU5OZ0xzQVNBQ0lBNDJBdWdCSUFJZ0NEWUM1QUVnQWlBSk5nTGNBU0FDSUFjMkF0Z0JJQUlnRERZQzFBRWdBaUFQTmdMUUFTQUNJQXMyQXN3QklBSWdFallDeUFFZ0FpQVJOZ0xFQVNBQ0lCQTJBdUFCSUFJZ0NqWUN3QUVnQWtFQk5nS2dBVUdBTFNBQ0lBSW9Bb1FGSUFJb0Fzd0dJQUlvQXBRSUlBSW9BdHdKUVFGMGFrRUJkR3BCQVhScUlBSW9BcndERUJRZ0FpQUNRZUFBYWlJQUVBdEJnQ0VnQWlBQ0tBTGNCQ0FDS0FLa0JpQUNLQUxzQnlBQ0tBSzBDVUVCZEdwQkFYUnFRUUYwYWlBQ0tBS1VBeEFVSUFJZ0FCQUxRWUFWSUFJZ0FpZ0N0QVFnQWlnQy9BVWdBaWdDeEFjZ0FpZ0NqQWxCQVhScVFRRjBha0VCZEdvZ0FpZ0M3QUlRRkNBQ0lBQVFDMEdBQ1NBQ0lBSW9Bb3dFSUFJb0F0UUZJQUlvQXB3SElBSW9BdVFJUVFGMGFrRUJkR3BCQVhScUlBSW9Bc1FDRUJRZ0FpQUFFQXRCQ0NFREEwQWdBa0hnQUdvaUJCQVBRWUE1SUFJZ0FrR2dBbW9nQXlJQVFRSjBhaUlES0FMQUIwRUJkQ0FES0FMNEJXcEJBWFFnQXlnQ3NBUnFRUUYwSUFNb0F1Z0NhaUFES0FLZ0FSQVVJQUlnQkJBTFFZQXRJQUlnQXlnQ3dBSWdBeWdDaUFRZ0F5Z0MwQVVnQXlnQ21BZEJBWFJxUVFGMGFrRUJkR29nQXlnQ2VCQVVJQUlnQkJBTFFZQWhJQUlnQXlnQ21BSWdBeWdDNEFNZ0F5Z0NxQVVnQXlnQzhBWkJBWFJxUVFGMGFrRUJkR29nQXlnQ1VCQVVJQUlnQkJBTFFZQVZJQUlnQXlnQzhBRWdBeWdDdUFNZ0F5Z0NnQVVnQXlnQ3lBWkJBWFJxUVFGMGFrRUJkR29nQXlnQ0tCQVVJQUlnQkJBTFFZQUpJQUlnQXlnQ3lBRWdBeWdDa0FNZ0F5Z0MyQVFnQXlnQ29BWkJBWFJxUVFGMGFrRUJkR29nQXlnQ0FCQVVJQUJCQVdzaEF5QUNJQVFRQ3lBQURRQUxJQUpCNEFCcUlBRVFNU0FDUWVBS2FpUUFDMUlBSUFFZ0FDZ0NBRFlDQUNBQklBQW9BZ1EyQWdRZ0FTQUFLQUlJTmdJSUlBRWdBQ2dDRERZQ0RDQUJJQUFvQWhBMkFoQWdBU0FBS0FJVU5nSVVJQUVnQUNnQ0dEWUNHQ0FCSUFBb0FodzJBaHdMZVFJQ2Z3TitJQUFvQWd3aEFpQUFLQUljSVFNZ0FDa0FLQ0VFSUFBcEFEQWhCU0FBS1FBZ0lRWWdBU0FBS1FBNE53QVlJQUVnQlRjQUVDQUJJQVEzQUFnZ0FTQUdOd0FBSUFFZ0FTZ0NIQ0FDSUFNZ0FDZ0NEQ0FBS0FJSUlBQW9BZ1FnQUNnQ0FISnljaHRCQVhSQmdJQ0FnSGh4Y2pZQ0hBdndBUUVIZnlBQ0lBRW9BZ0FpQXlBQUtBSUFJZ1JxSWdZMkFnQWdBaUFCS0FJRUlnVWdBQ2dDQkNJSElBUWdCbk1nQXlBRWMzSWdCbk5CSDNacUlnTnFJZ1EyQWdRZ0FpQUJLQUlJSWdnZ0FDZ0NDQ0lKSUFjZ0EwRi9jM0VnQXlBRWN5QURJQVZ6Y2lBRWMzSkJIM1pxSWdWcUlnTTJBZ2dnQWlBR0lBRW9BZ3dnQUNnQ0RDQUpJQVZCZjNOeElBTWdCWE1nQlNBSWMzSWdBM055UVI5MmFtb2lBRUVmZG1vaUFUWUNBQ0FDSUFRZ0JpQUJRWDl6Y1VFZmRtb2lBVFlDQkNBQ0lBTWdCQ0FCUVg5emNVRWZkbW9pQVRZQ0NDQUNJQUJCLy8vLy93ZHhJQU1nQVVGL2MzRkJIM1pxTmdJTUM5UURBZ2gvQVg0akFFRWdheUlESkFBZ0FDQUJJQU5CQWhBTUlBTXBBd2doQ3lBRFFnQTNBd2dnQXlBTE53TUFJQUJCQ0dvaUJTQUJJQU5CRUdvaUJFRUNFQXdnQkNBRElBUVFFQm9nQUNBQlFRaHFJZ1lnQTBFQ0VBd2dBMEVRYWlBRElBTkJFR29RRUNFRUlBTXBBeGdoQ3lBRElBU3ROd01ZSUFNZ0N6Y0RFQ0FBUVJCcUlnUWdBU0FEUVFJUURDQURRUkJxSUFNZ0EwRVFhaEFRR2lBQUlBRkJFR29pQ1NBRFFRSVFEQ0FEUVJCcUlBTWdBMEVRYWhBUUlRY2dCU0FHSUFOQkFoQU1JQU5CRUdvZ0F5QURRUkJxRUJBaENDQURJQU1wQXhnM0F4QWdBeUFJclNBSHJYdzNBeGdnQUNBQlFSaHFJZ2NnQTBFQ0VBd2dBMEVRYWlBRElBTkJFR29RRUJvZ0FFRVlhaUlBSUFFZ0EwRUNFQXdnQTBFUWFpQURJQU5CRUdvUUVDRUJJQVVnQ1NBRFFRSVFEQ0FEUVJCcUlBTWdBMEVRYWhBUUlRZ2dCQ0FHSUFOQkFoQU1JQU5CRUdvZ0F5QURRUkJxRUJBaENpQURJQU1wQXhnM0F4QWdBeUFLclNBSXJTQUJyWHg4TndNWUlBVWdCeUFEUVFJUURDQURRUkJxSUFNZ0EwRVFhaEFRR2lBQUlBWWdBMEVDRUF3Z0EwRVFhaUFESUFOQkVHb1FFQm9nQkNBSklBTkJBaEFNSUFOQkVHb2dBeUFEUVJCcUVCQWFJQUlnQXlrREVEY0RBQ0FEUVNCcUpBQUwrUUVCQTM4Z0FDMEF5UUZGQkVBZ0FFRUJJQUF0QU1nQkVCSWdBRUdBQVVHbkFSQVNBa0FnQUJBVkN5QUFRWUFDT3dESUFRc2dBZ1JBQTBBQ2Z3SkFJQUF0QU1nQklnUkJxQUZISWdVTkFDQURRYWdCYWlBQ1N3MEFJQUlnQTJzaUEwR29BVThFUUFOQUFrQWdBQkFWQ3lBQUlBRkJBRUdvQVJBL0lBRkJxQUZxSVFFZ0EwR29BV3NpQTBHbkFVc05BQXNMSUFJZ0Eyc01BUXNnQlVVRVFBSkFJQUFRRlFzZ0FFRUFPZ0RJQVVFQUlRUUxJQUFnQVNBRVFhZ0JJQVJySUFJZ0Eyc2lCU0FFSUFWcVFhZ0JTeHNpQkJBL0lBQWdBQzBBeUFFZ0JHbzZBTWdCSUFFZ0JHb2hBU0FESUFScUN5SURJQUpKRFFBTEN3dXNBUUVGZnlBQUtBSUFJUU1DUUNBQlFRSkpEUUFnQVVFQmF5SUNRUU54SVFRQ1FDQUJRUUpyUVFOSkJFQkJBU0VCREFFTElBSkJmSEVoQmtFQklRRURRQ0FBSUFGQkFuUnFJZ0lvQWd3Z0FpZ0NDQ0FDS0FJRUlBSW9BZ0FnQTNKeWNuSWhBeUFCUVFScUlRRWdCVUVFYWlJRklBWkhEUUFMQ3lBRVJRMEFRUUFoQWdOQUlBQWdBVUVDZEdvb0FnQWdBM0loQXlBQlFRRnFJUUVnQWtFQmFpSUNJQVJIRFFBTEN5QURSUXVhRXdFV2Z5TUFRYUFDYXlJRkpBQWdBRUhnQUdvaUVpQVNJQUZCNEFCcUlnTVFCeUFBSUFCQklHb2lBaUFCRUFjZ0FpQUFJQUZCSUdvUURTQURJQUJCZ0FGcUloWWdBeEFHSUFCQlFHc2lFQ0FRSUFGQlFHc1FCeUFEUWVBSUlBTVFCaUFBRUE4Z0JTQUFLQUlzSWc0Z0FDZ0NEQ0lSYWlBQUtBSUlJZ2tnQUNnQ0JDSUdJQUlvQWdBaUR5QUFLQUlBSWdocUlnTWdDSE1nQ0NBUGN5SVRjaUFEYzBFZmRtb2lBaUFBS0FJa0lndHFJZ1FnQW5NZ0FpQUxjM0lnQkhNZ0JpQUNRWDl6Y1hKQkgzWnFJZ0lnQUNnQ0tDSU1haUlISUFKeklBSWdESE55SUFkeklBa2dBa0YvYzNGeVFSOTJhaUlDUVI5MklBTnFJZ28yQWdBZ0JTQURJQXBCZjNOeFFSOTJJQVJxSWdNMkFnUWdCU0FFSUFOQmYzTnhRUjkySUFkcUlnTTJBZ2dnQlNBQ1FmLy8vLzhIY1NBSElBTkJmM054UVI5MmFqWUNEQ0FBS0FJOElSUWdBQ2dDSENFVklBQW9BamdoQXlBQUtBSVlJUUlnQUNnQ01DRU5JQUFvQWhBaEJDQUFLQUkwSVFjZ0FDZ0NGQ0VLSUFVZ0RpQVJJQXdnQ1NBTUlBbHJJZzV6SUFrZ0RITnljMEVmZGlBTElBWWdDeUFHYXlJSmN5QUdJQXR6Y25OQkgzWWdEeUFJSUE4Z0NHc2lDM01nRTNKelFSOTJJZ1lnQ1VWeGNpSUlJQTVGY1hKcWF5SU1RZi8vLy84SGNTQU1RUjkySWd3Z0MwVnhJZzhnQ1NBR2F5SUpSWEVpQmlBT0lBaHJJZ2hGY1dzMkFpd2dCU0FJSUFack5nSW9JQVVnQ1NBUGF6WUNKQ0FGSUEwZ0JHc2lDU0FVSUJVZ0F5QUNJQU1nQW1zaUJuTWdBaUFEYzNKelFSOTJJQWNnQ2lBSElBcHJJZ2h6SUFjZ0NuTnljMEVmZGlBTklBUWdEWE1pRHlBRUlBbHpjbk5CSDNZaURpQUlSWEZ5SWhFZ0JrVnhjbXBySWhOQkgzWWlGMnMyQWpBZ0JTQUlJQTVySWdnZ0Z5QUpSWEVpQ1dzMkFqUWdCU0FHSUJGcklnWWdDU0FJUlhFaUNXczJBamdnQlNBVFFmLy8vLzhIY1NBSklBWkZjV3MyQWp3Z0JTQVVJQlZxSUFNZ0FpQUhJQW9nQkNBRUlBMXFJZ2x6SUE5eUlBbHpRUjkyYWlJRWFpSUdJQVJ6SUFRZ0IzTnlJQVp6SUFvZ0JFRi9jM0Z5UVI5MmFpSUVhaUlISUFSeklBTWdCSE55SUFkeklBSWdCRUYvYzNGeVFSOTJhaUlEUVI5MklBbHFJZ0kyQWhBZ0JTQUpJQUpCZjNOeFFSOTJJQVpxSWdJMkFoUWdCU0FHSUFKQmYzTnhRUjkySUFkcUlnSTJBaGdnQlNBRFFmLy8vLzhIY1NBSElBSkJmM054UVI5MmFqWUNIQ0FGSUFzZ0RHczJBaUFnRWlBV0lBVkI0QUJxRUFZZ0JTQVFLQUlBTmdKQUlBVWdBQ2dDUkRZQ1JDQUZJQUFvQWtnMkFrZ2dCU0FBS0FKTU5nSk1JQVVnQUNnQ1VEWUNVQ0FGSUFBb0FsUTJBbFFnQlNBQUtBSllOZ0pZSUFVZ0FDZ0NYRFlDWENBRlFZQUNhaUVXUVFFaEVnTkFJQUVnRWtFSGRHb2lBRUdBQVdzZ0JTQUZRWUFCYWhBV0lBVW9BdXdCSVFvZ0JTZ0M2QUVoQXlBQUlBVW9BdVFCSWdJZ0JTZ0M0QUVpQmtFZmRtb2lCQ0FDYWlJSE5nSmtJQUFnQXlBRElBSWdCRUYvYzNFZ0JDQUhjeUFDSUFSemNpQUhjM0pCSDNacUlnSnFJZ1EyQW1nZ0FDQUtRUUYwSUFNZ0FrRi9jM0VnQWlBRWN5QUNJQU56Y2lBRWMzSkJIM1p5SWdOQi8vLy8vd2R4TmdKc0lBQkI0QUJxSWdrZ0JrRUJkQ0FEUVI5MmNqWUNBQ0FGS0FMOEFTRUtJQVVvQXZnQklRTWdBQ0FGS0FMMEFTSUNJQVVvQXZBQklnWkJIM1pxSWdRZ0Ftb2lCellDZENBQUlBTWdBeUFDSUFSQmYzTnhJQVFnQjNNZ0FpQUVjM0lnQjNOeVFSOTJhaUlDYWlJRU5nSjRJQUFnQ2tFQmRDQURJQUpCZjNOeElBSWdCSE1nQWlBRGMzSWdCSE55UVI5MmNpSURRZi8vLy84SGNUWUNmQ0FBSUFaQkFYUWdBMEVmZG5JMkFuQWdBQ0FGS0FLc0FTSU9JQVVvQW93QkloRnFJQVVvQW9nQklnWWdCU2dDaEFFaUNDQUZLQUtnQVNJUUlBVW9Bb0FCSWd0cUlnTWdDM01nQ3lBUWN5SVRjaUFEYzBFZmRtb2lBaUFGS0FLa0FTSU1haUlFSUFKeklBSWdESE55SUFSeklBZ2dBa0YvYzNGeVFSOTJhaUlDSUFVb0FxZ0JJZzFxSWdjZ0FuTWdBaUFOYzNJZ0IzTWdCaUFDUVg5emNYSkJIM1pxSWdKQkgzWWdBMm9pQ2pZQ0FDQUFJQU1nQ2tGL2MzRkJIM1lnQkdvaUF6WUNCQ0FBSUFRZ0EwRi9jM0ZCSDNZZ0Iyb2lBellDQ0NBQUlBSkIvLy8vL3dkeElBY2dBMEYvYzNGQkgzWnFOZ0lNSUFVb0Fyd0JJUlFnQlNnQ25BRWhGU0FGS0FLNEFTRURJQVVvQXBnQklRSWdCU2dDc0FFaER5QUZLQUtRQVNFRUlBVW9BclFCSVFjZ0JTZ0NsQUVoQ2lBQUlBNGdFU0FOSUFZZ0RTQUdheUlPY3lBR0lBMXpjbk5CSDNZZ0RDQUlJQXdnQ0dzaUJuTWdDQ0FNYzNKelFSOTJJQkFnQ3lBUUlBdHJJZ2h6SUJOeWMwRWZkaUlMSUFaRmNYSWlEQ0FPUlhGeWFtc2lEVUgvLy8vL0IzRWdEVUVmZGlJTklBaEZjU0lRSUFZZ0Myc2lCa1Z4SWdzZ0RpQU1heUlNUlhGck5nSXNJQUFnRENBTGF6WUNLQ0FBSUFZZ0VHczJBaVFnQUNBSUlBMXJOZ0lnSUFBZ0R5QUVheUlHSUJRZ0ZTQURJQUlnQXlBQ2F5SUljeUFDSUFOemNuTkJIM1lnQnlBS0lBY2dDbXNpQzNNZ0J5QUtjM0p6UVI5MklBOGdCQ0FQY3lJTUlBUWdCbk55YzBFZmRpSU5JQXRGY1hJaUVDQUlSWEZ5YW1zaURrRWZkaUlSYXpZQ01DQUFJQXNnRFdzaUN5QVJJQVpGY1NJR2F6WUNOQ0FBSUFnZ0VHc2lDQ0FHSUF0RmNTSUdhellDT0NBQUlBNUIvLy8vL3dkeElBWWdDRVZ4YXpZQ1BDQUFJQlFnRldvZ0F5QUNJQWNnQ2lBRUlBUWdEMm9pQm5NZ0RISWdCbk5CSDNacUlnUnFJZ2dnQkhNZ0JDQUhjM0lnQ0hNZ0NpQUVRWDl6Y1hKQkgzWnFJZ1JxSWdjZ0JITWdBeUFFYzNJZ0IzTWdBaUFFUVg5emNYSkJIM1pxSWdOQkgzWWdCbW9pQWpZQ0VDQUFJQVlnQWtGL2MzRkJIM1lnQ0dvaUFqWUNGQ0FBSUFnZ0FrRi9jM0ZCSDNZZ0Iyb2lBallDR0NBQUlBTkIvLy8vL3dkeElBY2dBa0YvYzNGQkgzWnFOZ0ljSUFrZ0ZpQUpFQVlnQlNnQ3pBRWhDaUFGS0FMSUFTRURJQUFnQlNnQ3hBRWlBaUFGS0FMQUFTSUdRUjkyYWlJRUlBSnFJZ2MyQWtRZ0FDQURJQU1nQWlBRVFYOXpjU0FFSUFkeklBSWdCSE55SUFkemNrRWZkbW9pQW1vaUJEWUNTQ0FBSUFwQkFYUWdBeUFDUVg5emNTQUNJQVJ6SUFJZ0EzTnlJQVJ6Y2tFZmRuSWlBMEgvLy8vL0IzRTJBa3dnQUVGQWF5QUdRUUYwSUFOQkgzWnlOZ0lBSUFVb0F0d0JJUW9nQlNnQzJBRWhBeUFBSUFVb0F0UUJJZ0lnQlNnQzBBRWlCa0VmZG1vaUJDQUNhaUlITmdKVUlBQWdBeUFESUFJZ0JFRi9jM0VnQkNBSGN5QUNJQVJ6Y2lBSGMzSkJIM1pxSWdKcUlnUTJBbGdnQUNBS1FRRjBJQU1nQWtGL2MzRWdBaUFFY3lBQ0lBTnpjaUFFYzNKQkgzWnlJZ05CLy8vLy93ZHhOZ0pjSUFBZ0JrRUJkQ0FEUVI5MmNqWUNVQ0FKUWVBSUlBa1FCaUFTUVFGcUloSkJCRWNOQUFzZ0JVR2dBbW9rQUF1Y0N3RVdmeU1BUVVCcUlnRWtBQ0FBUVNCcUlBRkJJR29pRFJBSUlBQWdBUkFJSUFFb0Fqd2hEaUFCS0FJY0lROGdBU2dDR0NFQUlBRW9BamdoQWlBQktBSVVJUVVnQVNnQ05DRUlJQUVvQWl3aEVTQUJLQUlNSVJJZ0FTZ0NDQ0VESUFFb0FpZ2hCQ0FCS0FJQUlRY2dBU2dDSUNFSklBRW9BZ1FoQ3lBQktBSWtJUXdnQVNnQ0VDRUdJQUVvQWpBaENpQU5JQUVnRFJBR1FlQUlJQTBnQVJBR0lBRWdEaUFQSUFJZ0FDQUNJQUJySWc1eklBQWdBbk55YzBFZmRpQUlJQVVnQ0NBRmF5SU5jeUFGSUFoemNuTkJIM1lnQ2lBR0lBb2dCbXNpQ0hNZ0JpQUtjM0p6UVI5MklnWWdEVVZ4Y2lJS0lBNUZjWEpxYXlJUFFmLy8vLzhIY1NBQktBSVlJZ1VnQlNBQktBSVVJZ0lnQWlBQktBSVFJZ0FnQUNBQktBSWNJaEJCSDNacUlnQkJmM054UVI5MmFpSUNRWDl6Y1VFZmRtb2lCVUYvYzNGQkgzWWdFRUgvLy8vL0IzRnFJQTlCSDNZaUR5QUlSWEVpRUNBTklBWnJJZzFGY1NJR0lBNGdDbXNpQ2tWeGFpQUtJQVpySWdZZ0JXc2lDaUFGY3lBRklBWnpjaUFHYzBFZmRpQU5JQkJySWdVZ0Ftc2lCaUFDY3lBQ0lBVnpjaUFGYzBFZmRpQUlJQTlySWdJZ0FHc2lCU0FBY3lBQUlBSnpjaUFDYzBFZmRpSUFJQVpGY1hJaUFpQUtSWEZ5YW1zaUNFSC8vLy8vQjNFZ0NFRWZkaUlOSUFWRmNTSVBJQVlnQUdzaUVFVnhJaE1nQ2lBQ2F5SVVSWEZySWdnMkFqd2dBU2dDQUNFQUlBRW9BZ1FoQWlBQktBSUlJUVlnQVNnQ0RDRVZJQUZCUUdza0FDQUpJQWRySWdvZ0VTQVNJQVFnQXlBRUlBTnJJZzV6SUFNZ0JITnljMEVmZGlBTUlBc2dEQ0FMYXlJRGN5QUxJQXh6Y25OQkgzWWdDU0FISUFweklBY2dDWE55YzBFZmRpSU1JQU5GY1hJaUVTQU9SWEZ5YW1zaUFVRWZkaUlTYXlJRUlBQkJBV29pRmlBVklBWWdCaUFDSUFJZ0FFRitJQUJyY1VFZmRtb2lCMEYvYzNGQkgzWnFJZ2xCZjNOeFFSOTJhaUlDUVI5MmFpSUFheUlMSUFGQi8vLy8vd2R4SUFKQi8vLy8vd2R4SUFrZ0NTQUhJQWNnRmlBQVFYOXpjVUVmZG1vaUFVRi9jM0ZCSDNacUlnSkJmM054UVI5MmFpQVNJQXBGY1NJSklBTWdER3NpREVWeElnTWdEaUFSYXlJSFJYRnFJQWNnQTJzaUF5QUNheUlISUFKeklBSWdBM055SUFOelFSOTJJQXdnQ1dzaUFpQUJheUlESUFGeklBRWdBbk55SUFKelFSOTJJQUFnQzNNZ0FDQUVjM0lnQkhOQkgzWWlBQ0FEUlhGeUlnUWdCMFZ4Y21wcklnbEJIM1lpREdzaUFVRUJhaUlDUVg0Z0F5QUFheUlESUF3Z0MwVnhJZ3RySWdCcklBQkJmM055SUFCelFSOTJRWDRnQVdzZ0FVRi9jM0lnQVhOQkgzWWlBU0FBUVFGcUlnd2dBRWx4Y2lJR0lBY2dCR3NpQkNBTElBTkZjU0lEYXlJQVFRRnFJZ2NnQUVseFFYNGdBR3NnQUVGL2MzSWdBSE5CSDNaeUlnc2dDVUgvLy8vL0IzRWdBeUFFUlhGcklnQkIvLy8vL3dkcklnTkZjU0FESUFCQmYzTnhRUjkyY2lJQWF5SUVJQXdnQVdzaUNTQUVJQUlnQkhNZ0FrRUFJQUJySWdGemNuTkJIM1pxSWdJZ0FHc2lCSElnQnlBR2F5SUhJQWtnQWtGL2MzRWdBaUFFY3lBQklBSnpjaUFFYzNKQkgzWnFJZ0lnQUdzaUFISUVmMEVBQlNBRElBdHJJQUZCQVhacUlBY2dBa0YvYzNFZ0FDQUNjeUFCSUFKemNpQUFjM0pCSDNWR0N5QUZJQTFySWdGQkFXb2lBa0YrSUJBZ0Qyc2lBR3NnQUVGL2MzSWdBSE5CSDNaQmZpQUJheUFCUVg5emNpQUJjMEVmZGlJRElBQkJBV29pQkNBQVNYRnlJZ2NnRkNBVGF5SUFRUUZxSWdrZ0FFbHhRWDRnQUdzZ0FFRi9jM0lnQUhOQkgzWnlJZ3NnQ0VILy8vLy9CMnNpQlVWeElBVWdDRUYvYzNGQkgzWnlJZ0JySWdGRmNTQUVJQU5ySWdNZ0FTQUJJQUp6SUFKQkFDQUFheUlCYzNKelFSOTJhaUlDSUFCcklnaEZjU0FKSUFkcklnUWdBeUFDUVg5emNTQUNJQWh6SUFFZ0FuTnlJQWh6Y2tFZmRtb2lBaUFBYXlJQVJYRWdCU0FMYXlBQlFRRjJhaUFFSUFKQmYzTnhJQUFnQW5NZ0FTQUNjM0lnQUhOeVFSOTFSbkVMd0FFQkJIOGpBRUhnQUdzaUFTUUFJQUFRU1NBQVFSQnFFQjBnQUVIUUFHb1FIU0FBUVRCcUVCMGdBRUZBYXlJQ0lBRVFDQ0FBSUFGQlFHc2lBeEFJSUFBZ0FTQUFFQVlnQVVHQWpnSWdBaEFHSUFGQm9JNENJQUZCSUdvaUJCQUdJQUZCd0k0Q0lBRVFCaUFESUFJZ0FoQUhJQU1nQVNBQkVBY2dBeUFFSUFRUUJ5QUJFRWNnQWlBQVFTQnFJZ01nQWhBR0lBQWdBU0FBRUFZZ0JDQUNJQU1RQmlBQVFlQ09BaUFBRUFZZ0FpQUJJQUlRQmlBQUVFWWdBVUhnQUdva0FBc1dBRUdFbUFKQmxKY0NOZ0lBUWJ5WEFrRXFOZ0lBQzZjREFRUi9Jd0JCRUdzaUFpUUFJQUlnQURZQ0RDQUNJQUUyQWdnZ0FrSDhod0kyQWdRZ0FrR3hpQUkyQWdCQkFDRUJJd0JCRUdzaUF5UUFJQU1nQWpZQ0RDTUFRZEFCYXlJQUpBQWdBQ0FDTmdMTUFTQUFRYUFCYWlJQ1FRQkJLQkFPSUFBZ0FDZ0N6QUUyQXNnQkFrQkJBQ0FBUWNnQmFpQUFRZEFBYWlBQ0VEaEJBRWdOQUVHMGtnSW9BZ0JCQUU0aEJFSG9rUUlvQWdBaEFrR3drZ0lvQWdCQkFFd0VRRUhva1FJZ0FrRmZjVFlDQUFzQ2Z3SkFBa0JCbUpJQ0tBSUFSUVJBUVppU0FrSFFBRFlDQUVHRWtnSkJBRFlDQUVINGtRSkNBRGNEQUVHVWtnSW9BZ0FoQVVHVWtnSWdBRFlDQUF3QkMwSDRrUUlvQWdBTkFRdEJmMEhva1FJUU5BMEJHZ3RCNkpFQ0lBQkJ5QUZxSUFCQjBBQnFJQUJCb0FGcUVEZ0xJUVVnQVFSL1FlaVJBa0VBUVFCQmpKSUNLQUlBRVFNQUdrR1lrZ0pCQURZQ0FFR1VrZ0lnQVRZQ0FFR0VrZ0pCQURZQ0FFSDRrUUpCQURZQ0FFSDhrUUlvQWdBYVFmeVJBa0VBTmdJQVFRQUZJQVVMR2tIb2tRSkI2SkVDS0FJQUlBSkJJSEZ5TmdJQUlBUkZEUUFMSUFCQjBBRnFKQUFnQTBFUWFpUUFRUUVRQXdBTFZRRURmMEhyaHdJaEF5QUFMUUFBSVFFQ1FFSHJod0l0QUFBaUFrVU5BQ0FCSUFKSERRQURRQ0FBTFFBQklRRWdBeTBBQVNJQ1JRMEJJQUJCQVdvaEFDQURRUUZxSVFNZ0FTQUNSZzBBQ3dzZ0FpQUJhd3ZNREFFSGZ3SkFJQUJGRFFBZ0FFRUlheUlESUFCQkJHc29BZ0FpQVVGNGNTSUFhaUVGQWtBZ0FVRUJjUTBBSUFGQkEzRkZEUUVnQXlBREtBSUFJZ0ZySWdOQmpKTUNLQUlBU1EwQklBQWdBV29oQUNBRFFaQ1RBaWdDQUVjRVFDQUJRZjhCVFFSQUlBTW9BZ2dpQWlBQlFRTjJJZ1JCQTNSQnBKTUNha1lhSUFJZ0F5Z0NEQ0lCUmdSQVFmeVNBa0g4a2dJb0FnQkJmaUFFZDNFMkFnQU1Bd3NnQWlBQk5nSU1JQUVnQWpZQ0NBd0NDeUFES0FJWUlRWUNRQ0FESUFNb0Fnd2lBVWNFUUNBREtBSUlJZ0lnQVRZQ0RDQUJJQUkyQWdnTUFRc0NRQ0FEUVJScUlnSW9BZ0FpQkEwQUlBTkJFR29pQWlnQ0FDSUVEUUJCQUNFQkRBRUxBMEFnQWlFSElBUWlBVUVVYWlJQ0tBSUFJZ1FOQUNBQlFSQnFJUUlnQVNnQ0VDSUVEUUFMSUFkQkFEWUNBQXNnQmtVTkFRSkFJQU1nQXlnQ0hDSUNRUUowUWF5VkFtb2lCQ2dDQUVZRVFDQUVJQUUyQWdBZ0FRMEJRWUNUQWtHQWt3SW9BZ0JCZmlBQ2QzRTJBZ0FNQXdzZ0JrRVFRUlFnQmlnQ0VDQURSaHRxSUFFMkFnQWdBVVVOQWdzZ0FTQUdOZ0lZSUFNb0FoQWlBZ1JBSUFFZ0FqWUNFQ0FDSUFFMkFoZ0xJQU1vQWhRaUFrVU5BU0FCSUFJMkFoUWdBaUFCTmdJWURBRUxJQVVvQWdRaUFVRURjVUVEUncwQVFZU1RBaUFBTmdJQUlBVWdBVUYrY1RZQ0JDQURJQUJCQVhJMkFnUWdBQ0FEYWlBQU5nSUFEd3NnQXlBRlR3MEFJQVVvQWdRaUFVRUJjVVVOQUFKQUlBRkJBbkZGQkVBZ0JVR1Vrd0lvQWdCR0JFQkJsSk1DSUFNMkFnQkJpSk1DUVlpVEFpZ0NBQ0FBYWlJQU5nSUFJQU1nQUVFQmNqWUNCQ0FEUVpDVEFpZ0NBRWNOQTBHRWt3SkJBRFlDQUVHUWt3SkJBRFlDQUE4TElBVkJrSk1DS0FJQVJnUkFRWkNUQWlBRE5nSUFRWVNUQWtHRWt3SW9BZ0FnQUdvaUFEWUNBQ0FESUFCQkFYSTJBZ1FnQUNBRGFpQUFOZ0lBRHdzZ0FVRjRjU0FBYWlFQUFrQWdBVUgvQVUwRVFDQUZLQUlJSWdJZ0FVRURkaUlFUVFOMFFhU1RBbXBHR2lBQ0lBVW9BZ3dpQVVZRVFFSDhrZ0pCL0pJQ0tBSUFRWDRnQkhkeE5nSUFEQUlMSUFJZ0FUWUNEQ0FCSUFJMkFnZ01BUXNnQlNnQ0dDRUdBa0FnQlNBRktBSU1JZ0ZIQkVBZ0JTZ0NDQ0lDUVl5VEFpZ0NBRWthSUFJZ0FUWUNEQ0FCSUFJMkFnZ01BUXNDUUNBRlFSUnFJZ0lvQWdBaUJBMEFJQVZCRUdvaUFpZ0NBQ0lFRFFCQkFDRUJEQUVMQTBBZ0FpRUhJQVFpQVVFVWFpSUNLQUlBSWdRTkFDQUJRUkJxSVFJZ0FTZ0NFQ0lFRFFBTElBZEJBRFlDQUFzZ0JrVU5BQUpBSUFVZ0JTZ0NIQ0lDUVFKMFFheVZBbW9pQkNnQ0FFWUVRQ0FFSUFFMkFnQWdBUTBCUVlDVEFrR0Frd0lvQWdCQmZpQUNkM0UyQWdBTUFnc2dCa0VRUVJRZ0JpZ0NFQ0FGUmh0cUlBRTJBZ0FnQVVVTkFRc2dBU0FHTmdJWUlBVW9BaEFpQWdSQUlBRWdBallDRUNBQ0lBRTJBaGdMSUFVb0FoUWlBa1VOQUNBQklBSTJBaFFnQWlBQk5nSVlDeUFESUFCQkFYSTJBZ1FnQUNBRGFpQUFOZ0lBSUFOQmtKTUNLQUlBUncwQlFZU1RBaUFBTmdJQUR3c2dCU0FCUVg1eE5nSUVJQU1nQUVFQmNqWUNCQ0FBSUFOcUlBQTJBZ0FMSUFCQi93Rk5CRUFnQUVFRGRpSUJRUU4wUWFTVEFtb2hBQUovUWZ5U0FpZ0NBQ0lDUVFFZ0FYUWlBWEZGQkVCQi9KSUNJQUVnQW5JMkFnQWdBQXdCQ3lBQUtBSUlDeUVDSUFBZ0F6WUNDQ0FDSUFNMkFnd2dBeUFBTmdJTUlBTWdBallDQ0E4TFFSOGhBaUFEUWdBM0FoQWdBRUgvLy84SFRRUkFJQUJCQ0hZaUFTQUJRWUQrUDJwQkVIWkJDSEVpQVhRaUFpQUNRWURnSDJwQkVIWkJCSEVpQW5RaUJDQUVRWUNBRDJwQkVIWkJBbkVpQkhSQkQzWWdBU0FDY2lBRWNtc2lBVUVCZENBQUlBRkJGV3AyUVFGeGNrRWNhaUVDQ3lBRElBSTJBaHdnQWtFQ2RFR3NsUUpxSVFFQ1FBSkFBa0JCZ0pNQ0tBSUFJZ1JCQVNBQ2RDSUhjVVVFUUVHQWt3SWdCQ0FIY2pZQ0FDQUJJQU0yQWdBZ0F5QUJOZ0lZREFFTElBQkJBRUVaSUFKQkFYWnJJQUpCSDBZYmRDRUNJQUVvQWdBaEFRTkFJQUVpQkNnQ0JFRjRjU0FBUmcwQ0lBSkJIWFloQVNBQ1FRRjBJUUlnQkNBQlFRUnhhaUlIUVJCcUtBSUFJZ0VOQUFzZ0J5QUROZ0lRSUFNZ0JEWUNHQXNnQXlBRE5nSU1JQU1nQXpZQ0NBd0JDeUFFS0FJSUlnQWdBellDRENBRUlBTTJBZ2dnQTBFQU5nSVlJQU1nQkRZQ0RDQURJQUEyQWdnTFFaeVRBa0dja3dJb0FnQkJBV3NpQUVGL0lBQWJOZ0lBQ3d1T0JBRUVmeU1BUVNCcklnUWtBRUVCSVFNQ1FDQUFLQUtvQTBFQlJnUkFJQUFvQXFRRElRTUNRQUpBQWtBZ0FDZ0NvQU5GQkVBZ0FFSFFBV29pQlNBQklBSkJnTUFBSUFOcklnTWdBaUFEU1JzaUF4QVpJQUFnQXlBQUtBS2tBMm9pQmpZQ3BBTWdBaUFEYXlFQ0lBRWdBMm9oQVNBR1FZREFBRWNOQVNBQ1JRMEJJQVJCQXpvQUFDQUFRZ0UzQTZBRElBVWdCRUVCRUJrZ0FDQUFMUUNZQTBFSGFrSDRBWEU2QUpnRERBSUxJQU5GRFFBZ0FDQUJJQUpCZ01BQUlBTnJJZ01nQWlBRFNSc2lBeEFaSUFBZ0FDZ0NwQU1nQTJvaUJUWUNwQU1nQWlBRGF5RUNJQUVnQTJvaEFTQUZRWURBQUVjTkFDQUFRUUEyQXFRRElBQWdBQ2dDb0FOQkFXbzJBcUFESUFBdEFNa0JEUVFnQUVFTElBQXRBTWdCRUJJZ0FFR0FBVUduQVJBU0FrQWdBQkFWQ3lBQVFZQUNPd0RJQVNBQUlBUkJJQkFsSUFCQjBBRnFJQVJCSUJBWkN5QUNSUTBCQ3lBQVFkQUJhaUVGQTBBZ0FCQkJJQUJCQURzQXlBRWdBQ0FCSUFKQmdNQUFJQUpCZ01BQVNTSUdHeUlERUJrQ1FDQUdSUVJBSUFBZ0FDZ0NvQU5CQVdvMkFxQURJQUF0QU1rQkRRVWdBRUVMSUFBdEFNZ0JFQklnQUVHQUFVR25BUkFTQWtBZ0FCQVZDeUFBUVlBQ093RElBU0FBSUFSQklCQWxJQVVnQkVFZ0VCa01BUXNnQUNBRE5nS2tBd3NnQVNBRGFpRUJJQUlnQTJzaUFnMEFDd3RCQUNFREN5QUVRU0JxSkFBZ0F3OExRZGdBUWEySEFoQXJBQXV0QXdJQmZ3WitJd0JCSUdzaUFpUUFJQUJCNEl3Q0lBSkJHR29RSkNBQVFZQ05BaUFDUVJCcUVDUWdBRUdnalFJZ0FrRUlhaEFrSUFCQndJMENJQUlRSkNBQklBSXBBeGdpQTBMUnpPZTFtUFBjcHdoK0lBSXBBeEFpQkVLd3NMcVJ0OGlPa2xwK2ZDQUNLUU1JSWdWQzZlVEUvck9YNUxCMWZud2dBaWtEQUNJR1F1cVYrTGFKajhMcUdINThJQUFwQXdBZ0EwTHF2UDM2Z1p2QS9IWitmQ0FFUXF6NmpOalhncW5iWW41OElBVkMvdm1ENTYzY2xLcG9mbndnQmtMQjc5ejMxdjd5eUd4K2ZDSUlRZ0dEUWdGOUlnZEM2cFg0dG9tUHd1b1lnMzFDOTVDNnR2VzkzK0xyQUh3M0F4Z2dBU0FEUXZINTM1bmgrZWZlZUg0Z0JIMGdCVUtmaVovSm1MbklwaTUrZkNBR1FyWFRvdFdDdnBMRkJuNThJQWRDdGRPaTFZSytrc1VHZzMxQytQU1hzY1N2dE9uOUFIdzNBeEFnQVNBRUlBTkNvTnVva2F5TStyRVRmbndnQlVLdnk5emowZHozblgxK2ZDQUdRczZCL09Dam1zanVUbjU4SUFkQ3N2NkRuOXpsdDVFeGczeEM3TjZkNmEzaDF2elpBSHczQXdnZ0FTQUlJQWRDdjVDamlLbUJqYmNUZzN4Q25LdVJqYVdLaTZUeUFIdzNBd0FnQWtFZ2FpUUFDNFlCQVFGL0lBQWdBRUVnYWlJQ0lBRVFCeUFDSUFBZ0FVRWdhaEFOSUFCQjRBQnFJQUJCZ0FGcUlBRkI0QUJxRUFZZ0FVRkFheUFBUVVCcktBSUFOZ0lBSUFFZ0FDZ0NSRFlDUkNBQklBQW9Ba2cyQWtnZ0FTQUFLQUpNTmdKTUlBRWdBQ2dDVURZQ1VDQUJJQUFvQWxRMkFsUWdBU0FBS0FKWU5nSllJQUVnQUNnQ1hEWUNYQXZSQ3dFU2Z5TUFRVEJySWdJa0FDQUFRVUJySWdNZ0F5QUNFQVVnQTBFUWFpSUdJQVlnQWtFUWFoQUZJQUlnQWlnQ0hDQUNLQUlNYWlBQ0tBSUlJZ2dnQWlnQ0JDSUpJQUlvQWhBaUJ5QUNLQUlBSWdWcUlnUWdCWE1nQlNBSGMzSWdCSE5CSDNacUlnVWdBaWdDRkNJS2FpSUhJQVZ6SUFVZ0NuTnlJQWR6SUFrZ0JVRi9jM0Z5UVI5MmFpSUZJQUlvQWhnaUNtb2lDU0FGY3lBRklBcHpjaUFKY3lBSUlBVkJmM054Y2tFZmRtb2lCVUVmZGlBRWFpSUlOZ0lBSUFJZ0JDQUlRWDl6Y1VFZmRpQUhhaUlFTmdJRUlBSWdCeUFFUVg5emNVRWZkaUFKYWlJRU5nSUlJQUlnQlVILy8vLy9CM0VnQ1NBRVFYOXpjVUVmZG1vMkFnd2dBaUFDUVNCcUlnUVFTaUFFSUFRZ0JCQUZJQVFnQkNBRUVBVWdBaUFFSUFJUUJTQUdJQVlvQWdCQmYzTTJBZ0FnQXlBREtBSVVRWDl6TmdJVUlBTWdBeWdDR0VGL2N6WUNHQ0FEUWYvLy8vOEhJQU1vQWh4ck5nSWNJQU1nQWlBREVBVWdCaUFDSUFZUUJTQUNRVEJxSkFBZ0FDQURJQUVRQmlBQVFTQnFJQU1nQVVFZ2FoQUdJQUVnQVNnQ0FDSUNRUUZxSWdSQmZpQUJLQUlFSWdCcklBQkJmM055SUFCelFSOTJRWDRnQW1zZ0FrRi9jM0lnQW5OQkgzWWlDaUFBUVFGcUlnc2dBRWx4Y2lJTUlBRW9BZ2dpQUVFQmFpSU9JQUJKY1VGK0lBQnJJQUJCZjNOeUlBQnpRUjkyY2lJUElBRW9BZ3dpQUVILy8vLy9CMnNpQjBWeElBY2dBRUYvYzNGQkgzWnlJZ0pySWdZMkFnQWdBU0FCS0FJUUlnTkJBV29pQlVGK0lBRW9BaFFpQUdzZ0FFRi9jM0lnQUhOQkgzWkJmaUFEYXlBRFFYOXpjaUFEYzBFZmRpSU5JQUJCQVdvaUVDQUFTWEZ5SWhFZ0FTZ0NHQ0lBUVFGcUloSWdBRWx4UVg0Z0FHc2dBRUYvYzNJZ0FITkJIM1p5SWhNZ0FTZ0NIQ0lBUWYvLy8vOEhheUlKUlhFZ0NTQUFRWDl6Y1VFZmRuSWlBR3NpQ0RZQ0VDQUJJQXNnQ21zaUN5QUVJQVp6SUFSQkFDQUNheUlEYzNJZ0JuTkJIM1pxSWdRZ0Ftc2lDallDQkNBQklCQWdEV3NpRFNBRklBaHpJQVZCQUNBQWF5SUdjM0lnQ0hOQkgzWnFJZ1VnQUdzaUNEWUNGQ0FCSUE0Z0RHc2lEQ0FMSUFSQmYzTnhJQVFnQ25NZ0F5QUVjM0lnQ25OeVFSOTJhaUlFSUFKcklnbzJBZ2dnQVNBU0lCRnJJZ3NnRFNBRlFYOXpjU0FGSUFoeklBVWdCbk55SUFoemNrRWZkbW9pQWlBQWF5SUFOZ0lZSUFFZ0J5QVBheUFEUVFGMmFpQU1JQVJCZjNOeElBUWdDbk1nQXlBRWMzSWdDbk55UVI5MmFqWUNEQ0FCSUFrZ0Uyc2dCa0VCZG1vZ0N5QUNRWDl6Y1NBQUlBSnpJQUlnQm5OeUlBQnpja0VmZG1vMkFod2dBU0FCS0FJZ0lnSkJBV29pQTBGK0lBRW9BaVFpQUdzZ0FFRi9jM0lnQUhOQkgzWkJmaUFDYXlBQ1FYOXpjaUFDYzBFZmRpSUdJQUJCQVdvaUJTQUFTWEZ5SWdjZ0FTZ0NLQ0lBUVFGcUlna2dBRWx4UVg0Z0FHc2dBRUYvYzNJZ0FITkJIM1p5SWdnZ0FTZ0NMQ0lBUWYvLy8vOEhheUlDUlhFZ0FpQUFRWDl6Y1VFZmRuSWlBR3NpQkRZQ0lDQUJJQUlnQ0d0QkFDQUFheUlDUVFGMmFpQUpJQWRySWdjZ0JTQUdheUlHSUFNZ0JITWdBaUFEYzNJZ0JITkJIM1pxSWdNZ0FHc2lCQ0FEY3lBQ0lBTnpjaUFFY3lBR0lBTkJmM054Y2tFZmRtb2lBeUFBYXlJQUlBTnpJQUlnQTNOeUlBQnpJQWNnQTBGL2MzRnlRUjkyYWpZQ0xDQUJJQUEyQWlnZ0FTQUVOZ0lrSUFFZ0FTZ0NNQ0lDUVFGcUlnTkJmaUFCS0FJMElnQnJJQUJCZjNOeUlBQnpRUjkyUVg0Z0Ftc2dBa0YvYzNJZ0FuTkJIM1lpQWlBQVFRRnFJZ1VnQUVseGNpSUhJQUVvQWpnaUFFRUJhaUlKSUFCSmNVRitJQUJySUFCQmYzTnlJQUJ6UVI5MmNpSUlJQUVvQWp3aUFFSC8vLy8vQjJzaUJFVnhJQVFnQUVGL2MzRkJIM1p5SWdCcklnWTJBakFnQVNBRklBSnJJZ1VnQmlBRElBWnpJQU5CQUNBQWF5SUNjM0p6UVI5MmFpSURJQUJySWdZMkFqUWdBU0FKSUFkcklnY2dCU0FEUVg5emNTQURJQVp6SUFJZ0EzTnlJQVp6Y2tFZmRtb2lBeUFBYXlJQU5nSTRJQUVnQkNBSWF5QUNRUUYyYWlBSElBTkJmM054SUFBZ0EzTWdBaUFEYzNJZ0FITnlRUjkyYWpZQ1BBdVdBZ0VKZnlBQUlBQW9BZ0FpQVVFQmFpSUVRWDRnQUNnQ0NDSUNheUFDUVg5emNpQUNjMEVmZGtGK0lBQW9BZ1FpQTJzZ0EwRi9jM0lnQTNOQkgzWkJmaUFCYXlBQlFYOXpjaUFCYzBFZmRpSUJJQU5CQVdvaUJTQURTWEZ5SWdZZ0FrRUJhaUlJSUFKSmNYSWlDU0FBS0FJTUlnSkIvLy8vL3dkcklnZEZjU0FISUFKQmYzTnhRUjkyY2lJQ2F5SUROZ0lBSUFBZ0JTQUJheUlGSUFNZ0F5QUVjeUFFUVFBZ0Ftc2lBM055YzBFZmRtb2lBU0FDYXlJRU5nSUVJQUFnQ0NBR2F5SUdJQVVnQVVGL2MzRWdBU0FFY3lBQklBTnpjaUFFYzNKQkgzWnFJZ0VnQW1zaUFqWUNDQ0FBSUFZZ0FVRi9jM0VnQVNBQ2N5QUJJQU56Y2lBQ2MzSkJIM1lnQTBFQmRtb2dCeUFKYTJvMkFnd0w0UUVCQ1g4Z0FpQUFLQUlBSWdNZ0FTZ0NBQ0lFYXlJSE5nSUFJQUlnQUNnQ0JDSUZJQUVvQWdRaUJtc2lDQ0FESUFRZ0IzTWdBeUFFYzNKelFSOTJJZ3RySWdNMkFnUWdBaUFBS0FJSUlnUWdBU2dDQ0NJSmF5SUtJQXNnQ0VWeElBVWdCaUFJY3lBRklBWnpjbk5CSDNaeUlnWnJJZ1UyQWdnZ0FpQUhJQUFvQWd3Z0FTZ0NEQ0FHSUFwRmNTQUVJQWtnQ25NZ0JDQUpjM0p6UVI5MmNtcHJJZ0JCSDNZaUFXczJBZ0FnQWlBRElBRWdCMFZ4SWdGck5nSUVJQUlnQlNBQklBTkZjU0lCYXpZQ0NDQUNJQUJCLy8vLy93ZHhJQUVnQlVWeGF6WUNEQXRaQVFGL0lBQWdBQ2dDU0NJQlFRRnJJQUZ5TmdKSUlBQW9BZ0FpQVVFSWNRUkFJQUFnQVVFZ2NqWUNBRUYvRHdzZ0FFSUFOd0lFSUFBZ0FDZ0NMQ0lCTmdJY0lBQWdBVFlDRkNBQUlBRWdBQ2dDTUdvMkFoQkJBQXV0Q1FFamZ5QUFLQUo4SVFvZ0FDZ0NlQ0VZSUFBb0FuUWhHU0FBS0FKd0lSb2dBQ2dDYkNFTElBQW9BbWdoR3lBQUtBSmtJUndnQUNnQ1lDRWRJQUFvQWx3aEhpQUFLQUpZSVI4Z0FDZ0NWQ0VnSUFBb0FsQWhJU0FBS0FKTUlTSWdBQ2dDU0NFaklBQW9Ba1FoSkNBQVFVQnJLQUlBSVNVZ0FDZ0NQQ0VNSUFBb0FqZ2hEU0FBS0FJMElRNGdBQ2dDTUNFUElBQW9BaXdoRUNBQUtBSW9JUkVnQUNnQ0pDRVNJQUFvQWlBaEV5QUFLQUljSVFZZ0FDZ0NHQ0VISUFBb0FoUWhDQ0FBS0FJUUlRa2dBQ2dDRENFVUlBQW9BZ2doRlNBQUtBSUVJUllnQUNnQ0FDRVhRUUVoSmdOQUlBSkJBV3NpQWtFZmRrRUJheUlFSUFBZ0prRUhkR29pQlNnQ0FDQVhjM0VnRjNNaEZ5QUZLQUo4SUFweklBUnhJQXB6SVFvZ0JTZ0NiQ0FMY3lBRWNTQUxjeUVMSUFVb0Fsd2dIbk1nQkhFZ0huTWhIaUFGS0FKTUlDSnpJQVJ4SUNKeklTSWdCU2dDUENBTWN5QUVjU0FNY3lFTUlBVW9BaXdnRUhNZ0JIRWdFSE1oRUNBRktBSWNJQVp6SUFSeElBWnpJUVlnQlNnQ0RDQVVjeUFFY1NBVWN5RVVJQVVvQW5nZ0dITWdCSEVnR0hNaEdDQUZLQUpvSUJ0eklBUnhJQnR6SVJzZ0JTZ0NXQ0FmY3lBRWNTQWZjeUVmSUFVb0FrZ2dJM01nQkhFZ0kzTWhJeUFGS0FJNElBMXpJQVJ4SUExeklRMGdCU2dDS0NBUmN5QUVjU0FSY3lFUklBVW9BaGdnQjNNZ0JIRWdCM01oQnlBRktBSUlJQlZ6SUFSeElCVnpJUlVnQlNnQ2RDQVpjeUFFY1NBWmN5RVpJQVVvQW1RZ0hITWdCSEVnSEhNaEhDQUZLQUpVSUNCeklBUnhJQ0J6SVNBZ0JTZ0NSQ0FrY3lBRWNTQWtjeUVrSUFVb0FqUWdEbk1nQkhFZ0RuTWhEaUFGS0FJa0lCSnpJQVJ4SUJKeklSSWdCU2dDRkNBSWN5QUVjU0FJY3lFSUlBVW9BZ1FnRm5NZ0JIRWdGbk1oRmlBRktBSndJQnB6SUFSeElCcHpJUm9nQlNnQ1lDQWRjeUFFY1NBZGN5RWRJQVVvQWxBZ0lYTWdCSEVnSVhNaElTQUZRVUJyS0FJQUlDVnpJQVJ4SUNWeklTVWdCU2dDTUNBUGN5QUVjU0FQY3lFUElBVW9BaUFnRTNNZ0JIRWdFM01oRXlBRktBSVFJQWx6SUFSeElBbHpJUWtnSmtFQmFpSW1RUWhIRFFBTElBRWdIallDWENBQklCODJBbGdnQVNBZ05nSlVJQUVnSVRZQ1VDQUJJQ0kyQWt3Z0FTQWpOZ0pJSUFFZ0pEWUNSQ0FCUVVCcklDVTJBZ0FnQVNBRElCaHpRWDl6TmdKNElBRWdBeUFaYzBGL2N6WUNkQ0FCSUFNZ0duTkJmM00yQW5BZ0FTQURJQnR6UVg5ek5nSm9JQUVnQXlBY2MwRi9jellDWkNBQklBTWdIWE5CZjNNMkFtQWdBU0FHSUF4eklBTnhJZ0FnQm5NMkFqd2dBU0FISUExeklBTnhJZ0lnQjNNMkFqZ2dBU0FJSUE1eklBTnhJZ1FnQ0hNMkFqUWdBU0FKSUE5eklBTnhJZ1VnQ1hNMkFqQWdBU0FRSUJSeklBTnhJZ1lnRkhNMkFpd2dBU0FSSUJWeklBTnhJZ2NnRlhNMkFpZ2dBU0FTSUJaeklBTnhJZ2dnRm5NMkFpUWdBU0FUSUJkeklBTnhJZ2tnRjNNMkFpQWdBU0FBSUF4ek5nSWNJQUVnQWlBTmN6WUNHQ0FCSUFRZ0RuTTJBaFFnQVNBRklBOXpOZ0lRSUFFZ0JpQVFjellDRENBQklBY2dFWE0yQWdnZ0FTQUlJQkp6TmdJRUlBRWdDU0FUY3pZQ0FDQUJRZi8vLy84SElBcHJJZ0FnQ25NZ0EzRWdBSE0yQW53Z0FVSC8vLy8vQnlBTGF5SUFJQXR6SUFOeElBQnpOZ0pzQzd3Q0FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQVVFSmF3NFNBQWdKQ2dnSkFRSURCQW9KQ2dvSUNRVUdCd3NnQWlBQ0tBSUFJZ0ZCQkdvMkFnQWdBQ0FCS0FJQU5nSUFEd3NnQWlBQ0tBSUFJZ0ZCQkdvMkFnQWdBQ0FCTWdFQU53TUFEd3NnQWlBQ0tBSUFJZ0ZCQkdvMkFnQWdBQ0FCTXdFQU53TUFEd3NnQWlBQ0tBSUFJZ0ZCQkdvMkFnQWdBQ0FCTUFBQU53TUFEd3NnQWlBQ0tBSUFJZ0ZCQkdvMkFnQWdBQ0FCTVFBQU53TUFEd3NnQWlBQ0tBSUFRUWRxUVhoeElnRkJDR28yQWdBZ0FDQUJLd01BT1FNQUR3c2dBQ0FDUVFZUkFBQUxEd3NnQWlBQ0tBSUFJZ0ZCQkdvMkFnQWdBQ0FCTkFJQU53TUFEd3NnQWlBQ0tBSUFJZ0ZCQkdvMkFnQWdBQ0FCTlFJQU53TUFEd3NnQWlBQ0tBSUFRUWRxUVhoeElnRkJDR28yQWdBZ0FDQUJLUU1BTndNQUMzSUJBMzhnQUNnQ0FDd0FBRUV3YTBFS1R3UkFRUUFQQ3dOQUlBQW9BZ0FoQTBGL0lRRWdBa0hNbWJQbUFFMEVRRUYvSUFNc0FBQkJNR3NpQVNBQ1FRcHNJZ0pxSUFGQi8vLy8vd2NnQW10S0d5RUJDeUFBSUFOQkFXbzJBZ0FnQVNFQ0lBTXNBQUZCTUd0QkNra05BQXNnQWd1cEZBSVNmd0YrSXdCQjBBQnJJZ1VrQUNBRlFkT0lBallDVENBRlFUZHFJUlFnQlVFNGFpRVNBa0FDUUFKQUFrQURRQ0FFUWYvLy8vOEhJQXhyU2cwQklBUWdER29oRENBRktBSk1JZ2toQkFKQUFrQUNRQ0FKTFFBQUlnZ0VRQU5BQWtBQ1FDQUlRZjhCY1NJR1JRUkFJQVFoQ0F3QkN5QUdRU1ZIRFFFZ0JDRUlBMEFnQkMwQUFVRWxSdzBCSUFVZ0JFRUNhaUlHTmdKTUlBaEJBV29oQ0NBRUxRQUNJUW9nQmlFRUlBcEJKVVlOQUFzTElBZ2dDV3NpQkVILy8vLy9CeUFNYXlJVlNnMEhJQUFFUUNBQUlBa2dCQkFKQ3lBRURRWkJmeUVSUVFFaEJnSkFJQVVvQWt3aUJDd0FBVUV3YTBFS1R3MEFJQVF0QUFKQkpFY05BQ0FFTEFBQlFUQnJJUkZCQVNFVFFRTWhCZ3NnQlNBRUlBWnFJZ1EyQWt4QkFDRU5Ba0FnQkN3QUFDSUxRU0JySWdwQkgwc0VRQ0FFSVFZTUFRc2dCQ0VHUVFFZ0NuUWlCMEdKMFFSeFJRMEFBMEFnQlNBRVFRRnFJZ1kyQWt3Z0J5QU5jaUVOSUFRc0FBRWlDMEVnYXlJS1FTQlBEUUVnQmlFRVFRRWdDblFpQjBHSjBRUnhEUUFMQ3dKQUlBdEJLa1lFUUNBRkFuOENRQ0FHTEFBQlFUQnJRUXBQRFFBZ0JTZ0NUQ0lFTFFBQ1FTUkhEUUFnQkN3QUFVRUNkQ0FEYWtIQUFXdEJDallDQUNBRUxBQUJRUU4wSUFKcVFZQURheWdDQUNFT1FRRWhFeUFFUVFOcURBRUxJQk1OQmtFQUlSTkJBQ0VPSUFBRVFDQUJJQUVvQWdBaUJFRUVhallDQUNBRUtBSUFJUTRMSUFVb0FreEJBV29MSWdRMkFrd2dEa0VBVGcwQlFRQWdEbXNoRGlBTlFZREFBSEloRFF3QkN5QUZRY3dBYWhBM0lnNUJBRWdOQ0NBRktBSk1JUVFMUVFBaEJrRi9JUWNDZjBFQUlBUXRBQUJCTGtjTkFCb2dCQzBBQVVFcVJnUkFJQVVDZndKQUlBUXNBQUpCTUd0QkNrOE5BQ0FGS0FKTUlnUXRBQU5CSkVjTkFDQUVMQUFDUVFKMElBTnFRY0FCYTBFS05nSUFJQVFzQUFKQkEzUWdBbXBCZ0FOcktBSUFJUWNnQkVFRWFnd0JDeUFURFFZZ0FBUi9JQUVnQVNnQ0FDSUVRUVJxTmdJQUlBUW9BZ0FGUVFBTElRY2dCU2dDVEVFQ2Fnc2lCRFlDVENBSFFYOXpRUjkyREFFTElBVWdCRUVCYWpZQ1RDQUZRY3dBYWhBM0lRY2dCU2dDVENFRVFRRUxJUThEUUNBR0lSQkJIQ0VJSUFRc0FBQkIrd0JyUVVaSkRRa2dCU0FFUVFGcUlnczJBa3dnQkN3QUFDRUdJQXNoQkNBR0lCQkJPbXhxUWIrSUFtb3RBQUFpQmtFQmEwRUlTUTBBQ3dKQUFrQWdCa0ViUndSQUlBWkZEUXNnRVVFQVRnUkFJQU1nRVVFQ2RHb2dCallDQUNBRklBSWdFVUVEZEdvcEF3QTNBMEFNQWdzZ0FFVU5DQ0FGUVVCcklBWWdBUkEySUFVb0Frd2hDd3dDQ3lBUlFRQk9EUW9MUVFBaEJDQUFSUTBIQ3lBTlFmLy9lM0VpQ2lBTklBMUJnTUFBY1JzaEJrRUFJUTFCaEljQ0lSRWdFaUVJQWtBQ1FBSkFBbjhDUUFKQUFrQUNRQUovQWtBQ1FBSkFBa0FDUUFKQUFrQWdDMEVCYXl3QUFDSUVRVjl4SUFRZ0JFRVBjVUVEUmhzZ0JDQVFHeUlFUWRnQWF3NGhCQlFVRkJRVUZCUVVEaFFQQmc0T0RoUUdGQlFVRkFJRkF4UVVDUlFCRkJRRUFBc0NRQ0FFUWNFQWF3NEhEaFFMRkE0T0RnQUxJQVJCMHdCR0RRa01Fd3NnQlNrRFFDRVdRWVNIQWd3RkMwRUFJUVFDUUFKQUFrQUNRQUpBQWtBQ1FDQVFRZjhCY1E0SUFBRUNBd1FhQlFZYUN5QUZLQUpBSUF3MkFnQU1HUXNnQlNnQ1FDQU1OZ0lBREJnTElBVW9Ba0FnREt3M0F3QU1Gd3NnQlNnQ1FDQU1Pd0VBREJZTElBVW9Ba0FnRERvQUFBd1ZDeUFGS0FKQUlBdzJBZ0FNRkFzZ0JTZ0NRQ0FNckRjREFBd1RDeUFIUVFnZ0IwRUlTeHNoQnlBR1FRaHlJUVpCK0FBaEJBc2dFaUVKSUFSQklIRWhFQ0FGS1FOQUloWlFSUVJBQTBBZ0NVRUJheUlKSUJhblFROXhRZENNQW1vdEFBQWdFSEk2QUFBZ0ZrSVBWaUVLSUJaQ0JJZ2hGaUFLRFFBTEN5QUZLUU5BVUEwRElBWkJDSEZGRFFNZ0JFRUVka0dFaHdKcUlSRkJBaUVOREFNTElCSWhCQ0FGS1FOQUloWlFSUVJBQTBBZ0JFRUJheUlFSUJhblFRZHhRVEJ5T2dBQUlCWkNCMVloQ1NBV1FnT0lJUllnQ1EwQUN3c2dCQ0VKSUFaQkNIRkZEUUlnQnlBU0lBbHJJZ1JCQVdvZ0JDQUhTQnNoQnd3Q0N5QUZLUU5BSWhaQ0FGTUVRQ0FGUWdBZ0ZuMGlGamNEUUVFQklRMUJoSWNDREFFTElBWkJnQkJ4QkVCQkFTRU5RWVdIQWd3QkMwR0dod0pCaEljQ0lBWkJBWEVpRFJzTElSRWdGaUFTRUI0aENRc2dEMEVBSUFkQkFFZ2JEUTRnQmtILy8zdHhJQVlnRHhzaEJnSkFJQVVwQTBBaUZrSUFVZzBBSUFjTkFDQVNJZ2toQ0VFQUlRY01EQXNnQnlBV1VDQVNJQWxyYWlJRUlBUWdCMGdiSVFjTUN3c0NmMEgvLy8vL0J5QUhJQWRCQUVnYklnZ2lDMEVBUnlFUUFrQUNRQUpBSUFVb0FrQWlCRUhNaUFJZ0JCc2lDU0lHSWc5QkEzRkZEUUFnQzBVTkFBTkFJQTh0QUFCRkRRSWdDMEVCYXlJTFFRQkhJUkFnRDBFQmFpSVBRUU54UlEwQklBc05BQXNMSUJCRkRRRUxBa0FnRHkwQUFFVU5BQ0FMUVFSSkRRQURRQ0FQS0FJQUlnUkJmM01nQkVHQmdvUUlhM0ZCZ0lHQ2hIaHhEUUVnRDBFRWFpRVBJQXRCQkdzaUMwRURTdzBBQ3dzZ0MwVU5BQU5BSUE4Z0R5MEFBRVVOQWhvZ0QwRUJhaUVQSUF0QkFXc2lDdzBBQ3d0QkFBc2lCQ0FHYXlBSUlBUWJJZ1FnQ1dvaENDQUhRUUJPQkVBZ0NpRUdJQVFoQnd3TEN5QUtJUVlnQkNFSElBZ3RBQUFORFF3S0N5QUhCRUFnQlNnQ1FBd0NDMEVBSVFRZ0FFRWdJQTVCQUNBR0VBb01BZ3NnQlVFQU5nSU1JQVVnQlNrRFFENENDQ0FGSUFWQkNHb2lCRFlDUUVGL0lRY2dCQXNoQ0VFQUlRUUNRQU5BSUFnb0FnQWlDVVVOQVFKQUlBVkJCR29nQ1JBNklncEJBRWdpQ1EwQUlBb2dCeUFFYTBzTkFDQUlRUVJxSVFnZ0J5QUVJQXBxSWdSTERRRU1BZ3NMSUFrTkRRdEJQU0VJSUFSQkFFZ05DeUFBUVNBZ0RpQUVJQVlRQ2lBRVJRUkFRUUFoQkF3QkMwRUFJUWNnQlNnQ1FDRUlBMEFnQ0NnQ0FDSUpSUTBCSUFWQkJHb2dDUkE2SWdrZ0Iyb2lCeUFFU3cwQklBQWdCVUVFYWlBSkVBa2dDRUVFYWlFSUlBUWdCMHNOQUFzTElBQkJJQ0FPSUFRZ0JrR0F3QUJ6RUFvZ0RpQUVJQVFnRGtnYklRUU1DQXNnRDBFQUlBZEJBRWdiRFFoQlBTRUlJQUFnQlNzRFFDQU9JQWNnQmlBRVFRVVJDQUFpQkVFQVRnMEhEQWtMSUFVZ0JTa0RRRHdBTjBFQklRY2dGQ0VKSUFvaEJnd0VDeUFGSUFSQkFXb2lCallDVENBRUxRQUJJUWdnQmlFRURBQUxBQXNnQUEwSElCTkZEUUpCQVNFRUEwQWdBeUFFUVFKMGFpZ0NBQ0lBQkVBZ0FpQUVRUU4wYWlBQUlBRVFOa0VCSVF3Z0JFRUJhaUlFUVFwSERRRU1DUXNMUVFFaERDQUVRUXBQRFFjRFFDQURJQVJCQW5ScUtBSUFEUUVnQkVFQmFpSUVRUXBIRFFBTERBY0xRUndoQ0F3RUN5QUlJQWxySWhBZ0J5QUhJQkJJR3lJS1FmLy8vLzhISUExclNnMENRVDBoQ0NBS0lBMXFJZ2NnRGlBSElBNUtHeUlFSUJWS0RRTWdBRUVnSUFRZ0J5QUdFQW9nQUNBUklBMFFDU0FBUVRBZ0JDQUhJQVpCZ0lBRWN4QUtJQUJCTUNBS0lCQkJBQkFLSUFBZ0NTQVFFQWtnQUVFZ0lBUWdCeUFHUVlEQUFITVFDZ3dCQ3d0QkFDRU1EQU1MUVQwaENBdEIrSklDSUFnMkFnQUxRWDhoREFzZ0JVSFFBR29rQUNBTUMzNENBWDhCZmlBQXZTSURRalNJcDBIL0QzRWlBa0gvRDBjRWZDQUNSUVJBSUFFZ0FFUUFBQUFBQUFBQUFHRUVmMEVBQlNBQVJBQUFBQUFBQVBCRG9pQUJFRGtoQUNBQktBSUFRVUJxQ3pZQ0FDQUFEd3NnQVNBQ1FmNEhhellDQUNBRFF2Ly8vLy8vLy8rSGdIK0RRb0NBZ0lDQWdJRHdQNFMvQlNBQUN3dVpBZ0FnQUVVRVFFRUFEd3NDZndKQUlBQUVmeUFCUWY4QVRRMEJBa0JCaEpnQ0tBSUFLQUlBUlFSQUlBRkJnSDl4UVlDL0EwWU5Bd3dCQ3lBQlFmOFBUUVJBSUFBZ0FVRS9jVUdBQVhJNkFBRWdBQ0FCUVFaMlFjQUJjam9BQUVFQ0RBUUxJQUZCZ0VCeFFZREFBMGNnQVVHQXNBTlBjVVVFUUNBQUlBRkJQM0ZCZ0FGeU9nQUNJQUFnQVVFTWRrSGdBWEk2QUFBZ0FDQUJRUVoyUVQ5eFFZQUJjam9BQVVFRERBUUxJQUZCZ0lBRWEwSC8vejlOQkVBZ0FDQUJRVDl4UVlBQmNqb0FBeUFBSUFGQkVuWkI4QUZ5T2dBQUlBQWdBVUVHZGtFL2NVR0FBWEk2QUFJZ0FDQUJRUXgyUVQ5eFFZQUJjam9BQVVFRURBUUxDMEg0a2dKQkdUWUNBRUYvQlVFQkN3d0JDeUFBSUFFNkFBQkJBUXNMcXdZQ0NuOEVmaU1BUWVBT2F5SURKQUFnQUNBRFFjQU5haUlBRUVVZ0FTQURRYUFFYWhBdklBQVFLQ0lJQkVBZ0EwSEFEV29pQUNBRFFjQUVhaUlCRUJjZ0FCQVBJQUVnQUJBUklBQVFEeUFBRUE4Z0FCQVBJQUFRRHlBQklBQVFFU0FBRUE4Z0FCQVBJQUFRRHlBRFFYODJBb0FDSUFNcEE3Z0VJUTBnQXlrRHNBUWhEaUFES1FPb0JDRVBJQU1wQTZBRUlSQkJBQ0VCQTBBZ0F5QUJRUUowSWdCcVFRQWdFRUlCaUNJUXAwRUJjU0lFYXpZQ0FDQURRWkFDYWlBQWFpQVBwMEVCY1NJRklBNm5RUUZ4SWdaQkFYUnlJQTJuUVFGeElnZEJBblJ5TmdJQUlBY2dCRUYvY3lJQWNhMGdEVUlCaUh3aERTQUFJQVp4clNBT1FnR0lmQ0VPSUFBZ0JYR3RJQTlDQVloOElROGdBVUVCYWlJQlFjQUFSdzBBQ3lBRElBNUNBWVlnRDN3Z0RVSUNobnluSWdrMkFwQUVJd0JCb0FScklnQWtBQ0FEUWNBTmFpSUJJQUFRSVNBQlFTQnFJZ29nQUVFZ2FoQWhJQUZCUUdzaUN5QUFRVUJyRUNFZ0FVSGdBR29nQUVIZ0FHb1FJU0FCUVlBQmFpQUFRWUFCYWhBaElBQVFSQ0FBSUFCQm9BTnFJZ2NRTUNBQUVDa2dBQ0FBUWFBQmFpSUZFREFnQVNBRFFjQUVhaUlFRUJjZ0FSQXBJQUVnQUVHZ0Ftb2lCaEF3SUFRZ0J5QUFFQllnQUNBRVFZQUJhaUlIRUJjZ0JDQUdJQUFRRmlBQUlBUkJnQUpxSWd3UUZ5QUhJQVlnQUJBV0lBQWdCRUdBQTJvaUJoQVhJQVFnQlNBQUVCWWdBQ0FFUVlBRWFoQVhJQWNnQlNBQUVCWWdBQ0FFUVlBRmFoQVhJQXdnQlNBQUVCWWdBQ0FFUVlBR2FoQVhJQVlnQlNBQUVCWWdBQ0FFUVlBSGFoQVhJQUJCb0FScUpBQWdCQ0FEUWNBTWFpSUFJQWtnQXlnQ2dBSVFOU0FBSUFCQklHb2lCQ0FCRUEwZ0FDQUVJQW9RQnlBTElBQkJRR3NvQWdBMkFnQWdBU0FBS0FKRU5nSkVJQUVnQUNnQ1NEWUNTQ0FCSUFBb0FrdzJBa3dnQVNBQUtBSlFOZ0pRSUFFZ0FDZ0NWRFlDVkNBQklBQW9BbGcyQWxnZ0FTQUFLQUpjTmdKY1FUOGhBQU5BSUFOQndBUnFJQU5Cd0F4cUlnUWdBQ0lCUVFKMElnQWdBMEdRQW1wcUtBSUFJQUFnQTJvb0FnQVFOU0FCUVFGcklRQWdBMEhBRFdvaUJSQVBJQVFnQlJBUklBRU5BQXNnQTBIQURXb2dBaEF4Q3lBRFFlQU9haVFBSUFnTFNBSUJmd0YrQWtBZ0FLMGlBcWNpQVVGL0lBRWdBa0lnaUtjYklBQkJBWEpCZ0lBRVNSc2lBUkE5SWdCRkRRQWdBRUVFYXkwQUFFRURjVVVOQUNBQVFRQWdBUkFPQ3lBQUM0MHVBUXQvSXdCQkVHc2lDeVFBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUFRZlFCVFFSQVFmeVNBaWdDQUNJR1FSQWdBRUVMYWtGNGNTQUFRUXRKR3lJSFFRTjJJZ0oySWdGQkEzRUVRQ0FCUVg5elFRRnhJQUpxSWdOQkEzUWlBVUdza3dKcUtBSUFJZ1JCQ0dvaEFBSkFJQVFvQWdnaUFpQUJRYVNUQW1vaUFVWUVRRUg4a2dJZ0JrRitJQU4zY1RZQ0FBd0JDeUFDSUFFMkFnd2dBU0FDTmdJSUN5QUVJQU5CQTNRaUFVRURjallDQkNBQklBUnFJZ0VnQVNnQ0JFRUJjallDQkF3TUN5QUhRWVNUQWlnQ0FDSUtUUTBCSUFFRVFBSkFRUUlnQW5RaUFFRUFJQUJyY2lBQklBSjBjU0lBUVFBZ0FHdHhRUUZySWdBZ0FFRU1ka0VRY1NJQ2RpSUJRUVYyUVFoeElnQWdBbklnQVNBQWRpSUJRUUoyUVFSeElnQnlJQUVnQUhZaUFVRUJka0VDY1NJQWNpQUJJQUIySWdGQkFYWkJBWEVpQUhJZ0FTQUFkbW9pQTBFRGRDSUFRYXlUQW1vb0FnQWlCQ2dDQ0NJQklBQkJwSk1DYWlJQVJnUkFRZnlTQWlBR1FYNGdBM2R4SWdZMkFnQU1BUXNnQVNBQU5nSU1JQUFnQVRZQ0NBc2dCRUVJYWlFQUlBUWdCMEVEY2pZQ0JDQUVJQWRxSWdJZ0EwRURkQ0lCSUFkcklnTkJBWEkyQWdRZ0FTQUVhaUFETmdJQUlBb0VRQ0FLUVFOMklnRkJBM1JCcEpNQ2FpRUZRWkNUQWlnQ0FDRUVBbjhnQmtFQklBRjBJZ0Z4UlFSQVFmeVNBaUFCSUFaeU5nSUFJQVVNQVFzZ0JTZ0NDQXNoQVNBRklBUTJBZ2dnQVNBRU5nSU1JQVFnQlRZQ0RDQUVJQUUyQWdnTFFaQ1RBaUFDTmdJQVFZU1RBaUFETmdJQURBd0xRWUNUQWlnQ0FDSUpSUTBCSUFsQkFDQUphM0ZCQVdzaUFDQUFRUXgyUVJCeElnSjJJZ0ZCQlhaQkNIRWlBQ0FDY2lBQklBQjJJZ0ZCQW5aQkJIRWlBSElnQVNBQWRpSUJRUUYyUVFKeElnQnlJQUVnQUhZaUFVRUJka0VCY1NJQWNpQUJJQUIyYWtFQ2RFR3NsUUpxS0FJQUlnRW9BZ1JCZUhFZ0Iyc2hBeUFCSVFJRFFBSkFJQUlvQWhBaUFFVUVRQ0FDS0FJVUlnQkZEUUVMSUFBb0FnUkJlSEVnQjJzaUFpQURJQUlnQTBraUFoc2hBeUFBSUFFZ0Foc2hBU0FBSVFJTUFRc0xJQUVvQWhnaENDQUJJQUVvQWd3aUJFY0VRQ0FCS0FJSUlnQkJqSk1DS0FJQVNSb2dBQ0FFTmdJTUlBUWdBRFlDQ0F3TEN5QUJRUlJxSWdJb0FnQWlBRVVFUUNBQktBSVFJZ0JGRFFNZ0FVRVFhaUVDQ3dOQUlBSWhCU0FBSWdSQkZHb2lBaWdDQUNJQURRQWdCRUVRYWlFQ0lBUW9BaEFpQUEwQUN5QUZRUUEyQWdBTUNndEJmeUVISUFCQnYzOUxEUUFnQUVFTGFpSUFRWGh4SVFkQmdKTUNLQUlBSWdsRkRRQkJBQ0FIYXlFREFrQUNRQUpBQW45QkFDQUhRWUFDU1EwQUdrRWZJQWRCLy8vL0Iwc05BQm9nQUVFSWRpSUFJQUJCZ1A0L2FrRVFka0VJY1NJQ2RDSUFJQUJCZ09BZmFrRVFka0VFY1NJQmRDSUFJQUJCZ0lBUGFrRVFka0VDY1NJQWRFRVBkaUFCSUFKeUlBQnlheUlBUVFGMElBY2dBRUVWYW5aQkFYRnlRUnhxQ3lJR1FRSjBRYXlWQW1vb0FnQWlBa1VFUUVFQUlRQU1BUXRCQUNFQUlBZEJBRUVaSUFaQkFYWnJJQVpCSDBZYmRDRUJBMEFDUUNBQ0tBSUVRWGh4SUFkcklnVWdBMDhOQUNBQ0lRUWdCU0lERFFCQkFDRURJQUloQUF3REN5QUFJQUlvQWhRaUJTQUZJQUlnQVVFZGRrRUVjV29vQWhBaUFrWWJJQUFnQlJzaEFDQUJRUUYwSVFFZ0FnMEFDd3NnQUNBRWNrVUVRRUVBSVFSQkFpQUdkQ0lBUVFBZ0FHdHlJQWx4SWdCRkRRTWdBRUVBSUFCcmNVRUJheUlBSUFCQkRIWkJFSEVpQW5ZaUFVRUZka0VJY1NJQUlBSnlJQUVnQUhZaUFVRUNka0VFY1NJQWNpQUJJQUIySWdGQkFYWkJBbkVpQUhJZ0FTQUFkaUlCUVFGMlFRRnhJZ0J5SUFFZ0FIWnFRUUowUWF5VkFtb29BZ0FoQUFzZ0FFVU5BUXNEUUNBQUtBSUVRWGh4SUFkcklnRWdBMGtoQWlBQklBTWdBaHNoQXlBQUlBUWdBaHNoQkNBQUtBSVFJZ0VFZnlBQkJTQUFLQUlVQ3lJQURRQUxDeUFFUlEwQUlBTkJoSk1DS0FJQUlBZHJUdzBBSUFRb0FoZ2hCaUFFSUFRb0Fnd2lBVWNFUUNBRUtBSUlJZ0JCakpNQ0tBSUFTUm9nQUNBQk5nSU1JQUVnQURZQ0NBd0pDeUFFUVJScUlnSW9BZ0FpQUVVRVFDQUVLQUlRSWdCRkRRTWdCRUVRYWlFQ0N3TkFJQUloQlNBQUlnRkJGR29pQWlnQ0FDSUFEUUFnQVVFUWFpRUNJQUVvQWhBaUFBMEFDeUFGUVFBMkFnQU1DQXNnQjBHRWt3SW9BZ0FpQWswRVFFR1Frd0lvQWdBaEF3SkFJQUlnQjJzaUFVRVFUd1JBUVlTVEFpQUJOZ0lBUVpDVEFpQURJQWRxSWdBMkFnQWdBQ0FCUVFGeU5nSUVJQUlnQTJvZ0FUWUNBQ0FESUFkQkEzSTJBZ1FNQVF0QmtKTUNRUUEyQWdCQmhKTUNRUUEyQWdBZ0F5QUNRUU55TmdJRUlBSWdBMm9pQUNBQUtBSUVRUUZ5TmdJRUN5QURRUWhxSVFBTUNnc2dCMEdJa3dJb0FnQWlDRWtFUUVHSWt3SWdDQ0FIYXlJQk5nSUFRWlNUQWtHVWt3SW9BZ0FpQWlBSGFpSUFOZ0lBSUFBZ0FVRUJjallDQkNBQ0lBZEJBM0kyQWdRZ0FrRUlhaUVBREFvTFFRQWhBQ0FIUVM5cUlna0NmMEhVbGdJb0FnQUVRRUhjbGdJb0FnQU1BUXRCNEpZQ1FuODNBZ0JCMkpZQ1FvQ2dnSUNBZ0FRM0FnQkIxSllDSUF0QkRHcEJjSEZCMktyVnFnVnpOZ0lBUWVpV0FrRUFOZ0lBUWJpV0FrRUFOZ0lBUVlBZ0N5SUJhaUlHUVFBZ0FXc2lCWEVpQWlBSFRRMEpRYlNXQWlnQ0FDSUVCRUJCckpZQ0tBSUFJZ01nQW1vaUFTQURUUTBLSUFFZ0JFc05DZ3RCdUpZQ0xRQUFRUVJ4RFFRQ1FBSkFRWlNUQWlnQ0FDSURCRUJCdkpZQ0lRQURRQ0FESUFBb0FnQWlBVThFUUNBQklBQW9BZ1JxSUFOTERRTUxJQUFvQWdnaUFBMEFDd3RCQUJBYUlnRkJmMFlOQlNBQ0lRWkIySllDS0FJQUlnTkJBV3NpQUNBQmNRUkFJQUlnQVdzZ0FDQUJha0VBSUFOcmNXb2hCZ3NnQmlBSFRRMEZJQVpCL3YvLy93ZExEUVZCdEpZQ0tBSUFJZ1FFUUVHc2xnSW9BZ0FpQXlBR2FpSUFJQU5ORFFZZ0FDQUVTdzBHQ3lBR0VCb2lBQ0FCUncwQkRBY0xJQVlnQ0dzZ0JYRWlCa0grLy8vL0Iwc05CQ0FHRUJvaUFTQUFLQUlBSUFBb0FnUnFSZzBESUFFaEFBc0NRQ0FBUVg5R0RRQWdCMEV3YWlBR1RRMEFRZHlXQWlnQ0FDSUJJQWtnQm10cVFRQWdBV3R4SWdGQi92Ly8vd2RMQkVBZ0FDRUJEQWNMSUFFUUdrRi9Sd1JBSUFFZ0Jtb2hCaUFBSVFFTUJ3dEJBQ0FHYXhBYUdnd0VDeUFBSWdGQmYwY05CUXdEQzBFQUlRUU1Cd3RCQUNFQkRBVUxJQUZCZjBjTkFndEJ1SllDUWJpV0FpZ0NBRUVFY2pZQ0FBc2dBa0grLy8vL0Iwc05BU0FDRUJvaEFVRUFFQm9oQUNBQlFYOUdEUUVnQUVGL1JnMEJJQUFnQVUwTkFTQUFJQUZySWdZZ0IwRW9hazBOQVF0QnJKWUNRYXlXQWlnQ0FDQUdhaUlBTmdJQVFiQ1dBaWdDQUNBQVNRUkFRYkNXQWlBQU5nSUFDd0pBQWtBQ1FFR1Vrd0lvQWdBaUJRUkFRYnlXQWlFQUEwQWdBU0FBS0FJQUlnTWdBQ2dDQkNJQ2FrWU5BaUFBS0FJSUlnQU5BQXNNQWd0QmpKTUNLQUlBSWdCQkFDQUFJQUZORzBVRVFFR01rd0lnQVRZQ0FBdEJBQ0VBUWNDV0FpQUdOZ0lBUWJ5V0FpQUJOZ0lBUVp5VEFrRi9OZ0lBUWFDVEFrSFVsZ0lvQWdBMkFnQkJ5SllDUVFBMkFnQURRQ0FBUVFOMElnTkJySk1DYWlBRFFhU1RBbW9pQWpZQ0FDQURRYkNUQW1vZ0FqWUNBQ0FBUVFGcUlnQkJJRWNOQUF0QmlKTUNJQVpCS0dzaUEwRjRJQUZyUVFkeFFRQWdBVUVJYWtFSGNSc2lBR3NpQWpZQ0FFR1Vrd0lnQUNBQmFpSUFOZ0lBSUFBZ0FrRUJjallDQkNBQklBTnFRU2cyQWdSQm1KTUNRZVNXQWlnQ0FEWUNBQXdDQ3lBQUxRQU1RUWh4RFFBZ0F5QUZTdzBBSUFFZ0JVME5BQ0FBSUFJZ0JtbzJBZ1JCbEpNQ0lBVkJlQ0FGYTBFSGNVRUFJQVZCQ0dwQkIzRWJJZ0JxSWdJMkFnQkJpSk1DUVlpVEFpZ0NBQ0FHYWlJQklBQnJJZ0EyQWdBZ0FpQUFRUUZ5TmdJRUlBRWdCV3BCS0RZQ0JFR1lrd0pCNUpZQ0tBSUFOZ0lBREFFTFFZeVRBaWdDQUNBQlN3UkFRWXlUQWlBQk5nSUFDeUFCSUFacUlRSkJ2SllDSVFBQ1FBSkFBa0FDUUFKQUFrQURRQ0FDSUFBb0FnQkhCRUFnQUNnQ0NDSUFEUUVNQWdzTElBQXRBQXhCQ0hGRkRRRUxRYnlXQWlFQUEwQWdCU0FBS0FJQUlnSlBCRUFnQWlBQUtBSUVhaUlFSUFWTERRTUxJQUFvQWdnaEFBd0FDd0FMSUFBZ0FUWUNBQ0FBSUFBb0FnUWdCbW8yQWdRZ0FVRjRJQUZyUVFkeFFRQWdBVUVJYWtFSGNSdHFJZ2tnQjBFRGNqWUNCQ0FDUVhnZ0FtdEJCM0ZCQUNBQ1FRaHFRUWR4RzJvaUJpQUhJQWxxSWdocklRSWdCU0FHUmdSQVFaU1RBaUFJTmdJQVFZaVRBa0dJa3dJb0FnQWdBbW9pQURZQ0FDQUlJQUJCQVhJMkFnUU1Bd3NnQmtHUWt3SW9BZ0JHQkVCQmtKTUNJQWcyQWdCQmhKTUNRWVNUQWlnQ0FDQUNhaUlBTmdJQUlBZ2dBRUVCY2pZQ0JDQUFJQWhxSUFBMkFnQU1Bd3NnQmlnQ0JDSUFRUU54UVFGR0JFQWdBRUY0Y1NFRkFrQWdBRUgvQVUwRVFDQUdLQUlJSWdNZ0FFRURkaUlBUVFOMFFhU1RBbXBHR2lBRElBWW9BZ3dpQVVZRVFFSDhrZ0pCL0pJQ0tBSUFRWDRnQUhkeE5nSUFEQUlMSUFNZ0FUWUNEQ0FCSUFNMkFnZ01BUXNnQmlnQ0dDRUhBa0FnQmlBR0tBSU1JZ0ZIQkVBZ0JpZ0NDQ0lBSUFFMkFnd2dBU0FBTmdJSURBRUxBa0FnQmtFVWFpSUFLQUlBSWdNTkFDQUdRUkJxSWdBb0FnQWlBdzBBUVFBaEFRd0JDd05BSUFBaEJDQURJZ0ZCRkdvaUFDZ0NBQ0lERFFBZ0FVRVFhaUVBSUFFb0FoQWlBdzBBQ3lBRVFRQTJBZ0FMSUFkRkRRQUNRQ0FHSUFZb0Fod2lBMEVDZEVHc2xRSnFJZ0FvQWdCR0JFQWdBQ0FCTmdJQUlBRU5BVUdBa3dKQmdKTUNLQUlBUVg0Z0EzZHhOZ0lBREFJTElBZEJFRUVVSUFjb0FoQWdCa1liYWlBQk5nSUFJQUZGRFFFTElBRWdCellDR0NBR0tBSVFJZ0FFUUNBQklBQTJBaEFnQUNBQk5nSVlDeUFHS0FJVUlnQkZEUUFnQVNBQU5nSVVJQUFnQVRZQ0dBc2dCU0FHYWlFR0lBSWdCV29oQWdzZ0JpQUdLQUlFUVg1eE5nSUVJQWdnQWtFQmNqWUNCQ0FDSUFocUlBSTJBZ0FnQWtIL0FVMEVRQ0FDUVFOMklnQkJBM1JCcEpNQ2FpRUNBbjlCL0pJQ0tBSUFJZ0ZCQVNBQWRDSUFjVVVFUUVIOGtnSWdBQ0FCY2pZQ0FDQUNEQUVMSUFJb0FnZ0xJUUFnQWlBSU5nSUlJQUFnQ0RZQ0RDQUlJQUkyQWd3Z0NDQUFOZ0lJREFNTFFSOGhBQ0FDUWYvLy93ZE5CRUFnQWtFSWRpSUFJQUJCZ1A0L2FrRVFka0VJY1NJRGRDSUFJQUJCZ09BZmFrRVFka0VFY1NJQmRDSUFJQUJCZ0lBUGFrRVFka0VDY1NJQWRFRVBkaUFCSUFOeUlBQnlheUlBUVFGMElBSWdBRUVWYW5aQkFYRnlRUnhxSVFBTElBZ2dBRFlDSENBSVFnQTNBaEFnQUVFQ2RFR3NsUUpxSVFRQ1FFR0Frd0lvQWdBaUEwRUJJQUIwSWdGeFJRUkFRWUNUQWlBQklBTnlOZ0lBSUFRZ0NEWUNBQ0FJSUFRMkFoZ01BUXNnQWtFQVFSa2dBRUVCZG1zZ0FFRWZSaHQwSVFBZ0JDZ0NBQ0VCQTBBZ0FTSURLQUlFUVhoeElBSkdEUU1nQUVFZGRpRUJJQUJCQVhRaEFDQURJQUZCQkhGcUlnUW9BaEFpQVEwQUN5QUVJQWcyQWhBZ0NDQUROZ0lZQ3lBSUlBZzJBZ3dnQ0NBSU5nSUlEQUlMUVlpVEFpQUdRU2hySWdOQmVDQUJhMEVIY1VFQUlBRkJDR3BCQjNFYklnQnJJZ0kyQWdCQmxKTUNJQUFnQVdvaUFEWUNBQ0FBSUFKQkFYSTJBZ1FnQVNBRGFrRW9OZ0lFUVppVEFrSGtsZ0lvQWdBMkFnQWdCU0FFUVNjZ0JHdEJCM0ZCQUNBRVFTZHJRUWR4RzJwQkwyc2lBQ0FBSUFWQkVHcEpHeUlDUVJzMkFnUWdBa0hFbGdJcEFnQTNBaEFnQWtHOGxnSXBBZ0EzQWdoQnhKWUNJQUpCQ0dvMkFnQkJ3SllDSUFZMkFnQkJ2SllDSUFFMkFnQkJ5SllDUVFBMkFnQWdBa0VZYWlFQUEwQWdBRUVITmdJRUlBQkJDR29oQVNBQVFRUnFJUUFnQVNBRVNRMEFDeUFDSUFWR0RRTWdBaUFDS0FJRVFYNXhOZ0lFSUFVZ0FpQUZheUlFUVFGeU5nSUVJQUlnQkRZQ0FDQUVRZjhCVFFSQUlBUkJBM1lpQUVFRGRFR2trd0pxSVFJQ2YwSDhrZ0lvQWdBaUFVRUJJQUIwSWdCeFJRUkFRZnlTQWlBQUlBRnlOZ0lBSUFJTUFRc2dBaWdDQ0FzaEFDQUNJQVUyQWdnZ0FDQUZOZ0lNSUFVZ0FqWUNEQ0FGSUFBMkFnZ01CQXRCSHlFQUlBVkNBRGNDRUNBRVFmLy8vd2ROQkVBZ0JFRUlkaUlBSUFCQmdQNC9ha0VRZGtFSWNTSUNkQ0lBSUFCQmdPQWZha0VRZGtFRWNTSUJkQ0lBSUFCQmdJQVBha0VRZGtFQ2NTSUFkRUVQZGlBQklBSnlJQUJ5YXlJQVFRRjBJQVFnQUVFVmFuWkJBWEZ5UVJ4cUlRQUxJQVVnQURZQ0hDQUFRUUowUWF5VkFtb2hBd0pBUVlDVEFpZ0NBQ0lDUVFFZ0FIUWlBWEZGQkVCQmdKTUNJQUVnQW5JMkFnQWdBeUFGTmdJQUlBVWdBellDR0F3QkN5QUVRUUJCR1NBQVFRRjJheUFBUVI5R0czUWhBQ0FES0FJQUlRRURRQ0FCSWdJb0FnUkJlSEVnQkVZTkJDQUFRUjEySVFFZ0FFRUJkQ0VBSUFJZ0FVRUVjV29pQXlnQ0VDSUJEUUFMSUFNZ0JUWUNFQ0FGSUFJMkFoZ0xJQVVnQlRZQ0RDQUZJQVUyQWdnTUF3c2dBeWdDQ0NJQUlBZzJBZ3dnQXlBSU5nSUlJQWhCQURZQ0dDQUlJQU0yQWd3Z0NDQUFOZ0lJQ3lBSlFRaHFJUUFNQlFzZ0FpZ0NDQ0lBSUFVMkFnd2dBaUFGTmdJSUlBVkJBRFlDR0NBRklBSTJBZ3dnQlNBQU5nSUlDMEdJa3dJb0FnQWlBQ0FIVFEwQVFZaVRBaUFBSUFkcklnRTJBZ0JCbEpNQ1FaU1RBaWdDQUNJQ0lBZHFJZ0EyQWdBZ0FDQUJRUUZ5TmdJRUlBSWdCMEVEY2pZQ0JDQUNRUWhxSVFBTUF3dEIrSklDUVRBMkFnQkJBQ0VBREFJTEFrQWdCa1VOQUFKQUlBUW9BaHdpQWtFQ2RFR3NsUUpxSWdBb0FnQWdCRVlFUUNBQUlBRTJBZ0FnQVEwQlFZQ1RBaUFKUVg0Z0FuZHhJZ2syQWdBTUFnc2dCa0VRUVJRZ0JpZ0NFQ0FFUmh0cUlBRTJBZ0FnQVVVTkFRc2dBU0FHTmdJWUlBUW9BaEFpQUFSQUlBRWdBRFlDRUNBQUlBRTJBaGdMSUFRb0FoUWlBRVVOQUNBQklBQTJBaFFnQUNBQk5nSVlDd0pBSUFOQkQwMEVRQ0FFSUFNZ0Iyb2lBRUVEY2pZQ0JDQUFJQVJxSWdBZ0FDZ0NCRUVCY2pZQ0JBd0JDeUFFSUFkQkEzSTJBZ1FnQkNBSGFpSUZJQU5CQVhJMkFnUWdBeUFGYWlBRE5nSUFJQU5CL3dGTkJFQWdBMEVEZGlJQVFRTjBRYVNUQW1vaEFnSi9RZnlTQWlnQ0FDSUJRUUVnQUhRaUFIRkZCRUJCL0pJQ0lBQWdBWEkyQWdBZ0Fnd0JDeUFDS0FJSUN5RUFJQUlnQlRZQ0NDQUFJQVUyQWd3Z0JTQUNOZ0lNSUFVZ0FEWUNDQXdCQzBFZklRQWdBMEgvLy84SFRRUkFJQU5CQ0hZaUFDQUFRWUQrUDJwQkVIWkJDSEVpQW5RaUFDQUFRWURnSDJwQkVIWkJCSEVpQVhRaUFDQUFRWUNBRDJwQkVIWkJBbkVpQUhSQkQzWWdBU0FDY2lBQWNtc2lBRUVCZENBRElBQkJGV3AyUVFGeGNrRWNhaUVBQ3lBRklBQTJBaHdnQlVJQU53SVFJQUJCQW5SQnJKVUNhaUVCQWtBQ1FDQUpRUUVnQUhRaUFuRkZCRUJCZ0pNQ0lBSWdDWEkyQWdBZ0FTQUZOZ0lBREFFTElBTkJBRUVaSUFCQkFYWnJJQUJCSDBZYmRDRUFJQUVvQWdBaEJ3TkFJQWNpQVNnQ0JFRjRjU0FEUmcwQ0lBQkJIWFloQWlBQVFRRjBJUUFnQVNBQ1FRUnhhaUlDS0FJUUlnY05BQXNnQWlBRk5nSVFDeUFGSUFFMkFoZ2dCU0FGTmdJTUlBVWdCVFlDQ0F3QkN5QUJLQUlJSWdBZ0JUWUNEQ0FCSUFVMkFnZ2dCVUVBTmdJWUlBVWdBVFlDRENBRklBQTJBZ2dMSUFSQkNHb2hBQXdCQ3dKQUlBaEZEUUFDUUNBQktBSWNJZ0pCQW5SQnJKVUNhaUlBS0FJQUlBRkdCRUFnQUNBRU5nSUFJQVFOQVVHQWt3SWdDVUYrSUFKM2NUWUNBQXdDQ3lBSVFSQkJGQ0FJS0FJUUlBRkdHMm9nQkRZQ0FDQUVSUTBCQ3lBRUlBZzJBaGdnQVNnQ0VDSUFCRUFnQkNBQU5nSVFJQUFnQkRZQ0dBc2dBU2dDRkNJQVJRMEFJQVFnQURZQ0ZDQUFJQVEyQWhnTEFrQWdBMEVQVFFSQUlBRWdBeUFIYWlJQVFRTnlOZ0lFSUFBZ0FXb2lBQ0FBS0FJRVFRRnlOZ0lFREFFTElBRWdCMEVEY2pZQ0JDQUJJQWRxSWdJZ0EwRUJjallDQkNBQ0lBTnFJQU0yQWdBZ0NnUkFJQXBCQTNZaUFFRURkRUdra3dKcUlRVkJrSk1DS0FJQUlRUUNmMEVCSUFCMElnQWdCbkZGQkVCQi9KSUNJQUFnQm5JMkFnQWdCUXdCQ3lBRktBSUlDeUVBSUFVZ0JEWUNDQ0FBSUFRMkFnd2dCQ0FGTmdJTUlBUWdBRFlDQ0F0QmtKTUNJQUkyQWdCQmhKTUNJQU0yQWdBTElBRkJDR29oQUFzZ0MwRVFhaVFBSUFBTGhRSUJCbjlCSUNFRVFlQ1JBaWdDQUVGL1JnUkFBMEFqQUVFUWF5SUNKQUFnQWtFQU5nSUFBbjlCQUVIY2h3SVFMRVVOQUJwQkFVR2hod0lRTEVVTkFCcEJRVUVDUWRDSEFoQXNHd3NpQVVHQllFOEVRRUg0a2dKQkFDQUJhellDQUVGL0lRRUxJQUpCRUdva0FFSGdrUUlnQVRZQ0FDQUJRWDlHRFFBTEMwRUFJUUlEUUNBQUlBSnFJUVVEUUVIZ2tRSW9BZ0FoQXlNQVFSQnJJZ0VrQUNBQklBUTJBZ3dnQVNBRk5nSUlJQU1nQVVFSWFrRUJJQUZCQkdvUUJDSURCSDlCK0pJQ0lBTTJBZ0JCZndWQkFBc2hBeUFCS0FJRUlRWWdBVUVRYWlRQVFYOGdCaUFER3lJQlFYOUdEUUFMSUFFZ0Ftb2hBaUFFSUFGcklnUkJBRW9OQUF0QkFRdURDZ0VJZnlNQVFSQnJJZ29rQUFKQUlBSkZCRUFnQUNFQ0lBRWhCeUFEUVFOMklnaEJBV3NpQkVFQVRnUkFBMEFnQnlBQ0tBSUFJZ1VnQWlnQ0JDSUdRUWgwYzBHQS9nTnhJZ2tnQlVILy93TnhJQVpCRUhSeWN5SUxJQWxCQ0hSeklna2dDMEVFZG5OQjhJSEFCM0VpQ3lBSmN5SUpJQXRCQkhSeklnc2dDVUVDZG5OQmpKaXc0QUJ4SWdrZ0MzTWlDeUFKUVFKMGN5SUpJQXRCQVhaelFhTEVpSkVDY1NJTElBbHpJQXRCQVhSek5nSUFJQWNnQlVFUWRpSUZJQVpCZ0lCOGNTSUdRUWgyYzBHQS9nTnhJZ2tnQlNBR2NuTWlCU0FKUVFoMGN5SUdJQVZCQkhaelFmQ0J3QWR4SWdVZ0JuTWlCaUFGUVFSMGN5SUZJQVpCQW5aelFZeVlzT0FBY1NJR0lBVnpJZ1VnQmtFQ2RITWlCaUFGUVFGMmMwR2l4SWlSQW5FaUJTQUdjeUFGUVFGMGN6WUNCQ0FIUVFocUlRY2dBa0VJYWlFQ0lBUkJBRW9oQlNBRVFRRnJJUVFnQlEwQUN3c2dDaUFBSUFoQkEzUnFJZ0lvQWdRaUFFRUlkQ0FDS0FJQUlnSnpRWUQrQTNFaUJ5QUNRZi8vQTNFZ0FFRVFkSEp6SWdRZ0IwRUlkSE1pQnlBRVFRUjJjMEh3Z2NBSGNTSUVJQWR6SWdjZ0JFRUVkSE1pQkNBSFFRSjJjMEdNbUxEZ0FIRWlCeUFFY3lJRUlBZEJBblJ6SWdjZ0JFRUJkbk5Cb3NTSWtRSnhJZ1FnQjNNZ0JFRUJkSE0yQWdnZ0NpQUNRUkIySWdJZ0FFR0FnSHh4SWdCQkNIWnpRWUQrQTNFaUJ5QUFJQUp5Y3lJQUlBZEJDSFJ6SWdJZ0FFRUVkbk5COElIQUIzRWlBQ0FDY3lJQ0lBQkJCSFJ6SWdBZ0FrRUNkbk5CakppdzRBQnhJZ0lnQUhNaUFDQUNRUUowY3lJQ0lBQkJBWFp6UWFMRWlKRUNjU0lBSUFKeklBQkJBWFJ6TmdJTUlBRWdBMEY0Y1dvZ0NrRUlhaUFEUVFkeEVCZ2FEQUVMSUFORkRRQWdDaUFBSUFKQkEzWWlCMEVEZEdvaUJTZ0NCQ0lFUVFoMElBVW9BZ0FpQlhOQmdQNERjU0lHSUFWQi8vOERjU0FFUVJCMGNuTWlDQ0FHUVFoMGN5SUdJQWhCQkhaelFmQ0J3QWR4SWdnZ0JuTWlCaUFJUVFSMGN5SUlJQVpCQW5aelFZeVlzT0FBY1NJR0lBaHpJZ2dnQmtFQ2RITWlCaUFJUVFGMmMwR2l4SWlSQW5FaUNDQUdjeUFJUVFGMGN6WUNDQ0FLSUFWQkVIWWlCU0FFUVlDQWZIRWlCRUVJZG5OQmdQNERjU0lHSUFRZ0JYSnpJZ1FnQmtFSWRITWlCU0FFUVFSMmMwSHdnY0FIY1NJRUlBVnpJZ1VnQkVFRWRITWlCQ0FGUVFKMmMwR01tTERnQUhFaUJTQUVjeUlFSUFWQkFuUnpJZ1VnQkVFQmRuTkJvc1NJa1FKeElnUWdCWE1nQkVFQmRITTJBZ3dnQVNBQ1FRZHhJZ0VnQ2tFSWFtb2dBMEVJSUFGcklnRWdBU0FEU3hzaUFSQVlJUUlnQXlBQmF5SURSUTBBSUFFZ0Ftb2hBUU5BSUFvZ0FDQUhRUUZxSWdkQkEzUnFJZ1FvQWdRaUFrRUlkQ0FFS0FJQUlnUnpRWUQrQTNFaUJTQUVRZi8vQTNFZ0FrRVFkSEp6SWdZZ0JVRUlkSE1pQlNBR1FRUjJjMEh3Z2NBSGNTSUdJQVZ6SWdVZ0JrRUVkSE1pQmlBRlFRSjJjMEdNbUxEZ0FIRWlCU0FHY3lJR0lBVkJBblJ6SWdVZ0JrRUJkbk5Cb3NTSWtRSnhJZ1lnQlhNZ0JrRUJkSE0yQWdnZ0NpQUVRUkIySWdRZ0FrR0FnSHh4SWdKQkNIWnpRWUQrQTNFaUJTQUNJQVJ5Y3lJQ0lBVkJDSFJ6SWdRZ0FrRUVkbk5COElIQUIzRWlBaUFFY3lJRUlBSkJCSFJ6SWdJZ0JFRUNkbk5CakppdzRBQnhJZ1FnQW5NaUFpQUVRUUowY3lJRUlBSkJBWFp6UWFMRWlKRUNjU0lDSUFSeklBSkJBWFJ6TmdJTUlBRWdDa0VJYWlBRFFRZ2dBMEVJU1JzaUFoQVlJQUpxSVFFZ0F5QUNheUlERFFBTEN5QUtRUkJxSkFBTCtnY0JDSDhqQUVFUWF5SUlKQUFDUUNBQ1JRUkFJQU5CQTNZaENpQURRUWhQQkVBZ0NpRUZJQUVoQWlBQUlRY0RRQ0FISUFjb0FnQWdBaWdDQUNJRVFRRjJJQVJ6UWFMRWlKRUNjU0lHSUFSeklnUWdCa0VCZEhNaUJpQUVRUUoyYzBHTW1MRGdBSEVpQkNBR2N5SUdJQVJCQW5SeklnUWdCa0VFZG5OQjhJSEFCM0VpQmlBRWN5SUVJQVpCQkhSeklnc2dCRUVJZG5OQmdQNERjU0lKSUF0Qi8vOERjWE1nQWlnQ0JDSUVRUUYySUFSelFhTEVpSkVDY1NJR0lBUnpJZ1FnQmtFQmRITWlCaUFFUVFKMmMwR01tTERnQUhFaUJDQUdjeUlHSUFSQkFuUnpJZ1FnQmtFRWRuTkI4SUhBQjNFaUJpQUVjeUlFSUFaQkJIUnpJZ1lnQkVFSWRuTkJnUDREY1NJRUlBWnpRUkIwY25NMkFnQWdCeUFIS0FJRUlBWkJnSUI4Y1NBRVFRaDBjeUFKUVFoMElBdHpRUkIyY25NMkFnUWdCMEVJYWlFSElBSkJDR29oQWlBRlFRRnJJZ1VOQUFzTElBaENBRGNEQ0NBSVFRaHFJQUVnQTBGNGNXb2dBMEVIY1JBWUdpQUFJQXBCQTNScUlnVWdCU2dDQUNBSUtBSUlJZ0JCQVhZZ0FITkJvc1NJa1FKeElnRWdBSE1pQUNBQlFRRjBjeUlCSUFCQkFuWnpRWXlZc09BQWNTSUFJQUZ6SWdFZ0FFRUNkSE1pQUNBQlFRUjJjMEh3Z2NBSGNTSUJJQUJ6SWdBZ0FVRUVkSE1pQXlBQVFRaDJjMEdBL2dOeElnSWdBMEgvL3dOeGN5QUlLQUlNSWdCQkFYWWdBSE5Cb3NTSWtRSnhJZ0VnQUhNaUFDQUJRUUYwY3lJQklBQkJBblp6UVl5WXNPQUFjU0lBSUFGeklnRWdBRUVDZEhNaUFDQUJRUVIyYzBId2djQUhjU0lCSUFCeklnQWdBVUVFZEhNaUFTQUFRUWgyYzBHQS9nTnhJZ0FnQVhOQkVIUnljellDQUNBRklBVW9BZ1FnQVVHQWdIeHhJQUJCQ0hSeklBSkJDSFFnQTNOQkVIWnljellDQkF3QkN5QURSUTBBSUFKQkEzWWhCeUFDUVFkeElRSURRQ0FJUWdBM0F3Z2dDRUVJYWlBQ2FpQUJJQU5CQ0NBQ2F5SUNJQUlnQTBzYklnWVFHQm9nQUNBSFFRTjBhaUlKSUFrb0FnQWdDQ2dDQ0NJQ1FRRjJJQUp6UWFMRWlKRUNjU0lGSUFKeklnSWdCVUVCZEhNaUJTQUNRUUoyYzBHTW1MRGdBSEVpQWlBRmN5SUZJQUpCQW5SeklnSWdCVUVFZG5OQjhJSEFCM0VpQlNBQ2N5SUNJQVZCQkhSeklnUWdBa0VJZG5OQmdQNERjU0lLSUFSQi8vOERjWE1nQ0NnQ0RDSUNRUUYySUFKelFhTEVpSkVDY1NJRklBSnpJZ0lnQlVFQmRITWlCU0FDUVFKMmMwR01tTERnQUhFaUFpQUZjeUlGSUFKQkFuUnpJZ0lnQlVFRWRuTkI4SUhBQjNFaUJTQUNjeUlDSUFWQkJIUnpJZ1VnQWtFSWRuTkJnUDREY1NJQ0lBVnpRUkIwY25NMkFnQWdDU0FKS0FJRUlBVkJnSUI4Y1NBQ1FRaDBjeUFLUVFoMElBUnpRUkIyY25NMkFnUWdBU0FHYWlFQklBZEJBV29oQjBFQUlRSWdBeUFHYXlJRERRQUxDeUFJUVJCcUpBQUxDd0FnQUVFQVFjZ0JFQTRMREFBZ0FFR2doUUlnQVJBYkM0RUlBZ3AvQTM0akFFSHdBbXNpQWlRQUlBSkNBRGNEdUFFZ0FrSUFOd093QVNBQ1FnQTNBNkFCSUFKQ0FEY0RxQUVnQWtFQk5nS2dBU0FBS1FBSUlRd2dBQ2tBRUNFTklBQXBBQUFoRGlBQklBQXBBQmczQURnZ0FTQU5Od0F3SUFFZ0REY0FLQ0FCUVNCcUlnTWdEamNBQUNBQUxRQWZJUXNnQVNBQktBSThRZi8vLy84SGNUWUNQQ0FESUFKQjRBRnFJZ1VRQ0NBRlFZQ0ZBaUFDUWNBQmFpSUdFQVlnQlNBQ1FhQUJhaUlBSUFVUURTQUdJQUFnQmhBSElBWWdBa0hBQW1vaUFCQWNJQUpCMEFGcUlnTWdBa0d3QW1vaUJ4QWNJQUFnQnlBQUVDTWdCU0FHSUFjUUJTQUNRZkFCYWlJQUlBTWdBa0dnQW1vaUJCQUZJQWNnQkNBSEVDTWdBQ0FHSUFRUUJTQUZJQU1nQWtHUUFtb2lBeEFGSUFRZ0F5QUVFRE1nQnlBREVCd2dCQ0FDUVlBQ2FpSUFFQndnQXlBQUlBTVFJMEVBSVFBRFFDQUNRWkFDYWlJRElBTVFIQ0FBUVFGcUlnQkIvUUJIRFFBTElBSkJzQUpxSUFKQmtBSnFJQUpCMEFKcUlnQVFJeUFBRURJZ0FpZ0MzQUlnQWlnQzJBSWdBaWdDMUFJZ0FpZ0MwQUp5Y25KRkJFQWdBa0d3QW1vZ0FrR1FBbW9nQWtIUUFtb1FNd3NnQWtIUUFtb2lDU0FKSUFrUUl5QUNRY0FDYWlJRElBSkJrQUpxSWdnUUhDQURJQWdnQ0JBRklBa2dDQ0FJRUFVZ0NDQUNRZUFDYWlJQUVFb2dBeUFBSUFnUUJTQUpJQWdnQVJBRklBRWdBa0d3QW1vaUNoQWNJQU1nQ2lBS0VBVWdBU0FCS0FJRUlnTWdBU2dDQUNJQVFRQWdBRUVCY1NJRWF5SUZjeUFBYzBFZmRpQUVheUlHYWlJSFFSOTBJQUJCQVhaeU5nSUFJQUVnQVNnQ0NDSUFJQVVnQmtGL2MzRWdCaUFIY3lBRElBWnpjaUFIYzNKQkgzWWdCR3NpQkdvaUEwRWZkQ0FIUVFGMmNqWUNCQ0FCSUFFb0Fnd2dCU0FFUVg5emNTQURJQVJ6SUFBZ0JITnlJQU56Y2tFZmRpQUZRUUYyYW1vaUFFRUJkallDRENBQklBQkJIM1FnQTBFQmRuSTJBZ2dnQWtHZ0Ftb2dDQ0FCUVJCcUlnTVFCU0FKSUFvZ0NSQXpJQWtRTWlBQ0tBTGNBaUFDS0FMWUFpQUNLQUxVQWlBQ0tBTFFBbkp5Y2dSQUlBSkJ3QUpxSWdBZ0FTZ0NBRFlDQUNBQUlBRW9BZ1EyQWdRZ0FDQUJLQUlJTmdJSUlBQWdBU2dDRERZQ0RDQUJJQU1vQWdBMkFnQWdBU0FES0FJRU5nSUVJQUVnQXlnQ0NEWUNDQ0FCSUFNb0FndzJBZ3dnQXlBQUtBSUFOZ0lBSUFNZ0FDZ0NCRFlDQkNBRElBQW9BZ2cyQWdnZ0F5QUFLQUlNTmdJTUN5QUJFRElnQVVFTVFSd2dBU2dDRENBQktBSUlJQUVvQWdRZ0FTZ0NBSEp5Y2h0cUtBSUFRUjUySUF0QkIzWkhCRUFnQVJCSEN5QUJJQUlRUlFKL0lBSVFLRVVFUUNBQ1FSQnFJZ0FRSFNBRElBQW9BZ0EyQWdBZ0F5QUFLQUlFTmdJRUlBTWdBQ2dDQ0RZQ0NDQURJQUFvQWd3MkFneEJBQ0FDRUNoRkRRRWFDMEVCQ3lFQUlBSkI4QUpxSkFBZ0FBdUNBd0VKZnlNQVFlQUJheUlCSkFBZ0FCQkpJQUJCUUdzaUNDQUJRVUJySWdrUUNDQUFRU0JxSWdVZ0NDQUJRZUFBYWlJR0VBWWdDVUdnandJZ0FVSEFBV29pQXhBR0lBVWdBVUdBQVdvaUJCQUlJQU1nQkNBREVBY2dCa0hBandJZ0FVR2dBV29pQWhBR0lBTWdBaUFCUVNCcUlnY1FEU0FESUFJZ0F4QUhJQU1nQ0NBREVBWWdCa0hnandJZ0FoQUdJQU1nQnlBREVBWWdDVUdBa0FJZ0J4QUdJQVFnQnlBSEVBY2dBaUFISUFFUURTQUNJQWNnQWhBSElBRWdBaUFCRUFZZ0FVR2drQUlnQVJBR0lBQWdBU0FBRUFZZ0JDQUJFQWdnQmlBRUVBZ2dDU0FHRUFnZ0JFSEFrQUlnQWhBR0lBWkI0SkFDSUFjUUJpQUNJQUVnQWhBSElBUkJnSkVDSUFRUUJpQUdRYUNSQWlBR0VBWWdBaUFISUFJUUJ5QUVJQVlnQkJBSElBSWdCU0FDRUFZZ0FTQUVJQVVRQnlBQUlBSWdBQkFHSUFWQndKRUNJQVVRQmlBQVFSQnFFQjBnQlNBSUlBVVFCaUFESUFJZ0NCQUdJQVVnQXlBRkVBWWdBRUhRQUdvUUhTQUFRVEJxRUIwZ0FCQkdJQUZCNEFGcUpBQUwzd0lCRDM4Z0FTQUFLQUlBSWdJMkFnQWdBU0FBS0FJRUlnTTJBZ1FnQVNBQUtBSUlJZ1EyQWdnZ0FTQUFLQUlNSWdVMkFnd2dBU0FBS0FJUUlnWTJBaEFnQVNBQUtBSVVJZ2MyQWhRZ0FTQUFLQUlZSWdnMkFoZ2dBU0FBS0FJY0lnazJBaHdnQVNBQUtBSWdJZ28yQWlBZ0FTQUFLQUlrSWdzMkFpUWdBU0FBS0FJb0lndzJBaWdnQVNBQUtBSXNJZzAyQWl3Z0FTQUFLQUl3SWc0MkFqQWdBU0FBS0FJMElnODJBalFnQVNBQUtBSTRJaEEyQWpnZ0FTQUFLQUk4SWdBMkFwd0JJQUVnRURZQ21BRWdBU0FQTmdLVUFTQUJJQTQyQXBBQklBRWdEVFlDakFFZ0FTQU1OZ0tJQVNBQklBczJBb1FCSUFFZ0NqWUNnQUVnQVNBSk5nSjhJQUVnQ0RZQ2VDQUJJQWMyQW5RZ0FTQUdOZ0p3SUFFZ0JUWUNiQ0FCSUFRMkFtZ2dBU0FETmdKa0lBRWdBallDWUNBQklBQTJBandnQVVJQU53SkVJQUZDQURjQ1RDQUJRZ0EzQWxRZ0FVRUFOZ0pjSUFGQkFUWUNRQXVMQVFFR2Z5TUFRVUJxSWdJa0FDQUFJQUpCSUdvaUF4QUlJQUJCUUdzaUFTQUFRZUFBYWlJRUVBZ2dBRUVnYWlJRklBSVFDQ0FFSUFRZ0FSQUhJQUlnQXlBRUVBMGdBeUFDSUFNUUJ5QUFJQVVnQUJBR0lBRWdCQ0FCRUEwZ0FFR0Fqd0lnQUVHQUFXb2lCaEFHSUFFZ0JDQUZFQVlnQmlBRElBQVFCaUFCSUFNZ0FSQUdJQUpCUUdza0FBdHlBQ0FBSUFBb0FnQkJmM00yQWdBZ0FDQUFLQUlFUVg5ek5nSUVJQUFnQUNnQ0NFRi9jellDQ0NBQVFmLy8vLzhISUFBb0FneHJOZ0lNSUFBZ0FDZ0NFRUYvY3pZQ0VDQUFJQUFvQWhSQmYzTTJBaFFnQUNBQUtBSVlRWDl6TmdJWUlBQkIvLy8vL3djZ0FDZ0NIR3MyQWh3TFRRRUJmeU1BUVVCcUlnSWtBQ0FDUWdBM0F4Z2dBa0lBTndNUUlBSkNBRGNEQUNBQ1FnQTNBd2dnQWtFQk5nSUFJQUJCd0FnZ0FrRWdhaUlBRUJzZ0FDQUNJQUVRR3lBQ1FVQnJKQUFMZndFRWZ5TUFRVUJxSWdNa0FDQUFJQU5CSUdvaUFoQUlJQUJCSUdvaUFTQURFQWdnQUNBQklBQVFCaUFBUVVCcklnUWdBUkFJSUFJZ0F5QUVFQWNnQXlBQ0lBSVFEU0FCSUFFZ0FSQUhJQUFnQWlBQUVBWWdBU0FDSUFFUURTQUFRZUNOQWlBQUVBWWdBU0FFSUFFUUJpQUVJQUlnQkJBR0lBTkJRR3NrQUF2aUNBRUZmeU1BUWRBQWF5SUVKQUFnQUNBQUlBUkJNR29pQXhBRklBQWdBeUFERUFVZ0F5QURJQVJCSUdvaUJoQUZJQVlnQmlBR0VBVWdBeUFHSUFZUUJTQUdJQVlnQkVFUWFpSUZFQVVnQlNBRklBVVFCU0FGSUFVZ0JSQUZJQVVnQlNBRkVBVWdCaUFGSUFVUUJTQUZJQVVnQkJBRklBUWdCQ0FFRUFVZ0JDQUVJQVFRQlNBRUlBUWdCQkFGSUFRZ0JDQUVFQVVnQkNBRUlBUVFCU0FFSUFRZ0JCQUZJQVFnQkNBRUVBVWdCU0FFSUFRUUJTQUVJQVFnQXhBRklBTWdBeUFERUFVZ0F5QURJQU1RQlNBRElBTWdBeEFGSUFNZ0F5QURFQVVnQXlBRElBTVFCU0FESUFNZ0F4QUZJQU1nQXlBREVBVWdBeUFESUFNUUJTQURJQU1nQXhBRklBTWdBeUFERUFVZ0F5QURJQU1RQlNBRElBTWdBeEFGSUFNZ0F5QURFQVVnQXlBRElBTVFCU0FESUFNZ0F4QUZJQVFnQXlBREVBVWdBeUFESUFSQlFHc2lBaEFGSUFJZ0FpQUNFQVVnQWlBQ0lBSVFCU0FDSUFJZ0FoQUZJQUlnQWlBQ0VBVWdBaUFDSUFJUUJTQUNJQUlnQWhBRklBSWdBaUFDRUFVZ0FpQUNJQUlRQlNBQ0lBSWdBaEFGSUFJZ0FpQUNFQVVnQWlBQ0lBSVFCU0FDSUFJZ0FoQUZJQUlnQWlBQ0VBVWdBaUFDSUFJUUJTQUNJQUlnQWhBRklBSWdBaUFDRUFVZ0FpQUNJQUlRQlNBQ0lBSWdBaEFGSUFJZ0FpQUNFQVVnQWlBQ0lBSVFCU0FDSUFJZ0FoQUZJQUlnQWlBQ0VBVWdBaUFDSUFJUUJTQUNJQUlnQWhBRklBSWdBaUFDRUFVZ0FpQUNJQUlRQlNBQ0lBSWdBaEFGSUFJZ0FpQUNFQVVnQWlBQ0lBSVFCU0FDSUFJZ0FoQUZJQUlnQWlBQ0VBVWdBeUFDSUFJUUJTQUNJQUlnQWhBRklBSWdBaUFDRUFVZ0FpQUNJQUlRQlNBQ0lBSWdBaEFGSUFJZ0FpQUNFQVVnQWlBQ0lBSVFCU0FDSUFJZ0FoQUZJQUlnQWlBQ0VBVWdBaUFDSUFJUUJTQUNJQUlnQWhBRklBSWdBaUFDRUFVZ0FpQUNJQUlRQlNBQ0lBSWdBaEFGSUFJZ0FpQUNFQVVnQWlBQ0lBSVFCU0FDSUFJZ0FoQUZJQUlnQWlBQ0VBVWdBaUFDSUFJUUJTQUNJQUlnQWhBRklBSWdBaUFDRUFVZ0FpQUNJQUlRQlNBQ0lBSWdBaEFGSUFJZ0FpQUNFQVVnQWlBQ0lBSVFCU0FDSUFJZ0FoQUZJQUlnQWlBQ0VBVWdBaUFDSUFJUUJTQUNJQUlnQWhBRklBSWdBaUFDRUFVZ0FpQUNJQUlRQlNBQ0lBSWdBaEFGSUFJZ0FpQUNFQVVnQWlBRElBSVFCU0FDSUFJZ0FoQUZJQUlnQWlBQ0VBVWdBaUFDSUFJUUJTQUNJQUlnQWhBRklBSWdBaUFDRUFVZ0FpQUNJQUlRQlNBQ0lBSWdBaEFGSUFJZ0FpQUNFQVVnQWlBQ0lBSVFCU0FDSUFJZ0FoQUZJQUlnQWlBQ0VBVWdBaUFDSUFJUUJTQUNJQUlnQWhBRklBSWdBaUFDRUFVZ0FpQUNJQUlRQlNBQ0lBSWdBaEFGSUFRZ0FpQUNFQVVnQWlBQ0lBSVFCU0FDSUFJZ0FoQUZJQUlnQWlBQ0VBVWdBaUFDSUFJUUJTQUNJQUlnQWhBRklBSWdBaUFDRUFVZ0FpQUNJQUlRQlNBQ0lBSWdBaEFGSUFVZ0FpQUNFQVVnQWlBQ0lBSVFCU0FDSUFJZ0FoQUZJQUlnQWlBQ0VBVWdBaUFDSUFJUUJTQUdJQUlnQWhBRklBSWdBaUFDRUFVZ0FDQUNJQUVRQlNBRVFkQUFhaVFBQzQ4RkFnWitBWDhnQVNBQktBSUFRUWRxUVhoeElnRkJFR28yQWdBZ0FBSjhJQUVwQXdBaEF5QUJLUU1JSVFZakFFRWdheUlJSkFBQ1FDQUdRdi8vLy8vLy8vLy8vd0NESWdSQ2dJQ0FnSUNBd0lBOGZTQUVRb0NBZ0lDQWdNRC93d0I5VkFSQUlBWkNCSVlnQTBJOGlJUWhCQ0FEUXYvLy8vLy8vLy8vRDRNaUEwS0JnSUNBZ0lDQWdBaGFCRUFnQkVLQmdJQ0FnSUNBZ01BQWZDRUNEQUlMSUFSQ2dJQ0FnSUNBZ0lCQWZTRUNJQU5DZ0lDQWdJQ0FnSUFJaFVJQVVnMEJJQUlnQkVJQmczd2hBZ3dCQ3lBRFVDQUVRb0NBZ0lDQWdNRC8vd0JVSUFSQ2dJQ0FnSUNBd1AvL0FGRWJSUVJBSUFaQ0JJWWdBMEk4aUlSQy8vLy8vLy8vL3dPRFFvQ0FnSUNBZ0lEOC93Q0VJUUlNQVF0Q2dJQ0FnSUNBZ1BqL0FDRUNJQVJDLy8vLy8vLy92Ly9EQUZZTkFFSUFJUUlnQkVJd2lLY2lBRUdSOXdCSkRRQWdBeUVDSUFaQy8vLy8vLy8vUDROQ2dJQ0FnSUNBd0FDRUlnVWhCd0pBSUFCQmdmY0FheUlCUWNBQWNRUkFJQUlnQVVGQWFxMkdJUWRDQUNFQ0RBRUxJQUZGRFFBZ0J5QUJyU0lFaGlBQ1FjQUFJQUZycllpRUlRY2dBaUFFaGlFQ0N5QUlJQUkzQXhBZ0NDQUhOd01ZQWtCQmdmZ0FJQUJySWdCQndBQnhCRUFnQlNBQVFVQnFyWWdoQTBJQUlRVU1BUXNnQUVVTkFDQUZRY0FBSUFCcnJZWWdBeUFBclNJQ2lJUWhBeUFGSUFLSUlRVUxJQWdnQXpjREFDQUlJQVUzQXdnZ0NDa0RDRUlFaGlBSUtRTUFJZ05DUElpRUlRSWdDQ2tERUNBSUtRTVloRUlBVXEwZ0EwTC8vLy8vLy8vLy93K0RoQ0lEUW9HQWdJQ0FnSUNBQ0ZvRVFDQUNRZ0Y4SVFJTUFRc2dBMEtBZ0lDQWdJQ0FnQWlGUWdCU0RRQWdBa0lCZ3lBQ2ZDRUNDeUFJUVNCcUpBQWdBaUFHUW9DQWdJQ0FnSUNBZ0grRGhMOExPUU1BQzc0WUF4Si9BWHdDZmlNQVFiQUVheUlMSkFBZ0MwRUFOZ0lzQWtBZ0FiMGlHVUlBVXdSQVFRRWhFRUdPaHdJaEV5QUJtaUlCdlNFWkRBRUxJQVJCZ0JCeEJFQkJBU0VRUVpHSEFpRVREQUVMUVpTSEFrR1Bod0lnQkVFQmNTSVFHeUVUSUJCRklSUUxBa0FnR1VLQWdJQ0FnSUNBK1A4QWcwS0FnSUNBZ0lDQStQOEFVUVJBSUFCQklDQUNJQkJCQTJvaUF5QUVRZi8vZTNFUUNpQUFJQk1nRUJBSklBQkI1NGNDUWFtSUFpQUZRU0J4SWdVYlFmaUhBa0d0aUFJZ0JSc2dBU0FCWWh0QkF4QUpJQUJCSUNBQ0lBTWdCRUdBd0FCekVBb2dBaUFESUFJZ0Ewb2JJUWtNQVFzZ0MwRVFhaUVSQWtBQ2Z3SkFJQUVnQzBFc2FoQTVJZ0VnQWFBaUFVUUFBQUFBQUFBQUFHSUVRQ0FMSUFzb0Fpd2lCa0VCYXpZQ0xDQUZRU0J5SWc1QjRRQkhEUUVNQXdzZ0JVRWdjaUlPUWVFQVJnMENJQXNvQWl3aENrRUdJQU1nQTBFQVNCc01BUXNnQ3lBR1FSMXJJZ28yQWl3Z0FVUUFBQUFBQUFDd1FhSWhBVUVHSUFNZ0EwRUFTQnNMSVF3Z0MwRXdhaUFMUWRBQ2FpQUtRUUJJR3lJTklRY0RRQ0FIQW44Z0FVUUFBQUFBQUFEd1FXTWdBVVFBQUFBQUFBQUFBR1p4QkVBZ0Fhc01BUXRCQUFzaUF6WUNBQ0FIUVFScUlRY2dBU0FEdUtGRUFBQUFBR1hOelVHaUlnRkVBQUFBQUFBQUFBQmlEUUFMQWtBZ0NrRUFUQVJBSUFvaEF5QUhJUVlnRFNFSURBRUxJQTBoQ0NBS0lRTURRQ0FEUVIwZ0EwRWRTUnNoQXdKQUlBZEJCR3NpQmlBSVNRMEFJQU90SVJwQ0FDRVpBMEFnQmlBWlF2Ly8vLzhQZ3lBR05RSUFJQnFHZkNJWklCbENnSlRyM0FPQUlobENnSlRyM0FOK2ZUNENBQ0FHUVFScklnWWdDRThOQUFzZ0dhY2lCa1VOQUNBSVFRUnJJZ2dnQmpZQ0FBc0RRQ0FJSUFjaUJra0VRQ0FHUVFScklnY29BZ0JGRFFFTEN5QUxJQXNvQWl3Z0Eyc2lBellDTENBR0lRY2dBMEVBU2cwQUN3c2dERUVaYWtFSmJpRUhJQU5CQUVnRVFDQUhRUUZxSVJJZ0RrSG1BRVloRlFOQVFRQWdBMnNpQTBFSklBTkJDVWtiSVFrQ1FDQUdJQWhMQkVCQmdKVHIzQU1nQ1hZaEZrRi9JQWwwUVg5eklROUJBQ0VESUFnaEJ3TkFJQWNnQXlBSEtBSUFJaGNnQ1hacU5nSUFJQThnRjNFZ0Ztd2hBeUFIUVFScUlnY2dCa2tOQUFzZ0NDZ0NBQ0VISUFORkRRRWdCaUFETmdJQUlBWkJCR29oQmd3QkN5QUlLQUlBSVFjTElBc2dDeWdDTENBSmFpSUROZ0lzSUEwZ0NDQUhSVUVDZEdvaUNDQVZHeUlISUJKQkFuUnFJQVlnQmlBSGEwRUNkU0FTU2hzaEJpQURRUUJJRFFBTEMwRUFJUU1DUUNBR0lBaE5EUUFnRFNBSWEwRUNkVUVKYkNFRFFRb2hCeUFJS0FJQUlnbEJDa2tOQUFOQUlBTkJBV29oQXlBSklBZEJDbXdpQjA4TkFBc0xJQXhCQUNBRElBNUI1Z0JHRzJzZ0RrSG5BRVlnREVFQVIzRnJJZ2NnQmlBTmEwRUNkVUVKYkVFSmEwZ0VRRUVFUWFRQ0lBcEJBRWdiSUF0cUlBZEJnTWdBYWlJSlFRbHRJZzlCQW5ScVFkQWZheUVLUVFvaEJ5QUpJQTlCQ1d4cklnbEJCMHdFUUFOQUlBZEJDbXdoQnlBSlFRRnFJZ2xCQ0VjTkFBc0xBa0FnQ2lnQ0FDSVNJQklnQjI0aUZTQUhiR3NpQ1VVZ0NrRUVhaUlQSUFaR2NRMEFBa0FnRlVFQmNVVUVRRVFBQUFBQUFBQkFReUVCSUFkQmdKVHIzQU5IRFFFZ0NDQUtUdzBCSUFwQkJHc3RBQUJCQVhGRkRRRUxSQUVBQUFBQUFFQkRJUUVMUkFBQUFBQUFBT0EvUkFBQUFBQUFBUEEvUkFBQUFBQUFBUGcvSUFZZ0QwWWJSQUFBQUFBQUFQZy9JQWtnQjBFQmRpSVBSaHNnQ1NBUFNSc2hHQUpBSUJRTkFDQVRMUUFBUVMxSERRQWdHSm9oR0NBQm1pRUJDeUFLSUJJZ0NXc2lDVFlDQUNBQklCaWdJQUZoRFFBZ0NpQUhJQWxxSWdNMkFnQWdBMEdBbE92Y0EwOEVRQU5BSUFwQkFEWUNBQ0FJSUFwQkJHc2lDa3NFUUNBSVFRUnJJZ2hCQURZQ0FBc2dDaUFLS0FJQVFRRnFJZ00yQWdBZ0EwSC9rK3ZjQTBzTkFBc0xJQTBnQ0d0QkFuVkJDV3doQTBFS0lRY2dDQ2dDQUNJSlFRcEpEUUFEUUNBRFFRRnFJUU1nQ1NBSFFRcHNJZ2RQRFFBTEN5QUtRUVJxSWdjZ0JpQUdJQWRMR3lFR0N3TkFJQVlpQnlBSVRTSUpSUVJBSUFkQkJHc2lCaWdDQUVVTkFRc0xBa0FnRGtIbkFFY0VRQ0FFUVFoeElRb01BUXNnQTBGL2MwRi9JQXhCQVNBTUd5SUdJQU5LSUFOQmUwcHhJZ29iSUFacUlReEJmMEYrSUFvYklBVnFJUVVnQkVFSWNTSUtEUUJCZHlFR0FrQWdDUTBBSUFkQkJHc29BZ0FpRGtVTkFFRUtJUWxCQUNFR0lBNUJDbkFOQUFOQUlBWWlDa0VCYWlFR0lBNGdDVUVLYkNJSmNFVU5BQXNnQ2tGL2N5RUdDeUFISUExclFRSjFRUWxzSVFrZ0JVRmZjVUhHQUVZRVFFRUFJUW9nRENBR0lBbHFRUWxySWdaQkFDQUdRUUJLR3lJR0lBWWdERW9iSVF3TUFRdEJBQ0VLSUF3Z0F5QUphaUFHYWtFSmF5SUdRUUFnQmtFQVNoc2lCaUFHSUF4S0d5RU1DMEYvSVFrZ0RFSDkvLy8vQjBIKy8vLy9CeUFLSUF4eUlnWWJTZzBCSUF3Z0JrRUFSeUlTYWtFQmFpRU9Ba0FnQlVGZmNTSVVRY1lBUmdSQUlBTkIvLy8vL3djZ0RtdEtEUU1nQTBFQUlBTkJBRW9iSVFZTUFRc2dFU0FESUFOQkgzVWlCbW9nQm5PdElCRVFIaUlHYTBFQlRBUkFBMEFnQmtFQmF5SUdRVEE2QUFBZ0VTQUdhMEVDU0EwQUN3c2dCa0VDYXlJUElBVTZBQUFnQmtFQmEwRXRRU3NnQTBFQVNCczZBQUFnRVNBUGF5SUdRZi8vLy84SElBNXJTZzBDQ3lBR0lBNXFJZ01nRUVILy8vLy9CM05LRFFFZ0FFRWdJQUlnQXlBUWFpSUZJQVFRQ2lBQUlCTWdFQkFKSUFCQk1DQUNJQVVnQkVHQWdBUnpFQW9DUUFKQUFrQWdGRUhHQUVZRVFDQUxRUkJxSWdaQkNISWhBeUFHUVFseUlRb2dEU0FJSUFnZ0RVc2JJZ2toQ0FOQUlBZzFBZ0FnQ2hBZUlRWUNRQ0FJSUFsSEJFQWdCaUFMUVJCcVRRMEJBMEFnQmtFQmF5SUdRVEE2QUFBZ0JpQUxRUkJxU3cwQUN3d0JDeUFHSUFwSERRQWdDMEV3T2dBWUlBTWhCZ3NnQUNBR0lBb2dCbXNRQ1NBSVFRUnFJZ2dnRFUwTkFBdEJBQ0VHSUJKRkRRSWdBRUhLaUFKQkFSQUpJQWNnQ0UwTkFTQU1RUUJNRFFFRFFDQUlOUUlBSUFvUUhpSUdJQXRCRUdwTEJFQURRQ0FHUVFGcklnWkJNRG9BQUNBR0lBdEJFR3BMRFFBTEN5QUFJQVlnREVFSklBeEJDVWdiRUFrZ0RFRUpheUVHSUFoQkJHb2lDQ0FIVHcwRElBeEJDVW9oQXlBR0lRd2dBdzBBQ3d3Q0N3SkFJQXhCQUVnTkFDQUhJQWhCQkdvZ0J5QUlTeHNoQ1NBTFFSQnFJZ05CQ1hJaERTQURRUWh5SVFNZ0NDRUhBMEFnRFNBSE5RSUFJQTBRSGlJR1JnUkFJQXRCTURvQUdDQURJUVlMQWtBZ0J5QUlSd1JBSUFZZ0MwRVFhazBOQVFOQUlBWkJBV3NpQmtFd09nQUFJQVlnQzBFUWFrc05BQXNNQVFzZ0FDQUdRUUVRQ1NBR1FRRnFJUVlnQ2lBTWNrVU5BQ0FBUWNxSUFrRUJFQWtMSUFBZ0JpQU5JQVpySWdZZ0RDQUdJQXhJR3hBSklBd2dCbXNoRENBSFFRUnFJZ2NnQ1U4TkFTQU1RUUJPRFFBTEN5QUFRVEFnREVFU2FrRVNRUUFRQ2lBQUlBOGdFU0FQYXhBSkRBSUxJQXdoQmdzZ0FFRXdJQVpCQ1dwQkNVRUFFQW9MSUFCQklDQUNJQVVnQkVHQXdBQnpFQW9nQWlBRklBSWdCVW9iSVFrTUFRc2dFeUFGUVJwMFFSOTFRUWx4YWlFTUFrQWdBMEVMU3cwQVFRd2dBMnNoQmtRQUFBQUFBQUF3UUNFWUEwQWdHRVFBQUFBQUFBQXdRS0loR0NBR1FRRnJJZ1lOQUFzZ0RDMEFBRUV0UmdSQUlCZ2dBWm9nR0tHZ21pRUJEQUVMSUFFZ0dLQWdHS0VoQVFzZ0VTQUxLQUlzSWdZZ0JrRWZkU0lHYWlBR2M2MGdFUkFlSWdaR0JFQWdDMEV3T2dBUElBdEJEMm9oQmdzZ0VFRUNjaUVLSUFWQklIRWhDQ0FMS0FJc0lRY2dCa0VDYXlJTklBVkJEMm82QUFBZ0JrRUJhMEV0UVNzZ0IwRUFTQnM2QUFBZ0JFRUljU0VHSUF0QkVHb2hCd05BSUFjaUJRSi9JQUdaUkFBQUFBQUFBT0JCWXdSQUlBR3FEQUVMUVlDQWdJQjRDeUlIUWRDTUFtb3RBQUFnQ0hJNkFBQWdBU0FIdDZGRUFBQUFBQUFBTUVDaUlRRUNRQ0FGUVFGcUlnY2dDMEVRYW10QkFVY05BQUpBSUFGRUFBQUFBQUFBQUFCaURRQWdBMEVBU2cwQUlBWkZEUUVMSUFWQkxqb0FBU0FGUVFKcUlRY0xJQUZFQUFBQUFBQUFBQUJpRFFBTFFYOGhDVUg5Ly8vL0J5QUtJQkVnRFdzaUJXb2lCbXNnQTBnTkFDQUFRU0FnQWlBR0FuOENRQ0FEUlEwQUlBY2dDMEVRYW1zaUNFRUNheUFEVGcwQUlBTkJBbW9NQVFzZ0J5QUxRUkJxYXlJSUN5SUhhaUlESUFRUUNpQUFJQXdnQ2hBSklBQkJNQ0FDSUFNZ0JFR0FnQVJ6RUFvZ0FDQUxRUkJxSUFnUUNTQUFRVEFnQnlBSWEwRUFRUUFRQ2lBQUlBMGdCUkFKSUFCQklDQUNJQU1nQkVHQXdBQnpFQW9nQWlBRElBSWdBMG9iSVFrTElBdEJzQVJxSkFBZ0NRdFBBUUYvSUFBb0Fqd2hBeU1BUVJCcklnQWtBQ0FESUFFZ0FrSC9BWEVnQUVFSWFoQUJJZ0lFZjBINGtnSWdBallDQUVGL0JVRUFDeUVDSUFBcEF3Z2hBU0FBUVJCcUpBQkNmeUFCSUFJYkMrOENBUWQvSXdCQklHc2lCQ1FBSUFRZ0FDZ0NIQ0lGTmdJUUlBQW9BaFFoQXlBRUlBSTJBaHdnQkNBQk5nSVlJQVFnQXlBRmF5SUJOZ0lVSUFFZ0Ftb2hCVUVDSVFjQ2Z3SkFBa0FnQUNnQ1BDQUVRUkJxSWdGQkFpQUVRUXhxRUFBaUF3Ui9RZmlTQWlBRE5nSUFRWDhGUVFBTFJRUkFBMEFnQlNBRUtBSU1JZ05HRFFJZ0EwRUFTQTBESUFFZ0F5QUJLQUlFSWdoTElnWkJBM1JxSWdrZ0F5QUlRUUFnQmh0cklnZ2dDU2dDQUdvMkFnQWdBVUVNUVFRZ0JodHFJZ2tnQ1NnQ0FDQUlhellDQUNBRklBTnJJUVVnQUNnQ1BDQUJRUWhxSUFFZ0Joc2lBU0FISUFacklnY2dCRUVNYWhBQUlnTUVmMEg0a2dJZ0F6WUNBRUYvQlVFQUMwVU5BQXNMSUFWQmYwY05BUXNnQUNBQUtBSXNJZ0UyQWh3Z0FDQUJOZ0lVSUFBZ0FTQUFLQUl3YWpZQ0VDQUNEQUVMSUFCQkFEWUNIQ0FBUWdBM0F4QWdBQ0FBS0FJQVFTQnlOZ0lBUVFBZ0IwRUNSZzBBR2lBQ0lBRW9BZ1JyQ3lFQUlBUkJJR29rQUNBQUN3a0FJQUFvQWp3UUFndXhBUUVDZnlNQVFVQnFJZ01rQUVFR0lRUUNRQUpBSUFFc0FBOUJBRWdOQUNBQkxBQWZRUUJJRFFBZ0FTd0FMMEVBU0EwQUlBRXNBRDlCQUVnTkFFRUFJUVFnQVNBQUlBTVFPMFVOQUFKQUlBTkJDQkFtUlEwQVFRY2hCQ0FEUVNScVFRY1FKa1VOQUNBREtBSWdRUUZHRFFFTElBSWdBeWtESURjQUFDQUNJQU1wQXpnM0FCZ2dBaUFES1FNd053QVFJQUlnQXlrREtEY0FDRUVCSVFRTUFRc2dBa0VJRUJNTElBTkJRR3NrQUNBRUN5Y0JBWDhnQUJBK0lnSkJBVVlFUUNBQUlBRVFJQ0FDRHdzZ0FFRUlFQk1nQVVFUUVCTWdBZ3NLQUNBQUlBRVFJRUVCQzZNQkFRRi9Jd0JCUUdvaUF5UUFBa0FDUUNBQkxBQVBRUUJJQkVCQkJpRUJEQUVMSUFFZ0F4QkRJZ0ZCQVVjTkFFRUFJUUVnQXlBQUlBTVFPMFVOQUFKQUlBTkJDQkFtUlEwQVFRY2hBU0FEUVNScVFRY1FKa1VOQUNBREtBSWdRUUZHRFFFTElBSWdBeWtESURjQUFDQUNJQU1wQXpnM0FCZ2dBaUFES1FNd053QVFJQUlnQXlrREtEY0FDRUVCSVFFTUFRc2dBa0VJRUJNTElBTkJRR3NrQUNBQkN6OEJBbjhqQUVGQWFpSUNKQUFDUUNBQUVENGlBMEVCUmdSQUlBQWdBaEFnSUFJZ0FSQWlEQUVMSUFCQkNCQVRJQUZCQ0JBVEN5QUNRVUJySkFBZ0F3c2lBUUYvSXdCQlFHb2lBaVFBSUFBZ0FoQWdJQUlnQVJBaUlBSkJRR3NrQUVFQkMva3pBaE4vQVg0akFFR0FBV3NpQ1NRQUlBUkJBRFlDQUFKQUlBSkJRR3NpQlJBOElncEZCRUJCQlNFUkRBRUxRUVloRVFKQUlBQXNBQTlCQUVnTkFDQURMQUFQUVFCSURRQWdBeTBBUHcwQUlBTXRBRDVCUDBzTkFDQUFJQWxCUUdzUVF5SVJRUUZIRFFBZ0NpQURLUUFBTndBQUlBb2dBeWtBR0RjQUdDQUtJQU1wQUJBM0FCQWdDaUFES1FBSU53QUlJQW9nQUNrQUFEY0FJQ0FLSUFBcEFBZzNBQ2dnQ2lBQUtRQVFOd0F3SUFvZ0FDa0FHRGNBT0NBS1FVQnJJQUVnQWhBWUdrRUFJUkVnQ2lBRklBbEJJRUVBUVFBUUh3MEFJQU5CSUdvaEFTQUpRVUJySWdBaEFpTUFRY0FwYXlJRkpBQWdCVUd3SjJwQkFFR0VBaEFPSUFWQm9DVnFRUUJCaEFJUURpQUZRWkFqYWtFQVFZUUNFQTRnQlVHQUlXcEJBRUdFQWhBT0lBVkI4QjVxUVFCQmhBSVFEaUFGUWVBY2FrRUFRWVFDRUE0Z0JVSFFHbXBCQUVHRUFoQU9JQVZCd0JocVFRQkJoQUlRRGlBRklBQW9BZ0FpQmpZQ3dCWWdCU0FBS0FJRUlnYzJBc1FXSUFVZ0FDZ0NDQ0lJTmdMSUZpQUZJQUFvQWd3aUVqWUN6QllnQlNBQUtBSVFJZ3MyQXRBV0lBVkIxQlpxSUFBb0FoUWlERFlDQUNBRlFkZ1dhaUFBS0FJWUlnMDJBZ0FnQlVIY0Ztb2dBQ2dDSENJT05nSUFJQVVnQUNnQ0lDSVBOZ0xnRmlBRlFlUVdhaUFBS0FJa0loQTJBZ0FnQlVIb0Ztb2dBQ2dDS0NJVE5nSUFJQVZCN0JacUlBQW9BaXdpRkRZQ0FDQUZRZkFXYWlBQUtBSXdJaFUyQWdBZ0JVSDBGbW9nQUNnQ05DSVdOZ0lBSUFWQitCWnFJQUFvQWpnaUZ6WUNBQ0FGUWR3WGFpQUFLQUk4SWdBMkFnQWdCVUhZRjJvZ0Z6WUNBQ0FGUWRRWGFpQVdOZ0lBSUFWQjBCZHFJQlUyQWdBZ0JVSE1GMm9nRkRZQ0FDQUZRY2dYYWlBVE5nSUFJQVZCeEJkcUlCQTJBZ0FnQlVHOEYyb2dEallDQUNBRlFiZ1hhaUFOTmdJQUlBVkJ0QmRxSUF3MkFnQWdCVUd3RjJvZ0N6WUNBQ0FGUWF3WGFpQVNOZ0lBSUFWQnFCZHFJQWcyQWdBZ0JVR2tGMm9nQnpZQ0FDQUZRZndXYWlBQU5nSUFJQVZCaEJkcVFnQTNBZ0FnQlVHTUYyb2lBRUlBTndJQUlBVkJsQmRxSWdkQ0FEY0NBQ0FGUVp3WGFpSUlRUUEyQWdBZ0JTQVBOZ0xBRnlBRklBWTJBcUFYSUFWQkFUWUNnQmNnQlVIQUZtb1FLQ0lTQkVBZ0JVRzBGV29pQmlBRktRTFVGamNDQUNBRlFid1ZhaUlMSUFVcEF0d1dOd0lBSUFWQnhCVnFJZ3dnQlNrQzVCWTNBZ0FnQlVITUZXb2lEU0FGS1FMc0ZqY0NBQ0FGUWRRVmFpSU9JQVVwQXZRV053SUFJQVZCM0JWcUlnOGdCU2dDL0JZMkFnQWdCU0FGS0FMQUZqWUNvQlVnQlNBRktRTEVGamNDcEJVZ0JTQUZLUUxNRmpjQ3JCVWdCVUhrRldvZ0JTa0NoQmMzQWdBZ0JVSHNGV29nQUNrQ0FEY0NBQ0FGUWZRVmFpQUhLUUlBTndJQUlBVkIvQlZxSUFncEFnQTNBZ0FnQlVHRUZtb2dCU2tDcEJjM0FnQWdCVUdNRm1vZ0JTa0NyQmMzQWdBZ0JVR1VGbW9nQlNrQ3RCYzNBZ0FnQlVHY0Ztb2lBQ0FGS0FLOEZ6WUNBQ0FGSUFVb0FvQVhOZ0xnRlNBRlFhZ1dhaUlISUFVcEE4Z1hOd01BSUFWQnNCWnFJZ2dnQlNrRDBCYzNBd0FnQlVHNEZtb2lFQ0FGS1FQWUZ6Y0RBQ0FGSUFVcEE4QVhOd09nRmlBRlFhQVZhaEJFSUFWQmxCUnFJQVVwQXRRV053SUFJQVZCbkJScUlBVXBBdHdXTndJQUlBVkJwQlJxSUFVcEF1UVdOd0lBSUFWQnJCUnFJQVVwQXV3V053SUFJQVZCdEJScUlBVXBBdlFXTndJQUlBVkJ2QlJxSUFVb0F2d1dOZ0lBSUFVZ0JTZ0N3QlkyQW9BVUlBVWdCU2tDeEJZM0FvUVVJQVVnQlNrQ3pCWTNBb3dVSUFWQnlCUnFJQVZCaUJkcUtRTUFOd01BSUFWQjBCUnFJQVZCa0JkcUtRTUFOd01BSUFWQjJCUnFJQVZCbUJkcUtRTUFOd01BSUFWQjZCUnFJQVVwQTZnWE53TUFJQVZCOEJScUlBVXBBN0FYTndNQUlBVkIrQlJxSUFVb0FyZ1hOZ0lBSUFVZ0JTa0RnQmMzQThBVUlBVWdCU2tEb0JjM0ErQVVJQVZCL0JScUlBVW9BcndYTmdJQUlBVkJpQlZxSUFVcEE4Z1hOd01BSUFWQmtCVnFJQVVwQTlBWE53TUFJQVZCbUJWcUlBVXBBOWdYTndNQUlBVWdCU2tEd0JjM0E0QVZJQVZCZ0JScUVDa2dCVUgwRW1vZ0Jpa0NBRGNDQUNBRlFmd1NhaUFMS1FJQU53SUFJQVZCaEJOcUlBd3BBZ0EzQWdBZ0JVR01FMm9nRFNrQ0FEY0NBQ0FGUVpRVGFpQU9LUUlBTndJQUlBVkJuQk5xSUE4b0FnQTJBZ0FnQlNBRktBS2dGVFlDNEJJZ0JTQUZLUUtrRlRjQzVCSWdCU0FGS1FLc0ZUY0M3QklnQlVHb0Uyb2dCVUhvRldvcEF3QTNBd0FnQlVHd0Uyb2dCVUh3RldvcEF3QTNBd0FnQlVHNEUyb2dCVUg0RldvcEF3QTNBd0FnQlVISUUyb2dCVUdJRm1vcEF3QTNBd0FnQlVIUUUyb2dCVUdRRm1vcEF3QTNBd0FnQlVIWUUyb2dCVUdZRm1vb0FnQTJBZ0FnQlNBRktRUGdGVGNEb0JNZ0JTQUZLUU9BRmpjRHdCTWdCVUhjRTJvZ0FDZ0NBRFlDQUNBRlFlZ1RhaUFIS1FNQU53TUFJQVZCOEJOcUlBZ3BBd0EzQXdBZ0JVSDRFMm9nRUNrREFEY0RBQ0FGSUFVcEE2QVdOd1BnRXlBRlFlQVNhaEFwSUFFZ0JVRWdhaEF2SUFrZ0JSQXZBa0FnQlNrRElDSVlVQTBBSUFWQnNDZHFRUVJ5SVFaQkFDRUFBMEFDUUNBWVFnR0RVRVVFUUNBQVFRSjBJZ0VnQlVHd0oycHFRWUIrUVFBZ0dLZEIvd0Z4SWdkQi93QkxHeUlJSUFkeU5nSUFJQWhCSDNhdElCaENDSWg4SWhoUURRTWdBU0FHYWlJQlFnQTNBZ0FnQVVFQU5nSVlJQUZDQURjQ0VDQUJRZ0EzQWdnZ0FFRUhhaUVBREFFTElBVkJzQ2RxSUFCQkFuUnFRUUEyQWdBZ0dFSUJpQ0VZQ3lBQVFRRnFJUUFnR0VJQVVnMEFDd3NDUUNBRktRTW9JaGhRRFFBZ0JVR2dKV3BCQkhJaEJrRUFJUUFEUUFKQUlCaENBWU5RUlFSQUlBQkJBblFpQVNBRlFhQWxhbXBCZ0g1QkFDQVlwMEgvQVhFaUIwSC9BRXNiSWdnZ0IzSTJBZ0FnQ0VFZmRxMGdHRUlJaUh3aUdGQU5BeUFCSUFacUlnRkNBRGNDQUNBQlFRQTJBaGdnQVVJQU53SVFJQUZDQURjQ0NDQUFRUWRxSVFBTUFRc2dCVUdnSldvZ0FFRUNkR3BCQURZQ0FDQVlRZ0dJSVJnTElBQkJBV29oQUNBWVFnQlNEUUFMQ3dKQUlBVXBBekFpR0ZBTkFDQUZRWkFqYWtFRWNpRUdRUUFoQUFOQUFrQWdHRUlCZzFCRkJFQWdBRUVDZENJQklBVkJrQ05xYWtHQWZrRUFJQmluUWY4QmNTSUhRZjhBU3hzaUNDQUhjallDQUNBSVFSOTJyU0FZUWdpSWZDSVlVQTBESUFFZ0Jtb2lBVUlBTndJQUlBRkJBRFlDR0NBQlFnQTNBaEFnQVVJQU53SUlJQUJCQjJvaEFBd0JDeUFGUVpBamFpQUFRUUowYWtFQU5nSUFJQmhDQVlnaEdBc2dBRUVCYWlFQUlCaENBRklOQUFzTEFrQWdCU2tET0NJWVVBMEFJQVZCZ0NGcVFRUnlJUVpCQUNFQUEwQUNRQ0FZUWdHRFVFVUVRQ0FBUVFKMElnRWdCVUdBSVdwcVFZQitRUUFnR0tkQi93RnhJZ2RCL3dCTEd5SUlJQWR5TmdJQUlBaEJIM2F0SUJoQ0NJaDhJaGhRRFFNZ0FTQUdhaUlCUWdBM0FnQWdBVUVBTmdJWUlBRkNBRGNDRUNBQlFnQTNBZ2dnQUVFSGFpRUFEQUVMSUFWQmdDRnFJQUJCQW5ScVFRQTJBZ0FnR0VJQmlDRVlDeUFBUVFGcUlRQWdHRUlBVWcwQUN3c0NRQ0FGS1FNQUloaFFEUUFnQlVId0htcEJCSEloQVVFQUlRQURRQUpBSUJoQ0FZTlFSUVJBSUFCQkFuUWlCaUFGUWZBZWFtcEJjRUVBSUJpblFROXhJZ2RCQjBzYklnZ2dCM0kyQWdBZ0NFRWZkcTBnR0VJRWlId2lHRkFOQXlBQklBWnFJZ1pDQURjQ0FDQUdRUUEyQWdnZ0FFRURhaUVBREFFTElBVkI4QjVxSUFCQkFuUnFRUUEyQWdBZ0dFSUJpQ0VZQ3lBQVFRRnFJUUFnR0VJQVVnMEFDd3NDUUNBRktRTUlJaGhRRFFBZ0JVSGdIR3BCQkhJaEFVRUFJUUFEUUFKQUlCaENBWU5RUlFSQUlBQkJBblFpQmlBRlFlQWNhbXBCY0VFQUlCaW5RUTl4SWdkQkIwc2JJZ2dnQjNJMkFnQWdDRUVmZHEwZ0dFSUVpSHdpR0ZBTkF5QUJJQVpxSWdaQ0FEY0NBQ0FHUVFBMkFnZ2dBRUVEYWlFQURBRUxJQVZCNEJ4cUlBQkJBblJxUVFBMkFnQWdHRUlCaUNFWUN5QUFRUUZxSVFBZ0dFSUFVZzBBQ3dzQ1FDQUZLUU1RSWhoUURRQWdCVUhRR21wQkJISWhBVUVBSVFBRFFBSkFJQmhDQVlOUVJRUkFJQUJCQW5RaUJpQUZRZEFhYW1wQmNFRUFJQmluUVE5eElnZEJCMHNiSWdnZ0IzSTJBZ0FnQ0VFZmRxMGdHRUlFaUh3aUdGQU5BeUFCSUFacUlnWkNBRGNDQUNBR1FRQTJBZ2dnQUVFRGFpRUFEQUVMSUFWQjBCcHFJQUJCQW5ScVFRQTJBZ0FnR0VJQmlDRVlDeUFBUVFGcUlRQWdHRUlBVWcwQUN3c0NRQ0FGS1FNWUloaFFEUUFnQlVIQUdHcEJCSEloQVVFQUlRQURRQUpBSUJoQ0FZTlFSUVJBSUFCQkFuUWlCaUFGUWNBWWFtcEJjRUVBSUJpblFROXhJZ2RCQjBzYklnZ2dCM0kyQWdBZ0NFRWZkcTBnR0VJRWlId2lHRkFOQXlBQklBWnFJZ1pDQURjQ0FDQUdRUUEyQWdnZ0FFRURhaUVBREFFTElBVkJ3QmhxSUFCQkFuUnFRUUEyQWdBZ0dFSUJpQ0VZQ3lBQVFRRnFJUUFnR0VJQVVnMEFDd3NnQlVIQUZtb2dCVUhBREdvUUp5QUZRYUFWYWlBRlFjQUlhaEFuSUFWQmdCUnFJQVZCd0FScUVDY2dCVUhnRW1vZ0JVRkFheEFuSUFWQjRCRnFJZ0JDQURjREFDQUZRZmdSYWtJQU53TUFJQVZCOEJGcVFnQTNBd0FnQlVIb0VXcENBRGNEQUNBRlFkZ1Jha0lBTndNQUlBVkIwQkZxUWdBM0F3QWdCVUdJRW1wQ0FEY0RBQ0FGUVpBU2FrSUFOd01BSUFWQm1CSnFRZ0EzQXdBZ0FFRUJOZ0lBSUFWQ0FEY0RnQklnQlVJQU53UElFU0FGUWdBM0E4QVJJQVZCQVRZQ2dCSkJ3QUFoQUFOQUlBVkJ3QkZxRUE4Q1FDQUFJZ0ZCQW5RaUJpQUZRZkFlYW1vb0FnQWlBRUVBU0FSQUlBVWdCVUhBREdwQkFDQUFhMEVDYlVFSGRHb2lBQ2dDQURZQzRCQWdCU0FBS1FJRU53TGtFQ0FGSUFBcEFndzNBdXdRSUFVZ0FDZ0NGRFlDOUJBZ0FDZ0NZQ0VISUFBb0FtUWhDQ0FBS0FKb0lRc2dBQ2dDYkNFTUlBQW9BbkFoRFNBQUtBSjBJUTRnQUNnQ2VDRVBJQUFvQW53aEVDQUZJQUFvQWhnMkF2Z1FJQVVnQUNnQ0hEWUMvQkFnQlNBQUtRTWdOd1BBRUNBRklBQXBBeWczQThnUUlBVWdBQ2tETURjRDBCQWdCU0FBS1FNNE53UFlFQ0FGSUFCQlFHc3BBd0EzQTRBUklBVWdBQ2tEU0RjRGlCRWdCU0FBS1FOUU53T1FFU0FGSUFBb0FsZzJBcGdSSUFBb0Fsd2hBQ0FGUWYvLy8vOEhJQkJyTmdLOEVTQUZJQTlCZjNNMkFyZ1JJQVVnRGtGL2N6WUN0QkVnQlNBTlFYOXpOZ0t3RVNBRlFmLy8vLzhISUF4ck5nS3NFU0FGSUF0QmYzTTJBcWdSSUFVZ0NFRi9jellDcEJFZ0JTQUhRWDl6TmdLZ0VTQUZJQUEyQXB3UklBVkJ3QkJxSUFWQndCRnFFQkVNQVFzZ0FFVU5BQ0FGUWNBTWFpQUFRUVowUVlCL2NXb2dCVUhBRVdvUUVRc0NRQ0FGUWVBY2FpQUdhaWdDQUNJQVFRQklCRUFnQlNBRlFjQUlha0VBSUFCclFRSnRRUWQwYWlJQUtBSUFOZ0xnRUNBRklBQXBBZ1EzQXVRUUlBVWdBQ2tDRERjQzdCQWdCU0FBS0FJVU5nTDBFQ0FBS0FKZ0lRY2dBQ2dDWkNFSUlBQW9BbWdoQ3lBQUtBSnNJUXdnQUNnQ2NDRU5JQUFvQW5RaERpQUFLQUo0SVE4Z0FDZ0NmQ0VRSUFVZ0FDZ0NHRFlDK0JBZ0JTQUFLQUljTmdMOEVDQUZJQUFwQXlBM0E4QVFJQVVnQUNrREtEY0R5QkFnQlNBQUtRTXdOd1BRRUNBRklBQXBBemczQTlnUUlBVWdBRUZBYXlrREFEY0RnQkVnQlNBQUtRTklOd09JRVNBRklBQXBBMUEzQTVBUklBVWdBQ2dDV0RZQ21CRWdBQ2dDWENFQUlBVkIvLy8vL3djZ0VHczJBcndSSUFVZ0QwRi9jellDdUJFZ0JTQU9RWDl6TmdLMEVTQUZJQTFCZjNNMkFyQVJJQVZCLy8vLy93Y2dER3MyQXF3UklBVWdDMEYvY3pZQ3FCRWdCU0FJUVg5ek5nS2tFU0FGSUFkQmYzTTJBcUFSSUFVZ0FEWUNuQkVnQlVIQUVHb2dCVUhBRVdvUUVRd0JDeUFBUlEwQUlBVkJ3QWhxSUFCQkJuUkJnSDl4YWlBRlFjQVJhaEFSQ3dKQUlBVkIwQnBxSUFacUtBSUFJZ0JCQUVnRVFDQUZJQVZCd0FScVFRQWdBR3RCQW0xQkIzUnFJZ0FvQWdBMkF1QVFJQVVnQUNrQ0JEY0M1QkFnQlNBQUtRSU1Od0xzRUNBRklBQW9BaFEyQXZRUUlBQW9BbUFoQnlBQUtBSmtJUWdnQUNnQ2FDRUxJQUFvQW13aERDQUFLQUp3SVEwZ0FDZ0NkQ0VPSUFBb0FuZ2hEeUFBS0FKOElSQWdCU0FBS0FJWU5nTDRFQ0FGSUFBb0FodzJBdndRSUFVZ0FDa0RJRGNEd0JBZ0JTQUFLUU1vTndQSUVDQUZJQUFwQXpBM0E5QVFJQVVnQUNrRE9EY0QyQkFnQlNBQVFVQnJLUU1BTndPQUVTQUZJQUFwQTBnM0E0Z1JJQVVnQUNrRFVEY0RrQkVnQlNBQUtBSllOZ0tZRVNBQUtBSmNJUUFnQlVILy8vLy9CeUFRYXpZQ3ZCRWdCU0FQUVg5ek5nSzRFU0FGSUE1QmYzTTJBclFSSUFVZ0RVRi9jellDc0JFZ0JVSC8vLy8vQnlBTWF6WUNyQkVnQlNBTFFYOXpOZ0tvRVNBRklBaEJmM00yQXFRUklBVWdCMEYvY3pZQ29CRWdCU0FBTmdLY0VTQUZRY0FRYWlBRlFjQVJhaEFSREFFTElBQkZEUUFnQlVIQUJHb2dBRUVHZEVHQWYzRnFJQVZCd0JGcUVCRUxBa0FnQlVIQUdHb2dCbW9vQWdBaUFFRUFTQVJBSUFVZ0JVRkFhMEVBSUFCclFRSnRRUWQwYWlJQUtBSUFOZ0xnRUNBRklBQXBBZ1EzQXVRUUlBVWdBQ2tDRERjQzdCQWdCU0FBS0FJVU5nTDBFQ0FBS0FKZ0lRY2dBQ2dDWkNFSUlBQW9BbWdoQ3lBQUtBSnNJUXdnQUNnQ2NDRU5JQUFvQW5RaERpQUFLQUo0SVE4Z0FDZ0NmQ0VRSUFVZ0FDZ0NHRFlDK0JBZ0JTQUFLQUljTmdMOEVDQUZJQUFwQXlBM0E4QVFJQVVnQUNrREtEY0R5QkFnQlNBQUtRTXdOd1BRRUNBRklBQXBBemczQTlnUUlBVWdBRUZBYXlrREFEY0RnQkVnQlNBQUtRTklOd09JRVNBRklBQXBBMUEzQTVBUklBVWdBQ2dDV0RZQ21CRWdBQ2dDWENFQUlBVkIvLy8vL3djZ0VHczJBcndSSUFVZ0QwRi9jellDdUJFZ0JTQU9RWDl6TmdLMEVTQUZJQTFCZjNNMkFyQVJJQVZCLy8vLy93Y2dER3MyQXF3UklBVWdDMEYvY3pZQ3FCRWdCU0FJUVg5ek5nS2tFU0FGSUFkQmYzTTJBcUFSSUFVZ0FEWUNuQkVnQlVIQUVHb2dCVUhBRVdvUUVRd0JDeUFBUlEwQUlBVkJRR3NnQUVFR2RFR0FmM0ZxSUFWQndCRnFFQkVMQWtBZ0JVR3dKMm9nQm1vb0FnQWlBRUVBU0FSQUlBVkJBQ0FBYTBFQ2JVSGdBR3hCZ01VQWFpSUFLUU1BTndPQUdDQUZJQUFwQXhnM0E1Z1lJQVVnQUNrREVEY0RrQmdnQlNBQUtRTUlOd09JR0NBRklBQXBBemczQS9nWElBVWdBQ2tETURjRDhCY2dCU0FBS1FNb053UG9GeUFGSUFBcEF5QTNBK0FYSUFWQi8vLy8vd2NnQUNnQ1hHczJBcndZSUFVZ0FDZ0NXRUYvY3pZQ3VCZ2dCU0FBS0FKVVFYOXpOZ0swR0NBRklBQW9BbEJCZjNNMkFyQVlJQVZCLy8vLy93Y2dBQ2dDVEdzMkFxd1lJQVVnQUNnQ1NFRi9jellDcUJnZ0JTQUFLQUpFUVg5ek5nS2tHQ0FGSUFCQlFHc29BZ0JCZjNNMkFxQVlJQVZCNEJkcUlBVkJ3QkZxRUFzTUFRc2dBRVVOQUNBQVFRRjJRZUFBYkVHQXhRQnFJQVZCd0JGcUVBc0xBa0FnQlVHZ0pXb2dCbW9vQWdBaUFFRUFTQVJBSUFWQkFDQUFhMEVDYlVIZ0FHeEJnTVVBYWlJQVFaZ3dhaWtEQURjRG1CZ2dCU0FBUVpBd2Fpa0RBRGNEa0JnZ0JTQUFRWWd3YWlrREFEY0RpQmdnQlNBQVFZQXdhaWtEQURjRGdCZ2dCU0FBUWJnd2Fpa0RBRGNEK0JjZ0JTQUFRYkF3YWlrREFEY0Q4QmNnQlNBQVFhZ3dhaWtEQURjRDZCY2dCU0FBUWFBd2Fpa0RBRGNENEJjZ0JVSC8vLy8vQnlBQVFkd3dhaWdDQUdzMkFyd1lJQVVnQUVIWU1Hb29BZ0JCZjNNMkFyZ1lJQVVnQUVIVU1Hb29BZ0JCZjNNMkFyUVlJQVVnQUVIUU1Hb29BZ0JCZjNNMkFyQVlJQVZCLy8vLy93Y2dBRUhNTUdvb0FnQnJOZ0tzR0NBRklBQkJ5REJxS0FJQVFYOXpOZ0tvR0NBRklBQkJ4REJxS0FJQVFYOXpOZ0trR0NBRklBQkJ3REJxS0FJQVFYOXpOZ0tnR0NBRlFlQVhhaUFGUWNBUmFoQUxEQUVMSUFCRkRRQWdBRUVCZGtIZ0FHeEJnUFVBYWlBRlFjQVJhaEFMQ3dKQUlBVkJrQ05xSUFacUtBSUFJZ0JCQUVnRVFDQUZRUUFnQUd0QkFtMUI0QUJzUVlERkFHb2lBRUdZNEFCcUtRTUFOd09ZR0NBRklBQkJrT0FBYWlrREFEY0RrQmdnQlNBQVFZamdBR29wQXdBM0E0Z1lJQVVnQUVHQTRBQnFLUU1BTndPQUdDQUZJQUJCdU9BQWFpa0RBRGNEK0JjZ0JTQUFRYkRnQUdvcEF3QTNBL0FYSUFVZ0FFR280QUJxS1FNQU53UG9GeUFGSUFCQm9PQUFhaWtEQURjRDRCY2dCVUgvLy8vL0J5QUFRZHpnQUdvb0FnQnJOZ0s4R0NBRklBQkIyT0FBYWlnQ0FFRi9jellDdUJnZ0JTQUFRZFRnQUdvb0FnQkJmM00yQXJRWUlBVWdBRUhRNEFCcUtBSUFRWDl6TmdLd0dDQUZRZi8vLy84SElBQkJ6T0FBYWlnQ0FHczJBcXdZSUFVZ0FFSEk0QUJxS0FJQVFYOXpOZ0tvR0NBRklBQkJ4T0FBYWlnQ0FFRi9jellDcEJnZ0JTQUFRY0RnQUdvb0FnQkJmM00yQXFBWUlBVkI0QmRxSUFWQndCRnFFQXNNQVFzZ0FFVU5BQ0FBUVFGMlFlQUFiRUdBcFFGcUlBVkJ3QkZxRUFzTEFrQWdCVUdBSVdvZ0Jtb29BZ0FpQUVFQVNBUkFJQVZCQUNBQWEwRUNiVUhnQUd4QmdNVUFhaUlBUVppUUFXb3BBd0EzQTVnWUlBVWdBRUdRa0FGcUtRTUFOd09RR0NBRklBQkJpSkFCYWlrREFEY0RpQmdnQlNBQVFZQ1FBV29wQXdBM0E0QVlJQVVnQUVHNGtBRnFLUU1BTndQNEZ5QUZJQUJCc0pBQmFpa0RBRGNEOEJjZ0JTQUFRYWlRQVdvcEF3QTNBK2dYSUFVZ0FFR2drQUZxS1FNQU53UGdGeUFGUWYvLy8vOEhJQUJCM0pBQmFpZ0NBR3MyQXJ3WUlBVWdBRUhZa0FGcUtBSUFRWDl6TmdLNEdDQUZJQUJCMUpBQmFpZ0NBRUYvY3pZQ3RCZ2dCU0FBUWRDUUFXb29BZ0JCZjNNMkFyQVlJQVZCLy8vLy93Y2dBRUhNa0FGcUtBSUFhellDckJnZ0JTQUFRY2lRQVdvb0FnQkJmM00yQXFnWUlBVWdBRUhFa0FGcUtBSUFRWDl6TmdLa0dDQUZJQUJCd0pBQmFpZ0NBRUYvY3pZQ29CZ2dCVUhnRjJvZ0JVSEFFV29RQ3d3QkN5QUFSUTBBSUFCQkFYWkI0QUJzUVlEVkFXb2dCVUhBRVdvUUN3c2dBVUVCYXlFQUlBRU5BQXNnQlVIQUVXb2dBaEF4Q3lBRlFjQXBhaVFBSUJKRkRRQWdDVUZBYXlJQUlBQVFJa0VCSVJFZ0NTZ0NRQ0FES0FJQVJ3MEFJQWtvQWtRZ0F5Z0NCRWNOQUNBSktBSklJQU1vQWdoSERRQWdDU2dDVENBREtBSU1SdzBBSUFrb0FsQWdBeWdDRUVjTkFDQUpLQUpVSUFNb0FoUkhEUUFnQ1NnQ1dDQURLQUlZUncwQUlBa29BbHdnQXlnQ0hFY05BQ0FFUVFFMkFnQUxJQW9RTFFzZ0NVR0FBV29rQUNBUkM0SUpBUWQvSXdCQmdBSnJJZ1lrQUFKQUlBQkJJQ0FHUVlBQmFrSEFBRUVBUVFBUUh3MEFJQU5CUUdzaUJSQThJZ3BGQkVCQkJTRUZEQUVMSUFwQklHb2lBQ0FHS1FPZ0FUY0RBQ0FLSUFZcEE3Z0JOd000SUFvZ0Jpa0RzQUUzQXpBZ0NpQUdLUU9vQVRjREtDQUtRVUJySUFJZ0F4QVlHZ0ovUVFBZ0FDQURRU0JxSUFaQlFHdEJJRUVBUVFBUUh3MEFHaUFHUVVCcklBWkJ3QUZxSWdJUUlDQUNJQVFRSWlBS0lBUXBBQUEzQUFBZ0NpQUVLUUFZTndBWUlBb2dCQ2tBRURjQUVDQUtJQVFwQUFnM0FBZ2dBQ0FCS1FBWU53QVlJQUFnQVNrQUVEY0FFQ0FBSUFFcEFBZzNBQWdnQUNBQktRQUFOd0FBUVFBZ0NpQUZJQVpCSUVFQVFRQVFIdzBBR2lBR1FVQnJJZ0VnQVJCSUlBWWdCaEJJSUFaQmdBRnFJQVJCSUdvaUFCQkNJQVlnQmhCQ0lBQWdCaUFBRUJzakFFRWdheUlDSkFBZ0FrSUFOd01ZSUFKQ0FEY0RFQ0FDUWdBM0F3QWdBa0lBTndNSUlBSkJBVFlDQUNBQUlBSWdBQkFiSUFKQklHb2tBQ0FBSUFFb0FnQWlBaUFBS0FJQUlnTnJJZ2MyQWdBZ0FDQUJLQUlFSWdRZ0FDZ0NCQ0lGYXlJSUlBSWdBeUFIY3lBQ0lBTnpjbk5CSDNZaUNXczJBZ1FnQUNBQktBSUlJZ0lnQUNnQ0NDSURheUlISUFrZ0NFVnhJQVFnQlNBSWN5QUVJQVZ6Y25OQkgzWnlJZ2xyTmdJSUlBQWdBU2dDRENJRUlBQW9BZ3dpQldzaUNDQUpJQWRGY1NBQ0lBTWdCM01nQWlBRGMzSnpRUjkyY2lJSmF6WUNEQ0FBSUFFb0FoQWlBaUFBS0FJUUlnTnJJZ2NnQ1NBSVJYRWdCQ0FGSUFoeklBUWdCWE55YzBFZmRuSWlDV3MyQWhBZ0FDQUJLQUlVSWdRZ0FDZ0NGQ0lGYXlJSUlBa2dCMFZ4SUFJZ0F5QUhjeUFDSUFOemNuTkJIM1p5SWd0cklnTTJBaFFnQUNBQktBSVlJZ0lnQUNnQ0dDSUhheUlKSUFzZ0NFVnhJQVFnQlNBSWN5QUVJQVZ6Y25OQkgzWnlJZ3RySWdRMkFoZ2dBQ0FCS0FJY0lnRWdBQ2dDSENJRmF5SUlJQXNnQ1VWeElBSWdCeUFKY3lBQ0lBZHpjbk5CSDNaeUlnZHJJZ2syQWh3Z0FDQUFLQUlBSWdKQkFDQUhJQWhGY1NBQklBVWdDSE1nQVNBRmMzSnpRUjkyY21zaUFVSG5tZHE3ZkhGcUlnVTJBZ0FnQUNBQUtBSUVJZ2dnQWlBRmN5QUJJQUp6Y2lBRmMwRWZkbW9pQWlBQlFZNm95ZjBDY1dvaUJUWUNCQ0FBSUFBb0FnZ2lCeUFDSUFWQmYzTnhJQWdnQWtGL2MzRnlRUjkyYWlJQ0lBRkJtZk85Y0hGcUlnVTJBZ2dnQUNBQUtBSU1JZ2dnQnlBQ1FYOXpjU0FDSUFWeklBRWdBbk55SUFWemNrRWZkbW9pQWlBQlFjMkE5UDE5Y1dvaUJUWUNEQ0FBSUFBb0FoQWlCeUFJSUFKQmYzTnhJQUlnQlhNZ0FTQUNjM0lnQlhOeVFSOTJhaUlDSUFGQjVhbnc1WGx4YWlJRk5nSVFJQUFnQXlBSElBSkJmM054SUFJZ0JYTWdBU0FDYzNJZ0JYTnlRUjkyYWlJQ0lBRkJncS9PZ245eGFpSUZOZ0lVSUFBZ0JDQURJQUpCZjNOeElBSWdCWE1nQVNBQ2MzSWdCWE55UVI5MmFpSUNJQUZCOHBUNDhnUnhhaUlETmdJWUlBQWdDU0FDSUFOQmYzTnhJQVFnQWtGL2MzRnlRUjkyYWlBQlFjR1hwd0Z4YWpZQ0hFRUJDeUVGSUFvUUxRc2dCa0dBQVdwQkVCQVRJQVpCUUd0QkVCQVRJQVpCZ0FKcUpBQWdCUXRQQVFKL0l3QkJnQUZySWdJa0FBSkFJQUJCSUNBQ1FTQkJBRUVBRUI4RVFDQUNRUkFRRXlBQlFRZ1FFd3dCQ3lBQ0lBSkJRR3NpQUJBZ0lBQWdBUkFpUVFFaEF3c2dBa0dBQVdva0FDQURDd3VRaVFJVUFFR0FDQXZCL1FIbmpIYkhEbFN5TDVsNUQvNU5BTDNmNVJTOG5JS1hVL0J5Q2w1T3djc3BBQ2s1dkhudzVTL2g4OXo4MGJoNFh0Y2gyN1YyN1Fua3ZIVEF3YS85QWlmeklkYnpYM200SGNoOU9HdnFxcVUrRnh6Mk5pSEh0d0U5MC9uSWF2R2xCZ0JDQVFBQUFBQUFBT1FBQUFBQUFBQUFqUXo4OFlnVWdyUDg0RmRtaEM5SFhqSG1BNmZ6TklyaFh5dFFIYjlnZENoVEEvbms5Mkl1NE42c2hvczNvRHNNM0g2VHNKZ1B2NUJWeGZBa2VId0xkR1lUb0NPUkl5R3pwVmVWT3JuMS9FKzdRdHFyeS94NktjYVhiRlUzMFVoWlRHZ3dNem1hR0tnbkh6UUtjaXV2REllSEdQMFlvSXM2cUJMZGlJRVNSbFYzbTUvQU04eXpzRWtnVGJqNDZxNGJBUG42RWFZbFpBQ0o5NmJoRXMzM0dHWmdWUkthOE14dDY3Ym5yTzRGamtTd0tTaWRhRE12djdTOVZ5bkxIWkZ0N2dNODNOdFRJNThCNWI2NkJVUEZCaVdocnoxeFJhOHVUVGFLWkZnd2xuTHlQakdkSDNlM1lXbXc0ci80eDBGUHJKQ1hXYTRqaGtCQ0NqTkVob1V6VFlkMDNaeGtsbGI4Rk9HWTVlQnkzM1FMRVR5UkpXT2d5ZGl3NUY4UjFHc0gyZk8vMW1XZVlYWUlPdTU4RkVDU0pITmFsa2hodVpYV0J2Y3BpS0xJcWloN3BmY3BVOER4UVE3Z0E1L29xUnhFSGlUM2k2czRxdUgwdHpMSXI0enlXTVlBVlBxNCtOcktQb1pPS0FiUnRqU1hVUEU2cTR4SjlVbWNmUUdRZDc1dHZPaElGS2gydjJNRzREcnlXNUp4WS9xQjdiMGh4K0xGcTFhQTF1NXczazRRV0plMHRkazhqNmlhQ2k4Wi9WSkhGRVJ6SCt1VWh6Rmloa2JJMHZmZEVVNmpzWEp2c0JNbWNHZXdlck4xVlVZcmpXT0NYNFM1UU02WUFubFFRSWxJTWZHMEFhV1QyNzc3c29rb0RWYnpCSXNuV3hGMTJIMUZpb1dTVGVWZThsWitsd3pPemNIVWtwWkoxNGRCeW84SG9TTE1kdTB0dXp2Mks5dzloU2g3RWFLNndybDhkdk5EajRycTRDV2VCM050ZVJWYUs1bDNBWkx2MllBVWNuY3VGaWszWnpXSUNiNXRWL2Q2YXhlUEpSczVhR0g5T0lNd3BGTnptbCtTaFhJVVVlaFAwQThzaGxIck9rTG5uaVZUYUJvN1M2Z3hBUDc4Y2FBZlpoMVBHcWNveVkwV1ZOMHRhbW9aM3hwY0dHQzBxVzNjRjVlQVNRUDh6MDFMQ1dKZ2pYNzZCZnFtSHFTZ1NIRW5iK0JQU3ZDQW51NnBVN0o3TXhleHpJdVNta0dlQTVwcTVqc3loTHNVS0pldTBiSUJNUklGMDRTRldLZlhuWmZNSUI3ZlZOMGlMejcrQnRtUkR4cmZYNWZwTms0MGRuUnJkSEVZMkRNMDRlNjZNVjQrbzdwemxaZUEydVRHZC81ODJTcUZTNTZMUVJSbk5JdmdpTy9tTDV0eFBTZ0xHRnprTFowenQ4alYwaEh2L0t4MWRoaFdqSHAzUUk5TFRCT25RS3hVREFqdXVtWjlLQzY1djRpaEJsQitOVzl4YVI3dEdUT1F4VUQ5MnBIdlJYeDBib0V2SGFtR1FONTk3N096N1NmTFhlN1NIZnBzeFAxRG1HU1djSjhmVlZIY20rMWg5elJGdFgrd1B3ZXpWVFJGQzdmS2crTnpSL0xmOUl4MVh1S2JaeW51UHBUeTdSZmFaZy9jMXJqbHlUMWJ0ejlCdWd5bFZuOVRxTVZiTVdVZUUzSXNnRUlDK1Y4dUpTWDB5TmpKYzQrTUdUT0dlMk04TTA5QjdiT0VUMU1DYWQzZWNqNHhyYTh6M3h5VWZ0VmViakJYS2gzZ2IxcjVFMGMwNmoyMmMvTXJIQTlYY01zNTJ4Z2FuK1RHK0Mza2wzZG5TY01iWm1LUXZyN0w1eHBRUTVhVjZJMm9VbHRSSGNBUktIVnlBeWk1R3pDaVZ3d0J4azlWVlhFeGl6ZnhMS0FwUXZxRCtDbmIxMUM0UndCZnFpMUFLT042SkUyOG9sQ29Kd1lERGZWRHBJaWFYZWEwaWJCdExXdG95VzZIMmFIK0NDNGczZ0IyamZMVDRXUmN0NzloOXI0WGZSVk1NM1hkTmkwNVZsd1ZHYjNZZUZUaS9Xb3pQUzFQYlJUb0ZVNzVDK0Q3bThBUTMycWFXaGdyZTZ0UzdiTW5aWktBSGhCekZINlpaMEhGZkpUMFQ0KzFlcHJKK3NjQStEYlpWZ1JBTWk0dzBIdHB2RUEyNUhKRG1OaFFSN3ZLUkpHL1BLTEorbHJTZGY3TFZYWjJrVVY1QjB2OEYyWWgyM1RKMEdZbEpMSlhjQ043UVFoWk8xUWRnNGRDUkxTQXdobnZ3MnlML1Frak5YS3VhTUJxUFlNMzlCbkFJeHBud0U2MVc5Q2o0VGFZbmVQdkpQTGZHdjVFU3Z0KzVUeThscUpRUWFFMWFNaitMc3BMR2ZzSm5PRXZCdEk4bGRNSHpCamd1Y0RKRi9MZlcrNjhHbGhXcHhwbm90SDNLSzR6ek9IK282QTNTU1Z2RzRPN3VtVVdQVkJSRVpLSTFUWld1WFJwK0picTVIcTV2YjBRSlo0WXpnY1ZFenU1K2xSTmJua3BDWllGWDNhQmF1MHpxT1VoQlpRdVJQWkZzaktsM2p1VEp0WC9kV21udnRaT2JicElTTGxreHo3amxBRXR0WjBsbjJOVjJtWFBjVGlCV3RzZk8rZnRJdHhpYkR2UjVCSVhWUmhsd3JBWm5kRDl0VmZTRWFCMzVJVE5yc3JGN1IvUmtqUWVGVTZFUnQ4Z1FwQXhPa0o2bWZEb1I4ZGxNVnN1NGpYZjZsNW1IRnRaUmZ4V3RRSjQzdEpiQWZUZW9vV3RabkdWaDZ2eUYrWEJZQ0ExYmM4WmFvNUF2dEY2S2hKbTkxdGt5THQ1VzgvYUNrMmRBUHNnT0lXaUt5ZHFVcGZlQzBJTjZiUkJjRmV3MmxnekVUQTdRMExTOEdhTE9UMElSODBEbXBtbGtaYUFrODBKSks0ZWpCQTJUR0JyM1dab0dRaUpOd2dURi8zY0pYR1Ixc3BYeXZFRWw3aHNzRFR5cXpVZjUraXYzTGxOVkkwWk1ZTnBXd2V2UTJabmgySnRLNTFWNVZBSklIU1EzZXpEUC9iVW9oT3NRbkV4YzNSV2t6RUZDQU93bHJwNFF5VGcveUFzR3NCcTBocFJpVWoyL0plWklTZmpUdXI0Q3cvbjV2OFYxNmJRcHJSL1lXc2tjeS9Gb2R3V1NYZUNSb2J3YVlJOFMrQTN5TVFRUXNJc1ZGcVJUd3RJVGw3amY1cXc4LzdGc29UOVJONEJwVEc1QjZSQVNaN3llYXZsektVODRLY0w2dGgwaWdXeXFLZmMyaVlPZ2NmMFJvb1NvWlRPR2hkR0VhaVZWQUpWMjBSY2pmRkxHcDZJZjdJRzgwTXFGMDlOcmY4Y3UyYVhxVFBLbXRNa1dYZFVZbTRUSmNJT0kxWFlIU0haZU5CTlZCeTZZei8yYVpuK0VvTFRuWlRjOFpvR1ZzTGx6MERQV3pDVnRidExrcEN1WXdiZXQ1TjNDVkhrUGdUQW4vTU1lQWx4aUhucjUvaDZnamQ2VjNkc2lzNDZ1bFhnTWhNRzMza3JxYzZxZXNBZFZuTW1EWUxaSWtSK1NGT3Y0SVBmaFd0clV0amV3Um9WSDcxQ2NSWGwyT28xMUozSE0yenZwbTNrL1pRbFRhQXVYL3JWSjhBTWZRT1JHek93QnhCQXRWT2pwVXM5aWhrUGdaVkJxWnNsdldORW5zOHE3S3lVdURMT1NVUFdZUmR4ZUJIaUgvV3o0VG9sWTJSYlV6OUxua0RlU1Y3YUVHMGpPbW96SVp3Q3NkSVprTjJxTmdUME5TZ1pDeGtGRmFOQ0NYbUNnbllZRTRuQm5CK095c09XL2pxVEJpT1J0QUVZbjVIUVgySzRqZUk1amt6VVhUVlFxNThOS0p0eTJsVlJGTlYyVFIwUStNelRhR3dyakJxcUQxcUs2bFRMaEd6R1BIUEhadlhqTEFWUjlaK3VaZDRVN2pzazhNd0JpaEdHZFY3eGE0a2NlWjRJMXBNZEppMEMvelg1SEgyUFBlRTh6ZmE0dDVXUDZSMVB0RUhjWWlTSzVsRXAzZllqUEo2dFlWSGI2NEJrNms5WTgreWRQd2YrVWwzVk52T3RQa2orbW1wcHNZREpBL29kR1pxQi8wYzk5MVh0QUJFMlhmVjdhUm1VT1VaRWdOVGVueVhPZjBhVWpHRU05WTd3OFg5WjhzQXoyWTI1TmNrSDl0WGVlTHlNZGJ1UEZCT3ZCZzJhSHR2VVRIOUY0WnlIbEVrdGxxRnNPU2pEQlhiRlBWb0o5YkVueGFROUQxY2VoMWVUQkRtYTlpck9ITkQ5ZHVNZVdUT0d2SWpmV0h2MzBaWHpzbEhXWkZTdWhwb2Vhd204cnloclcvWkwzK0pzQ0Q2ZExvMkNPanZRWmkyTkhRR0NZejBaUFUybWZKaVVyMVp0T3czMzNWQ3BGYTNJZlBaZGpaSWZXN3lZZ0NBNSs2VFYzeUQxbWM2cGUycTRoN3c3TW9uSEE5aW9pRC9oVlFBZzhyM2MvMVl0eHlRYm93My9PaFlNREVabUZRRndFMnJFT3ZXMzkzYkNld2UzL3BzR0hEWThTcUU4R1VlUFBkNkk4RXJqYzIwMFpuMHgyU3RMWThnZWY3YzRSMEJiSGN1aEhMZXJUL05HYWxUS3lydEtCV0NtN1FqZHlzM284ZDZMbGIrcmNXbXZUdHZkVjRVelFYeTJlYkNGaFJVZWFHQ2l6M1FFSjlKcHBNNnpNbTJ6VXdnOVZHekJJeFVCVGpGelh5enBhRWJSckJkQnZqN3Z1aHFURTZjYWZRTUVqY2FRNCtRWTRXaDFGVXlrVmMyQWF6TEFLVmVLNmdkenNwcnA3bDlIeFZ4MXJCUk1RZzVGTk5qY3MxMStGUWsvVW9CWVVCc3J6bUtQTDJWT3habW9KKzJsd2krZkE4MEs3RDZCMWQxRVFFdFlXYWVRbmhoTndLRXpIZWU4VVNVa0JYLzRVV3Y1V3RrVjJBbjRJSWlZQXNXRGxEdjNaWCt5UTBzMjlFVUg5aTY1dUU4L3liMW15NHE3Vm9lMHlZWXJvV2VZbStEYTYvaXE2VzlPR0hBZVJJa1N6REFEVThMOWttbE5pMXJXMkVlK2RLNHcrcllEak5XWnZjTThhYWdjcHZJWUVGR3hubW4xLy9UWlpFZWdQVm1yT2oxRElCYzIvMWU0TEdFUnFTK3NIQzhNb1gwRnBCbkdwVE81R2FKSXhRdGYwU0FRTkVLdG5hQkdVSW40YzdnaGRNWVNVNjBiTG1LT05odDNsRUgvRFU3a2VSckhqTUx4WjFUa1pFVkxreURscjJyeFdYZXB2bC9YM0hFYk9aajNUcXVVQmh3cURSTkVWRlNITUFLaEdxclAvK0Y2UytkaE05Y3liK0prdVZRTHZUaHdwSTBWN3V6cWIvcU1GRDNNd25uVTFGWTMza01WMDZoTzFDVkRMTHNtNzRzczJIL3pKejBEUnlBc1lOTGFONWc5MDF0OU96aWpGekdVZC9LRHBYNXBIUWNTOGxzaUtpZEJmRHpUT3ZEeCtyM3JrZ1EzdG1nTUEyRmQwWFh1dWxNb2JzbzJOaHAzTkV0QUVrOStaaVpqeEJPK3NPT2JiNUZoMGl1SkQ4aXR5L2pqaGtqTGxCZUtEVkowZnZsTUFrWEhGUjRDNjFNZUhuVHVYS0hObWEvZ2pRaU5MSWJBSEpZU1dHSTA2Y0FoYzBNVFE2VDNKTVJveDd0Z1ErRVFQTDhmcDZ1NEZha1VuK3E0Ti84VEFzUmw3SmFOWElSMy95aUlvSFNqQi9iYWxISGJ2Z2FISEJaeFp1Z1h6MWxBVXVDWTY2d0piNUdVeENwVmFFYzhHNjhibDlKTWNCdmkzYnd1UkdpVmRZWU9qSnRpR1hxa1gyUFRWV2xxclpQajh1QkZxMi9FVVBEODlEN2RadkY5M1AyOGVndTduTThMRzNWYjZ4UWRRZjJpbkovM0hBcGc4UDl6YjBsY2NHMUNWWVdOWkVtcDJDSWphZ0hCUms5dG13MkgyMysxTTdiZENWSzJubURGZ3R5K1pwRVA1eWV2cjhpMXRTOTNJSG9pc05tVW9ubU52QzBSUWJGMWZ5QUFCNDc0eDlHWXNSZUN4S3JRVTFuL00xL2g2MU9DNGtWTVlSN0JIWDBtUmlLZXVRcjFaTDZWVlA2Q1hLdXFUdEMrWUg3QVduMlNUUnVxNW0xNDAyZEZLVzRQdjJJWnA1dnFYcU5FT05sanJFQm0wc2NvUXJPaDlTanIwamljRmlMY09UU3pjbmxMRkI2cXpWZUVSM0hIV0Izc0plRW1VdkhVaitlV2g1MW1mNkJFcXFyUkRYWFB2dXRhdFdKOE1pVzlUN1dWam1zQVRqYnJBVjM1c3lxVzRkWEFnRkMrL0NYblYxclhteHNxWFpzVFdHY3JLeDF6ZXB1RXIvUWNkYVVBZlRNdWZVb1d2S1NEeTZUanpnRDVLTDV0TnVDWU5BS0Ywa2lSaVQwRmFmdXd5bVJkWmdGMGp0WUlJaE9aU2wyUlA3M1V1MFM2dXlJaEYvbXdOQjN6cWVncHgwMFJYV0JMTTlVOXBPY0k2UFB3TXBLTzJ5aGlUeWFBRzc2M1hDT1BVSUtIeC9LYXNxSGo5OHpuYWpPK2xORXQ3dFRpZjNKb2lpc2JMajFYTnVxeVl6UHFNak5EUWg5Yk44RUxJQTBtc3dhTWZNUmxYbHlaVThvZkFrSkdtYkdiOUd4K0x5eHRHU05xdWg4eERkZmdLN1lURE1QY3NCRW5GS3p1WWRRMWZWbVdhVktJMXlHOTVzdWJGbkFRcFNtdDBMTHhvRTI1d1hJVVU5NHE1M09ZR053ZzR4RTQyMXpvbEJjcUxlTWg5cVpUeEtpZzkvWWxSYlhWQmtzYzdFZ1lhUllwOURDSFYxMVZGa0lkVGxzS0thY054dmhmVnZPaE9aL2RacUIwdERmWktheFY1SjQyU25xV2tVS0p2T1lTcXF5TmtSRERVUWFRNkVZOXNaQU9vREJVQmE4NXlxVnQ5U3YyRnVaUmpFZ3pIQUlhMWJ6N1k5L2FaQTE4NnIrZDVld1lDVG9nZE4zWEdUTTdES21maTF0VWlCM21XWXlRM0pLM0Uza0pQWnlha3kwS0ovRkx0NzVkR2pKd2hHMzIvMGRaWHBtOEp2M0tudXdpTmdXeGs0TEtGOTVHMkoxVndGWS9XU05RU0hVek4wZ1JISXRFOS8yd3hpTlBnQ2VLUlFSNU4zRHFKaWVXa1Q1WGNLdzFNayt5NFRWZStQUkpJQWk2VVpSeDFHQ0JrY1JMM2VFSU14NmlLVjB6VG00K1M0a1ZmdnZRTVU4dnZkdFEzc21wTmRLTEpPOFFSMk1iMHEwWU5OSTdObEk2SThlV244a0ltcTBVaEh4Y3dPWlVTc3RxdkpwWGt4RWFBaWxYSFBvSUMrRERKd1p6S256aCtVOExQWDh4a0ZsMTZBZlZTUDU3dkxON3NuWDFVZVpzTEErb1JFWnVjQnY4bFpkN1FLYjUvZDViNTUybytyKzZDdVd0ZGFDSkNJY1dzUXJPYk94WjNmemNQVzkwQnQ2SU5ZTTJibk9nS09vcEVSMHBZVTJJWkRqbHVQaDJUWVd1OGZodWNHa3dkWU5sakhvVFp2a2d4aHhmNUFHNngzWXYrQitPNGxTYzZPT3NudEkyeTBrTGZ4V2ZONE0zdWF3cm5zUHBaVDdhREFkRlBES2I1UzErcXpFdjRCYTNJbEZqUnZPOFV3bmV3dFlINHRjZnJGY2U2cFJmWHpyZnRQRFE2QWE2REpMRHFZZkRRTFJ3QU5qaDNrUEJmUjRya1RseWJicVlWQlF0R0JlZ2NDZ3pUSGt0Wi93RzQydE9LMXNrRWVJc0xKK25LNDBzY3BzUWVuSmZuUG9naFNidWVQNGtCVEJiVVppbXJzdnNBV0p6ZUw4UU1oR3NDRVpER0VTY2tmM1lNdGp5dUFRYmZsWEpXWFRjbVBjM1ZIZjFGNlJiV1BVQUVnVFRlajVmN0FBdWlHSkVLMTg5aC96a2RraGlrd29uTWlLYmVBaDhwRWJHdmhaV2t2N1pjQ1BFY2VZWk52b0tRN0pmSDZ6T2FHUVZOWFpCOHNMZWhEdVA1Y0FYa0E0VU1mcERkTXVNK0lWY3JHVFlaRjFmcHcyRSs3QnhTUFJmS2NNMk02MEw0WGticzNjcDNVS1ozLzhqR3BvUGpSa2JURTZHRXNFa2luZTYwRWh0OHBkbzluUVJ0bnFHYnNEVlA3bDRlUDh6enBoTFpaSExkYzVOMi9kalVleVpvRnBtRWJrWWNhNFdqMGtxbWxEcnROdkRYaWFHTE01b0JpT2tQWVV6NDdLcUsrWTJlRVNyZVVwOVVKbDFpQjVCL0xLL0plRXNBalBKSHF6WFpnUTlBNjVCMHlNQXZHTHBaYlNWMG9BeDE2SWJJZEFqVFMyUy8zck5QS0FVRlREZVNIRjJIcXZ2bEtnMnEwSENXQjc4US9QQ254eUhldElyVnBZN3loVnczWVVpUG1KVElKUWhIUEFSZEZYNVFtc0pkMVVtR1M5Wkl4dVVMVEhUQmh6Rnc2R3BxVEI1ajI3cXM3Q0pQYko4eDhVZGRhdCtObTdmNW9heHFjQ1VWaFUvV0UyRVQvcmZreWNqR0pCQlRZWFRhd3RFM1NveWJ0OHg4WUJVMVJmazQycUU0NHd4OUlRSkdpMEdaUVgyK2IvU1kreTZicENYNXlublh3ZDM1NlRJSkVaRDJRMWlzS25mNGhHUHYyU3o2RjRsMkJjYlJHTXM5d3dWd21MYzZJSFFnR2dRS01HUjdOOE5yNlQwTGg5K2wyd09qeHB2TWJrNHA2T25jdXdpVG94eUZqY3lPNitrV3dacFFNRm4weEdKSkJRVkNEZkR0cWo2U3IxUjV3QTBVWnQ2NTFCSUpZSXFHd1hBUnZ6Y1hocmtoa2dDZjhIS1Fmb09hNkIxVnB3YnNEQnFNeVoyQ2NvUUxQdDBnUW5wU0twTUlDdDBlNkc1VXNrQ2FUc3dJcm0yNmNJNUdYUlpQSnRySWJsMlgvRmtBcE9TYlNjVXJ1N1ZseEo3QjlNYi9xMUVCdytkcU9aYkpuNjFNeEJzTlRQbG9pOG9MSGZjWVZ5WkF6cjF6ejJKWG85ZFR6OENTUHgra3Z4THJvV20xa0VpYjFtaXVDbnNyK0N6UEVJNFpSQU5qZ0V4SmxaWFJPa1AwQzhSNElKSmNOaEJFcWVCWjA1bVZnMlh6dUk5RDUzMEJSdG1mbkZqMy8rVXFaaU9xR3VuZEdOQm1sZnhVKzBzQ0l0THF0SzEraDE0VmhpelpSajkzbEdCOTRGZ0RZU2JabVJPNFRoZnUvUTI1RUJMbHdwQk9OUkRBcjVtMXJQT01saU9ndUVhbm4wMEJvYnE0emtiUjNscDVGcEx5MkhQOGl6a2JscmE2aW1ydDJoWHlwcXlYT2NTL0I4TjB3a1JXK1phRGpKcnpiNzVjZG51UjJZQ2lZTGNqMFdsREFVdDFqSGx3VlE2VXI4cjZwRlU3dU81OEN0Z1M2MkFJMkp6cWlWWVg5OXhNaDVyS3cxSG9Hclk3OFhiU3pYRXVDUThOUVhLYStEMVBOdkhvL2VsVGl1UEhJb29vWHpPRWw0dkZkWjlQR2MydE1IVVdaWExIMUpPVlFJZVFOUUtKQStZMDJiUjJhUTVhMi94cTJJdlRLa2NOZXAvdW1PUk9QTzJZajNxbFhndVQ3VEdEMm5HcDgwRFJNYlZrekZnRGdtWlFDNHZUUG9Wcnc5Y216bTJFbzZkWENsR0d6TmJPdGF0NUZ4NVdFeHNjNzJuWC9LdTBVY1VSN05IT1ZjeUloeE1BQ2laVWp5YWZVT0kxZWduelJJWW5MRXFBbmdEZ1BZQTV6bzJLMElMZ0dQUkdqa2h2UG8yNzdkRkhiM2NJZi9ldkVSN0hPRnhJZHJHUVJUTXhQZDU3alVzU1RqQldTZVVVa2dLQmI0UWI5S1NaTm53VUl5WVR2V21HeGhpM2JheUxXcWpWMTRxYTREWjl5QTlwVHZiYTFKWFVPWUE5YkZzemhkRjgvaENzRUhZQlhEcGpXbHNDb0NxanN2aXExbTE5QVNkNUp3bDE5OVF3RFc1VGZtOU9UZ2hCR0l3VllZbGNiTmFjUGtaaXpzeWZSakd0aFlyVU5RbVcxbUpxbWx3Y1hseUdMUnQ0OEJuK05EaGRtellBZFlUZzNNYk13MkwvQzExZ0M3azgzSlVHS0RyRUN2bkU3MEZsWnYza0hRNG1sRUFKYTNUc3NFSmpUUDM4Q3hkcEYwRWJFSmlhSldCQVdRSkcvNmI5VmVOY29YRm9vMkhuNm41RUU3Y1lSNkR4RS9nVHpsVXpBTEdiYTdvNldkclZvUUVtNENUU2tmdy9NVzc0dk5ZT3NMQWNVTnMvamErK2dDMHA4RGtyajR2VEdIQnh1SFFnS2tRZHN4ZGlJaDhHZWdjSzh2Q09wOGMzdW9lTkMrdmU5QWFSeHNTQVd0OGczcldXY3RaSHloa2ppcktZakl2NUFIblVvQUY1ZXg5b3VBWnJLYTlweGNjYWJYeThaMGJNVXhJUStwSnJwdFVWWUdtNWZvbG90M0Zva1B2RG5EdEtwbGUrbGFJa1NOV0g1RllxVTJNNUtHQmkyUzl3OUM5RE9QbVptc21uUmFjSUxyemhYWkVNR0tvOXlBdVBRd2FxbHE3MGZFUkVUMkVLV3cyRTVETUxXU0x4d2I3NHduaFpFcElKMlIwWjZTOHJJNlB3VXpDSFJ1emJBdWdENCtKVDhocDM2THlJRWwwSnRRdGFWeE1mUmtxa2NEVzJKaHFmOTZhU0NnK0lILzBhWWRGbDZ3Ri9DTkJUeEpuZlcydDlEYTVPL2dQOE5UK1ZBa3pydzc1UmdCbHpzSzkzdm5VWWtmNWU0UDdiVmdxRjVNdWxqMFJ0R0pnZWp5VERYOFVsd1BiWFRTUWc4WnZXZU1JK3B0alovOW5UamN5Z29nWklSd0NHZnBlMWYwRVhTOEFvN3JoZWVER3RBVk15SFN0bzQ1bjVYMm5XR3FDOTBJY3pmckswb3RtVk9BY0p1VHQwMmgySXpLN3JuUmphdlR0OUE3UE1WbU03REVsV0Z2RGxTNWNsUU9XSldqcXNOZ253QjU5UW02WHFMY1R2Vkp4d01Wc2E4MUVzcUFNajlnRGw5aitqSnF1SEFEOXA1UDJvYk5FcUpic3ZYckxtbXhuTTczTjROVnJHMk80MmQwTTNJbnlLZjh1K3paMTFVY0pXYkErRG1YT3NoNEY5SXNPcExNNUlZMnU5RG43N1dWQnB0WndlcWJ0WWVEMmhKQ01Nc0E4TGo4R1Z0Q2VNdmdlMWJQb1NjNEJUVzFMMDFZV0w4a1FBZUFwQ0JkT0hLMXR2bmUwa01WV1RGZzE2U1hWQ2w5K1dXM1R0NDVOSmdoZ25vS2NtVlJuV0Q4ZGFsVDFuYWgrUFdSRFA1cDlUM1ZCcDNuNExvS1dCenR5S0NhWWxYZXlHaU41Nzd2d3lUZmNsNkExN0JqSWJpVkdXTjBKWE5weVNselV5dTFoYk45UkdlaGN6ODFQOHE3eGllYWFsYnVtQzU0NmU2Vmx2V2ZtU282S29wSFYvM0hmK3FkVCtpWERCaFBQTFd1WThtZG01QWtxMWFaUjl6NUt4N2hBUWhCNlVmV0RnWXo5M1l6UThVZUJHOGQ4STFreldUbUkwVS81LzJmdkVDMVp6SXBUSGV2d2J6ak9VYXhsL3NVVWdTdlVhYm5vdjVVNTJuNmhRYU1GMzQvWnhsMTR2dWhjTjAwdzhzcUR4T3doaGJVeEtpS0FCeFRZMGdUSmxlM2pLNHZCUFNzTjEvSTVGbzZrMERnUHZLWlUvVTg3RkxlbVc4YmppcDM2ZUpFZnRDNUlIVSt0aDA2TEN5UkE2MWtBUWpLRmJUSlJKMFIrOXpYQlNlT3FEV29IWVdKY2RrSTQyMnN4TlpMOWl6cTZaV0VrZFhvWDFVdDNMUnkyNDBjV21TOWFCS2h4UmxraldUdnR0VTNOV3RyNkZBVVA5YUJZdzM4cDZKRXFsZkxjdXRKOFpzS2E2akJScEExNXlSUWVQTlNnSnBDamsvNHB0Mks3eTN6Mjk2OVhBemJvV1h3Y1hZUFVPZ3RIK29iOXJ3MVhscjJqajJtK3hOZjhiOWNxN0wza0YxSGMxK3FwVHM1RGpsRksxdUI2dWxoVkJXaGtmc3dVNExnd0pzNVR5YXNEVjc2WmR3eGlHS05TcVUzb29vOGxLLzB2T3diRi9ZamRWcVU2bXRjZE54ZVpFcGg0ZFlON2tpMnJrQjBRVWtWVjBFdmxqQ0VHVTdRMVl0di9aWnNRV1JXbGdLSEU0R09HOUFSbUhPUi9Sa0Y0T0xmY3BCb3NyaGQxd01ZQ3k5TVo4VVZuNnBkOEZLbzh4TW94R3NmYWNQcDkrR3JDUGlHNUpYc085dWtvOG1mZjg0MzNqSnUxdjZOdkphU1NkMmcyUkhVWEl4OWN2dUdRSEV0a0c1NXFlRnQveXBOejlISkJXZXVxdUxSYnJtSnZHMlA2TWNUWnZHM015ZTJ5SUw0ZmhlQU92SitDM1Y5WjNjV3RGZE1kSkxiYjl5WFdpTGEwMU5LKzVmNkNXbGtOaUJITTREcGxhWFl2UVB6K2haNHJnUXAzQjdXVkpMc3hSN05mVnd6U0JiSmFTRFkwWXA2ZHUvN3paWllxQVNmM1Q4Q0U5UDVzV0w2LzZzQU1ocVZFZ0M1VDgrTG12Mi8rSURLdnV1cXJCWGlXZ012eUllMGIwdjdxdHhJaHBpb0xHUkQyZklPWTR2aFlrZSs4KzhnZWEyLzVwRHFiL2g3ekRvc0dLb1E3YXZjbitOZDhTOTJTbHh6OTg3dDFVV0NZYlIrY1FiYWJFeEN6alpmcHNqbzZDOTNWeVVGWnljWGd2TElsWU1mR05DYUJ1MGxhRVVRTkdmYmFFZXZMSW5hdDlVNFdrLzliZUYyMFhEVjlaSkZ4WEc3T1RGd2xmeEUrcnBvT2kwUWJXQlJVSWpiTDg2UlVoVWE4T2NXQUFYbHZ1Y2EzUTBBR1J3c0JMRHBiejh4RE1UZE13YS96K3gxMEpWZVZNWTgySEZvTEI3WFRMcndBWUgrelk5M1lNZ1B3Mkp1TWtMRkVCODY1ckkxaWppVXRGQjdHdWIyMHBidVc2VFJhS1JMS0M5UjFJVy9HaEp3RmVMNlFoMFB0T3hxd3RhdDlWMDg1MytRelBEdm1kMGN3YWxvczZFK2RvbG1rZDQ3bzBTSGtjbGtwTVJNREkrWnB1THZ5akswNm9DMjJzT3lQWU5oWUtLWkRBcVRubVRBMFk0K2EwblcyS2JxR1dQSDJwQ2dnUFFwOUJJYlM0bWp3SUE1M2JGMmJtUlI1Mm9ValdVcUgwZGtjV3NGU3RhNTRic0RwSTh6TUxVaEZWMHUxbjZFWWV3WjZtdjV1aVd3REV4eUgwZUFzTEMvSGtsVFducHN0TzNmUUdRamx4MGtHeStObGUrcG1xODAvOEtyRVFGdXhTVEhtQTZmek5JcmhYeXRRSGI5Z2RDaFRBL25rOTJJdTRONnNob3Mzb0RzTTNINlRzSmdQdjVCVnhmQWtlSHdMZEdZVG9DT1JJeUd6cFZlVk9ybjEvRSs3UXRxcnkveDZLY2FYYkZVMzBVaFpUR2d3TXptYUdLZ25IelFLY2l1dkRNUm96MXV4VmllSnVpYWxtSHozUWxlYm4vanBIVm9LTlBmUWRlNEthTzhVSDZSRFFPRnc1NFNWUE1NV0VjUVNBdUxBVGQ3bWtiYzFLRjJOVVFqZlNWbmJFTzFFQnhJT2F0T1JRNFRPZzFGYVVMcjlpaFdMWVcrSUlBNUhmZ1BpTER5NlpKb1Ura2tmVVFSbkdkVjJtRjlyV0ZWdkJRVUJBeWJYajMxVkdnOEN5SVp0c0hXeFROK1FnK1YvdnJ4UGFXY2JhblZLS1RONTdQaFlTNUxwMndtMmwvSE5BMFFQV2FjTGVzaWZsZ2NjWnlNbEVuZEhsc1NXc1BFaVlKY0lWWFVYTGtVZU50cnYrempJck13TUNucGYzT1VMSEhsK3NKUEx5eGkwdHRra0EzNFJ4dk53ZVVtVjFaYkxXS0dHT1N0aGt1WnNXSUNQMXZsTmZ0cXZYREJLa1ZKazRNS2h3WGt3V092QWlmbCttYkJrY3g5YmRqcHJuQ2xZYlNQdVR4bUVEbmRmQ1lGdkNieVdjMnZZdTFNUVFpdHJjcnB5SzR2SEFTa2QybDFpUGl2TkdIdTg5UTh5MDFoempGbFdCZGRRL3lCZkpKRUpmcWtaNmVWWWZ3NVdoM1U3TjJFRldvb1pmUGlUdkVka0lIVk13d1FHSS9uNkcxeEhKVVFoYTVlVWYyb3Q1ajNwUEVuMGhwMUZLU0hrejJURXg1UmpSYk9oOU1QK05DUmg4MkZDOU4wZTJSNy9vK0Q1VkRodERPUGtwNGd4RmYzVERKRVd5cjBmYVNTZFhHTFhYRWFYdnZSWjkzUFRIS1lxSzlZbW8yTlhUWUs2SU5wUW51TUtHcm5ENUI1SXlOQXl4aGpkbkJDSE5temFsYjh2RkJjbjVjYnBMTFVmcEw5bmRCU2dpS0RXSkU0bVp2dmpDc3FtU1I0WkE1R3FqMy9XWWpCdHF2V0lTR2VaV3VqQ0pEaW5TeFN6TlkzUkwydEF3WXB5Nmh0N0NLY09GbnN4SXZMU0VXbWtJMzRBYnBUNG9qSE91L3FXb1NLNkZoTGNHKzRKVXlTakp6aVY2UThreDdXdVk1dTQvUG13c1JidFNZRTdZUHRoendKc2gvR3hpNVF2WWE4eVhrb1RpSnJtN1JwSi9LVTY1VGFSTjlrYUk4SG0xYkVOcFYzS0Vpeis5eFJBTC9YRGhYWWRlZmJrbTFwMHd5R0ZJVXlYWDFXWXJ5RUZESHZheWxNcG9XSVVHeXhGMW1PcnNndUh1NWpzTWNXRFY1eThYV0JUNzMxekdXZm9NTG1DK1VuakVWTExrR2V4ZFo3cHVzMTBaYTFGVVpqcy9pMjNZaENJakViTUNab0NSZktoODNmZVFDSlQ2dENhcWg0cHZSZWdvUGpDNzllaTRJNTNJU0FGRW5RNjM1RE1hcGV3MzdEenNhZUp0Z1BXZjhiV0FNdWNWMUlSbzBrWVl6dDBRR01CMmd3T0tVZXE2d3Z2UDlXbVpUSVVXdWVCMlc5ZE1rVXFiMWc1eklDWER0MG9obm9namZha1FlaVRHTFV3MGxDMkJMVkxtbmE5OHk0cGFUa0dYSmRWYjNXNFg2SjdjZ2Y5TWRlT3o0Yi9CL0NoTmN4QStsZnYvQmhDaDNBNmRYQThseXMwNGxSWllZYmZXUnFQMXFsYWFFVGs5WitlampzalBRcldGSkYwTGt2YmRzRWV1YUVVYmE2YTFtTWErVlVuYlJ0N01vSWo5UDJxckY5SEg4OHFhSW0xZWJScGtQMTNYNlRFNWZTcU83YXFlb3E1bXF5aWdRbjFHRkRMWmxRRk1ycHhkNkpyUHVTN0crck5rT294azNOVlhHdEJBQUI5RFZGYVFiQk1ScjhyL3diU2h5RFFOdWVyZjgyT25Dc05xOHBDT0cyMXNxY0FkM2Ezb0c0RUVITXhub2g2T2hISzBQZStWS09TV2IySUE5Vk9xZDArVkpHRFovZGhKZ1hnS0o3aDl1MG9UT1ZFOXRMeXdoa2RQYXMxMjBnaGMxMzFnRFc0RkVjTWFPek1nTHVDOG5TakhPRjZ4NXRnbm5qeVJadFpmVmZTRUxFaGQ0VmJpMVFjM3o5VXRDYW5ybnZTVGhzdGtXSVZQSUlnNkxjRElqYldBS25IMHlQbEZCU3BJeDBjbFVtamZMUVA2RHhlSnFSTk51K3ByTHpyZ1hrTG1MKzE1Y202VHFTMW5QVGN3ZEtyRHpUR0pmeXNWRCs5SE5HNyt1OHVJSXhlYWJOOGF5Rm44Y2svc3ZtOGZQLzdldnIzMyt2ckxsNzRFYUh2YXhWeExKQWk5WTNaanh1UmwxRmlyZXNvYSszWUFRNlc2dkJzMVdkcEFNSjdZYlN0OEQzTFphQTlNcHhONGtFSGZXZ3h3bnlhVUN1UDJ3SW5CVElrV2ZoRGtpdHRiaDN3WU1Ob2FqRFZkK2pGVVNPcDg4V0YvTXhXYjQrU3hEY29aUWtiY2ZtRFRGVTNNd3ZzZzhmTTRodVQ0ay9HQ0xxVWxvSkdyTWJpV0dQak5aOXcwUUN3TTdOMEZFQm15Vzkxa3Rja1hveUc3NS9hajJGMWsvMWFFbHYvdDFqQ1FBUisyWTEzSjVZaGhrZ3gvL3NSNktmaTRlRVhOTng3ZTQrb1dla2hjb1k4ak92Q0NEVVBReHdSM3MxK2dqU2hlckNmc2J3aFJsY3ZxMUQ2d2VENldHWk9DMmdlUU15VE5qR3JTOElzZWtSa3VSSWNWQ0RNdzRIN3RuVkpOL2NYVGpUN1hwQlNubCtMYmJYSnhYbnNvN25TZGIrUU0rVDBXNGw5Z1BOK1VXc0VRbG9XRkNoWTRXOHlDZjJNZit4aWwweFArekl5SlUwWnpOcldlRmJvUlhVSys2OThiMk41UHJJM0ZwaTk5UTZLdUh4N0hXa1VLUWJpbWpHNkVGdW9sWUpQRlBzR2p5LzJhNWNnNW9DMDFuUHNjVmxDS2h3TDBVSG5xUXFBbTBhZzBZdDlEU09NL28xQ044NnFaV2UyV0g4cHRjb1B1UGM2bENhVkRzL24ydFIxVzVHUWZXdWRKVlpocEZWMHRlSE1kR1BBdkNuOXJvZXEwdzc3OGxqZFZBNnZCaG9odk9rOWNzV1ZER3luakFBbDdiYVpZaGo3VFUxNFB0Wi9NTnZCbTAwN3lTenFFMTFNMU9MSDY2QVJQVTJONFhneWVWOGhXdEk5bmpSdFFUQUxGYWV5ZnN1VW9QYlYxL01GQlJRemp0UnhOeW9KOEpiYzZUbnZDSkpKTmpvM1NDSUJNMDM5eVMvNVdQZHN5dFBmeHRnNUk3UnpKcFpsQ1FDTFZKQ2R1VDcwYjNUL0xrSktCZHpzUnd4L2V5Ykk5OWd6cmtJYWtxd0EvaUxtMlB3eFBYL2xNV2tJeGFFVkk1RzdyN3QrK3JETnlFcmZQcGRnU3RkQkJkZkZzalFEa0RSeU0vcXRNUGRGNWZLV3JMVTk1a1JPSXJuZWIxd0FQYnI4dFRhWlZlYWtreXhZMTRpdDE2QW5kOTJjY1JZQ0VETXVWQUlzNjVyNExudTByMWhIdCtWdEh5R3pUeEZIa09ocURkakdicHBlWUQzWWRLZ254eFhwR0MrUjBPbTFpSkJwRUc4RmptRkVrNit6NEVXQzMybVJHNUhJOUhBOXc3aGV3eE1ySXZ2ZENSYnRaclBSaGNneGdiQ25zWnlkejhON2FEbkpMNDFIbDlMMXAwNDZWN1RMRTJ1WTFXVE10VGZkM0xVYTJOZlIwMzZlUEpjalgwaFRyTmVST3pOZFp3VUh3WVl4eEJQUzVhMFUzNyswVjkrTGFtTjVjZDZoaUgrbzRyd1p0U0NTOGhjUXhwVVArOWZ5ZW54S0ZEdVMwOUVvNFJNb2w5akRjNDdCY2k3R1FBc1FBTnBRSC9xQmV0NkVSSUtkV05hUm8wK0ZzalFJYjFuRHZNN3BKQXJXeTBwTkRWcUR3YmlZK3BjTEhaQXBqcytyTTRMUXMzVVpQYWRnalpSYk1xUnFabUE1U2locHQ2MVVyU2liWUJQUm1Ib2ljamhxcnZ3ZkhrcU1nWC9XUytST0hoWFRoME83eG5SYWxZZXhzY0FvbEFGVnNMdHc0bFBCWEdGSzNBRGZxendyVjB1U0pzQVFRWU1YOHRueWhla3dMZldKTXpONWFSRkhGeVFnR0dyOTQxTmtXQzZjMXp3NXNZSXVFZVExS2RsWWJWc3d5SDZhbUlaNjh5anVUdjZvUWdFWldRSHZFdUowdWJHWEEzcVJkekpFZFdnOWJyNjhlN2F2Q1Ixd1Y0a0xhRFpRZE83SSsyeElnNS9hV3BLcFNFNFBMYnBUVndSWFpqMGlaampLYVgwZkp4Y3A0a3dGeDk1Uk94UGg0YnhCWHNNZStDM2tPanJEZk5SQ0Q5cXFmc3hYaWdUeE9MRVRqMXFSZnIySytXUXl4NkFXNjVYeGV0STAxcEduZ2I0UnVHRVBRMGZmMkpjRUVDZUJzOGRuQjZZS2xQczJrWlErdW0yVnpVRGozanNDSmgzNVQreFFzdHRaZjlSVUpONU15M2paTUpWMFhxODEyTlFaSVMrT1d0OUVCMXBDdFJ6ZlZkQTF2NmNJT3oyY2NlUXRnMTR6eGtKTkZRbCsyYmh1MlEzUzQ0MC9haS9hTTJJbi9UenlFeHlrRC93TnVLYTAxOWZQT2tCMjJGaWJFNDZMQnlMVUtrMUpyN3NxN3R0enlLUHNrWWgxb2drNENZc1g4YW41YnRvM3hwRExubjc4ZkJvTHdWODBCRG9mLy9saXkra2t3Tmd6cXFRNm5FOXM4TUZhdVpWcG5RUWJPbmFWVVlSREluYkNDbkF4YWthaEJWa3lPaEszRDJBa1d0T2daQm81blFqeFFRWlZPd2s3SHlJdS9WdmVkU0llMjJOWlJ1ZjFKWVQ3NS9jSEFTSStqbHE0d1R1aUJtOUlEdXYyR1kwWnROcGYxTnBoRjhGZERTcTFLa2srTUxvbzlhazl4Mmw4RXI2UXgvWU10NlhUWE5vWkNNV3djZzMzemNJdTFwQS9HYTl0OU1UUDBQZG42b0R6VWowSTdIcE52eWhLMmgwS2ZLZkxDR0QrSVAxR2xkVVZRWkdNV0hwNFgvVHMydE94anphdzU1VEEybEVJa3FneUttNm40TW92MjkwaUU0WlBFQWFRSDI3a2daMjNFb2xKb3Rjb1RSNi9pVXVYMDNVeHI4SlZuS2I1QUQxaGJ5SmxqajZJOWlNRjcyMWMxbjR2QjBQaU9MdEQ1cEJtRlpzWXlhZkVnUnF1U1VlZVp0RldFQXdaajBHbjhqY0JGcDFwYm5tU01lMThvemhjdEczWFBrT0NxSFVVYmVoNGJyR1Z4S3hhbUVVd0VJK09JTWpWUjRMbjBMUm9YNzV0YS9MM0xCalEwd2k5clM4WHpuWERaSFVvREtLemJRKzZVQklrVXdyWjRWYys1dmpkUDBNVkE1dXRmZU5RUnpRekZyQnByaWdOekdKSDFRQmhEK2hmUS9VOW5XYW9yblJZcWRSa2dqK1JsanV3RkJPNzFtZUFjODlNYjh3a3o4eElyM2UzYUwwclhtOW1YV09wZThQQ05GdSsvUUJKVXpIWFF4M2hyNWVkVDA3WGN4czFGQkswZ2E2bEVhMEEwVWdkVWJIaUtHYm5UaXE0NzNjWWtDNlFOSlJUMUE4YVZxaTF3RnJOMWZaNk1VU3Rpd2JwYVNSTU5TTFF5bUVuL25FSEt3OHRJZWh1cC8yVlZFUFV4dTdOZHYwbDZMTjFoY2xWR3pyWDFWNHlneW5uWnZTelQwdzhWckNMTXhPa0R4dHpRRktnVjhvWnRkNVJjMDljbTVCK2VvNnlLdDFUd2JmdnN6RHVYWVljeWhIaGZaMk5OS2c4QVpyUDZPN2FDMTVYZjYrREVLS1lURWJqTGlGYzJOdzlhQmtnMEV5cjhIRVJ5R1JOZnh6Z3h5TFRMaTQvNzhBdWwyeEhHbUhDZ3o5aW9TV3E2V3Z4czVrTERwbG9WTHcrTGZMVnBFYUZ1bDlkNDRZcG5aSG1Ga2RzWFQ4WXZQS3lPcjdVREpIVFYySmZLMC81ZUNwdkhEVDFaRkNLQ3pub2J1ZW9QTGk1UUlhZFBiNW1STkphUEFOWi9RMnpqZFpzYi9iemtBOGNhNnBTUmpaQWwwek5lLzZ3WDdCZ3lUK3JFZHFXV0ZkM1MxZ2tONkV0ayt1TmYwTHdCbE5ReXlpS2tnNkNZK2h2a2E0RVA4MjVFWW1wdXFwRmtVMlp1b2psV1orZTdyNzZHbytianY5Mk5PL0gvd1JHc1RlWnpsUFA2VWhFVWdHb1F2NXpyYXE3OHp6YVN5S2toSmpWVmxDb1gydHlSWVBVNm02TzBqWVgxRFlKSXdubmE2M1JXT3Q1NXE4ZUMxT2JkYnNJUytKZ2VGTHJpSlo0OHBxdkxVMXdFeFJ2a0J2SE9pZlp0ZDVBdmZzRjdsZnJZWjY2R1k1NHQ1bVdYUnpjdG1kNXdDY0JJL3hENERhY1VTMjdtR1Z4S2djYlRRMkVzaGZBUDJwMW4wajZPeDAyalRFa3Z6clhTbDFpRWo3MTVoVVpoSkQ0UWNtbkdiTDhZa2VQZWdpQUl1ZTAwVjgwZ0xLT2VmMXlWKzdVdUZYaDRpeCtlRHJteVlVNHFiMnRRVmRva2JTakVhc3d1UDhvWkRYNUlSR0pmbmlRWWhvbjZqckFPU1lLa3pKWnhIR1ZGL2hyS2huZjUvR3RPaGlQN2twdzEyTjZpbHExM1FZOEEvTmpoMjFWVXFjekRHK01SV3UzV3JsaXc0ZHJaaWliZThLa2RlVmFOdjJ0WWdVUk5lODJ4L2tuMmRoZGxZbWViRmhxZlhodVVzR0krZS9FQ3k1MlJrbXV0YlFqbFd4ZjZjK0lscEFLNmFPdC83UElmWXBsRDFKWWVycEk0YjdQMFhPRmZRQVphTVhwR3hUc3RkTjFKenhQWTY0MndrdVU2RENMbS9xU0ViOHNDUjArMUNsQlJlcTdXSVVHclB3MFpSRzRoNDArVWRUc1ZhRjVvWGRUTDFkRlZSNVRrMnlSclpxZ0cvaDljbEJpeWRzNWNWSUhLaGU2MkxFZ0F4V2JnS0ZnWCtpQklxK202eVRWdDJSeHFFenFQeGFIMDFCNHZxNWlmZUVONlExQndDaTZhYk5xT05HVldqRiswQmY5L2xNa05aYTBXSkliRUx6YkJIcTREcHQrZGZ2d3FFRFJaRzVwaXJSSUlkY1hERFU2U2dCT1BsWnJPSjkra2hmRjQrTkIxSnphS1JOeVFWZkRMVDJJUkNhRzl6OWxsQzd4UFVWSTlYcWpVenU1QU1PelhVY0VCSEplZ1UzNlpTM05QQ3hNdHkwYUk4MlhUYy9BTk5jZkl0SDJCY0ZWMGpLd0Irc0JrdjEwdTJCdnJJRWNQK01TY25DcHZqbGttdnZCeTgyNWZVdmhVc3QwNHhxcHdYcGpKSUxjV3NNaWhod3pmVXVtVUd4NDY1TllLaU9uSXlnMktrZU5hTXF2TGZMRTl6Y0NEbzlaR1BHODlQOTdTYmlYZjF1Y2VySk12M3JUbFQwN1RzUkg2a042Z3VIamozSll5QUw1YlJwbzAzOTUzaFBFdmR1eGJYOEF3eHJ0LzA2OHEzeUlSRWVsTVgrYVVkS0xUNXRWNXR0QndyREZqcWNZTUNCZHNZVUM0ZmIwajVvaDZpTVRYRWRyRWQwZ2Iwc1RNNGVaeU51OUNsMVI0UUtIazVQSm8xMnQ5cFMwcnJZSzVoVVkycjYwODR6Y0w0d0FJK05zVkRtK2phZW10UTZocEgxRnVLam8waVlHMkJjVjQ4dHNBaXhXTDRGTEZ6VXFUVGQ2M1prRTExZmx4ZE9zVWZsb015d0dBZmtWSlF0SmQ4TVZ3K2NKWVRIUE5aVld1ZzdpTWduWFo5WTVqR3BKRDE1TnhHMEplRld3QXpubkxCYUtZS3Q4c3l5RlpTNXJxUW5XYmk2YXNIVlZKR0NDTUV2SWVwUkw2SlMxeTVCMiszTVpVZG5haGZ6UUJwQ01zSFNLY3o2STFUbkpQeU9EOU1telhZdkF2MzlKZDEvN2srU2dnY0YzbXViM1hpVXNiMlhNQ2VZQ1R5UHNQQitXQzg5Z1dYcnhzVGNDbEhLc3JFYlVLWW9EVGtQR3NOZ0FEZ2xxeWo1SEhnQWtyUm9mL3BrekU5eTJaRzBIUnQzcFFicVpDTi8xdXlVL0MxbktFYzdZc0hoNUlWZXM2VzNhRTh1MDFsMzNaUFVNVW9nOGYzV25kVkM5bjJSaEllY1B1Wk1sUDZqSjNKRSs1Yjdoa2tySDVOeHBBQUZjaGFwNGlaYUQ3M005dFlPQmhOaHM2d1BrRUpiMVBRdC9DaGhHMUNVeWNlSlFtTVVzRVNQTURIT2pjTGFXVnhEUHBDOTY3UFJIb1ZPeWRTMEhIOW95WVBXRlhrVUhjRTVnM1I5M2FqZWxkdmVaeHR5clQrdEhsdTNHTkdQYlJVNXZWSEtySzI4R051ek5QbGxsZ1BRRUFWYTdQM2tDN0Q4bXBXUnJZblF2RXIxTk8vaHY5dEFoSEg5azNnNWhjQlBKY29HNFFpSzRWOTVheHYydHkzMVM5Wk5jT0FTYW5GNXNpbFJTbnMvUlpKVEpaWGd6Y3dDNkZkYThVRTdoUG1PVkVDWEVqaUpBK0kzd21DcUJscnRKZUdiNUlnUjk5WUxoNE9mL08rVFhCbVBvS25YS0RKRXpPSDRJWm54dTFBVERGM0FXeERWSjhhekpBMDMwNGlJL1pHSE44a1JpR2FiYnBFOVJ6clNpRmNUUXUwcE1vSkZSbmFISTdHQXpkZzdBYzZhRXdZUDEvdWN6ZEh3Szg4SjFtY0RIUjFXbFIrbURlbTVQNUhwY0pOVEN2dWI1WnFabnlGcGsraUs1NEYwaUxyZGNTajZiM1k2NnJWZkl3amtCTWNJNmhvNjIvcWVnTGV5STc0RVRVQUVMOUhDa3hyaXlZakEydUwxbEhRVVVWOWFtRkFUcFRBemZHVjFTQzFFZTlrdzNYVDl5bmxidzRmMDQvUUwrUzZLYUQ4WHJXWFN1TXQ3ZmNMRXNmZy9MQjNScU1xSTlQRUlZL1Yrb1VQd015TU9GWHNnMHEySXpjN05MWk5tMElwZ3RmTml6RTlOWFB4Tkp1aHdzUTA4TS9MNmtIOUZqWVM3eDNTOFNUcmthcUlYOHJsaVRmUHV4U2RtQmp3WWdXeERJUlNILzFvN1BBQzJUSWNDdmxGZlZOVzZiclllSlhENmcvVGE0OUxGcjE2RStTdTBmVDNtLzU3RGVLTkgyRFBXTWgyVWNQdXhVRGlDaU8zWVJLQUJ4ZStkUmNKRXRPSCtlT2dHOURPQkpuQUhQcE9sMjljdzZNM0I1S0daS1N4Lzg3UldKRm5MM2haWkhwdXkxamljR3owSFB1Y2lWaXRzNWJZTEh5Vmh1ZGY3eWlaZ1Jqa2ZVbUwyUkdkTHNjd0tWdTUvK1VlY21sUzVqc0hGYmdpbkZ0WXZ2bG85bUlRU2d5Vk9laVNvdjZGdzAxQzRwQXlqc1hjYkhWUkJ6Y3FYcGIwdWN5cW82Y2RhTDJzN1RLR0t2anNUL1hpdytkOG1hNmcrZXNYb0JadGZJbGdUaENaWVB3d0t6K1lrZUVvQms2UXNLMElkT3E5dXBDeGVOdlFsU1RzMStsRzkxeGxzUHpieTdRSjRzTG9IOWFYYTNwVUtlRFFnN1dLbXJac0YzYnRHWjMxWHVDU1gvWGx3TXdFeHJ3YmNLNHRXRWpQditUeGlXWEs0QVZPL2NSZ1BwbGJKeU85dzVDdG9iWGZKZW02aHlMZmwxRHF6NW40eVpuU1hCTThTbWN2c2NpZ1IyMWtrZHQvVWo3MkpQa1RDUGpVZXA3QmhTRTJIK0NFcU1TTWFienFKTkxqNG9OZjNxOFJVUDZrSzhQcjdTd2dMcGJwMVRGbElxc3U2OTUxS1E2YUVNS1hqc01TYVBPdVMvdnk2b0dCVzMzTDF1eEhFR2NDUjFIeUlhV1MzMWJwSjlwclpOWVpSSEI3YTY1STVjSDNiVnRXRWpqOTNaTVNrNzIrZzdXVVVhWUdJUjYyWERCbjlidGk3bFpsb3duUmlzUG1HMS9OeGVkZHRLRlNqOU5POUMxN2xUVjRBUGVaZTMzMVhDV3MxdTI0aWFYZHNVdmd3b1ZZSDZYbXpJd1lmWVdib3pZV01zbHlMMTJjSkNYY2ZUNitJaERGVFRTd05wM3BEM3plY3lDdVBUTjVnOHJob0piME9kNUNqUTdoenQ3MUVqNFpwM3BaZVhmVmhGQVc1N1FKcnVURzRWSlJseHhTb3YyQytzMGk0WUhXOENqSDhSRmlTemp3M002bHBVMTlKbDIyaFp2aDBTc1VaWVVuM1BPUU80MTUrVVZ3RnN0c20rNlI5SCtvNG04VmNBSjF4dVpUOElZeVFKenZrc2h0d2NKT2dXRXJNR3Fyd3J5N2NXTkliWWE1TWxQQ2M0U215V3lyZ1pQdVloL2EwNzVCcHFyS2FWS3dEOUhaZnBtRzEvNGdoSGZhd3gzQ0pqL2JWUTFXMmgyZlM2VXd5V1kxVHFvbG9DVDZYUG84Y3pXMXVRYStsdWhvZWkyMC9jcHZQendVaEhTeFVNcUFYc015T1crNWxiWFhSSFN1M05iaW9HVzVWRWNQRVZrT3Ira1hkYXd5L1JBL1pyY3lhQU9LVzhyVEltVDN4cDRVaE1icFV0NHdDRy9xM3BUZ1prcFEwcUJJU2xVM05Gdi9UWG96U3JieGNBL3RSUGpVNGZsRlhvSGpJVnBFRHpnZThCQjJlb0MrMktZWHg5RE5iWnY5a3hNU2h6WmF3YjR6bGFrelNSdWVpcXZQdHNSc2FLUnhoTzFRMGxUOTVBSHNWR25tVUVEc1grRktDT1lYeUhDd2lEMkdUKzk4U0lacnVyTEZkR1FZTTZTUmZJb2lDQk4zWkljODBHU2FnMmMzRUwzdVBFVTl1UlVTK1VOb2hOdjJyMnJmbWpsdnFIZ0VzVW1pcFBXNHEzL1A1Si9xdUxraGFHQ3VRYnF2Y2hWWmNCcVFjUU5XbURwbTdHSHc0NFFycUVBTDlOTjhjWXVaVkVOeDhLb0lDalZtazB1QWVxelc5MjlFWVR3UkpqMUlsVzI3UVdFOXgwTW45ZWQ4QkJJL01vaUlrSDM0WStPNk9RUXhUa3hlbmhUR0M4Y0hNSUlnRGVVbllTUlEzMW5XYThkQ2owWVFFVmhVVnZJK0lVZ2pIOVQvbzdSWmNGWldFcXlYd3E5dzRKa2c2dUx6dk1UNXpWYTJjbVI5VFJkQWtERENMbmhvYnBoMWhGWnR3TmR0amt1R1JCWStzUGhHK29GMVhleW5HVGJDeTAyYmxnd2V6T0EzODZiRGF1VE5hR1FOMHpKWVFudzVCaUd5dm9vS2ZTL0U0VUh0TVF5aVVaWWhieENPSVlNZEhjcVU3RnNkeCsrWkJhbVoxMHlERnp4SUJWQzZocE5Sb0diOFVWS3A1aHYyb1A5RVVpRXBoc0VDbC90TW1GQ2JGZ1dCRDBGWjQzbWpkUGVCYU85bDMwMWkwOEtKdXRaMUZITERwcUtwVUFxcmNqWlZNTXBDYThNbFVpenBZMXZxakFwVytsNzVwNkVxTlBmK1p6cVRxRVRwUlVlT2hhMUNkM1BLUitFWFhtTFBwSW5MczdyUVNPeW52bGlHOXk1RGwwMVlZaU82Q20wemN6VTFrQUFpa1h0ckNod09ZMFo5ZExVYlRHMSs0MGlYLzVYcmZ4NTg0VHZncW5WQTRTZWhDSWJOOFJibnB0bGs5amwwQzVDVEhGUkZBNnR5SlZ4cC9VYUdaR1JJek5sZUpwSktLWjJWOU1MRlJ2cDEyTFFZbi9FN1RzaDJwNCtqTnh0QUprUlNZSkdDL01UUnlUcDYzZFVwQVZ4ekFoRGE5dUpoZ2o3S0xDVGdIV1RiTkRGTFlGckJteUdMSDZ5M29WbVJEUVNyajA0dVM0RHBxaVRVcS9DaCtybnJXRks0VmY3V2xvY3NSWjBoc1ZDbm1Ia2wxV3pnQ0s5YnhDaEtRWE96YUJJMUlaNVFGNm9BMXhldEEySTdKTWNkejc4dXZQcWJnalRFZFJlaTlzY2VQVUJ5cmJkd2FZb05EUzJPaEE1QnBBYmM1alEyVDljZ0ZINE1yNVUxUGMybzNOYnRsWWx0Ylc4d1NDQWhYaW5FTVVrcUJBYjFZK2JDTnhVNHh6L1BtTG91ZCsrR1R1RDRHYVJKa1lUM2JqSWIvMGxhclF2Rlk0S0NUTWNHRjEvMlRYSjBuOG5STGdvajlXb1g0aWgrQXNZbVUyM2ExZUtLVUg2anM5UjdJT0t3M3Vocm5BN1JqZFFNZUU1WGdJMVUrZ01MK3QxYnZ0bTdWYTdXb2NvVnZidmN4ZjBDVVpZNGsvYS90WVN2cEVnZjFEWXkvYjVRZGJiZDVGcEViYTRlbFBhQVo2OXA5Y3NTTlpVYkpYRENvS2drQ1pRMUMxMmdSdnNybjBZajBERzlBQnBwN24rLzhRYnhmR213Q2EwMzZRTC84N013RFViV0tlQ2owbGF2QysvTnkrbTNvdE5EbGJlbW9iTFpyTUpLRml0Tis2c0Z6QmdwM2VqQzZoc3ZIV3ZJRS9mSlJTQjZTUEM4c0VCTlBMT052VE52cFROWWhDTlBuK1dTNDB1UngwS3BpUmdobXdGNnhqblh2T1BpbGF3azRMVTZUd29KK3RhUkJobmFkV3Rsa3FKbnF3RmREVzlQam1iMUJPWFJwazF5OHNISkdNQlFmRnNDU3VSZjZTNUlKSWcyRW5ReE1ic05Cb2pJc1hsSytxckE0QmZXMEFrem8rRWp6emZ6ZHAvdkxzUzFnSVJLdGd5VTlVVnVRZVcwVGNLcE9hME5FY2FJbEp0dVBwcjVtVlVIa1ZISWJ1dnZ0dmZ5VWJPZGFmaGRJdUo2MjJpU0xWaTE1NWZNN2JDaWhKeVZUTjhHWG9tUWxST3pkOXpoUnpsWC95anJDNnBBNHNTOXVvQlZ5THdId3RsM1pRSStxZ0NVYTRWU3dZTmJvRTR1Wmg3LzBEV1UxZWkxa21LQytFWS81NW9XS3IwejhxZVBPZzVYa1pHdkRTb3ZzMzFyM0d0QTlRd3lBZ0dVei8rOEFqMHNNSWtJVVVWUzRhbkloNjdXWExFdnFEOU5wNEhjb0p2QUViMFZSYkZXVXdOMWZuL1ZTblkxc1FNVkp5aVpuYTNFbzVIeTF4cSsrcjZXNEFWTFdCVTB5OWU0L2RCRWxWbVRFNks5S1lMeEpYYTk1VGVtTmoycEpNbTlabmcvWU5KUlNWS204amZIczk5cHBRWmJMNFpVdThOaTVTQ0FHRHpoSlFjcTZyNll5cGwzRWxPMGtLWHc1WE9GZ1lNMnpyRk1SNlIvVmxVNWRwVkdpakF0Q3ovVzdadEpQbUt6M0Z2UmxCU0RJN0hxNlBtc0FhYVZWL0JFeFJsT05KQWg4WGVBdkpkRloyTjZ2V09FYjJaaEdQMFZMTHBOdHFkTnBzMmoxbGsrS1RhQXUvTHRWT0FGM0NiTmtLTGNUSFpYVEtyeHpoMjFBelorOHZsS2pQT01aa0VhekYvOS95RDNHa21tUmVZaHVlYmJndVBkQVpvaFA1OS9tNm5vV1MyN3hhZlkrUlVGeGt4dVgzbWY0TXdTVU5GNUEvdFZqWUU2Ym5zVHF4V0xMZHhEL2g5RW4vU1Vpb3pSRlZxSC80bm5vdlRUdE5EY1ZJck1rSGdDeENtR3lSTkQxYTVuTGRQenZzdEdXeGpMRldxajM4NC9sdExHNmtsOXlOcVZyYjlwVzNQeThJMUQ5Q29OQWs5TzMxK0VJMm1ST1dKaHdKR29yVnNyTzd3bUV4bVpEN3NKNHpqUzZGdHZyMkVYM3ZSVXZhczQwR0tpSi9mSnBVUXBkditab2N5TTRkOHcwM1ZTN3dHaE1iNkpqZTdxeDBwQ0lHdlZnTkxvaktwdyswaWhBa1gyV1ZzVTFiL1hmYW1rZnJWRWQ5aXZ6V042U29aMWlkREU5S0pZaVlHTWJRdm9PNk1qTFpWM3NnNEExN1dLZHFDY3UrOWcwQ3E2Z3BLZ1ZCbnU5cFdxRnc3bkhtU29iZ1BwSlU2WHdXaCtnZGJKbkRlR2grQ2F5UUZIR2Nza1RSZHlXY0d2UWNLWTF0cEd0NWtBVmx1NjdVeUcwdUhMbE1tNno0QkxtLzUybGtlQ3gwb1U1OTVSdEFTQzlDV2kvVDFuZmNyK0FMMHpqSG9zdGxoMTZkQ0pvRmRRU3RmZlo5MzBBTXJvaVMxUlphY1pkZnhsSFUrVzk0VEYxaHFlK0pBZXdEL245UUgrUUVSbWhHSHh6OER0dG4xZWt2S0hpQis0R0RmKzdyVjQwZ1hBUzIxRnR4N1RrMGRKUlc4K3pGNjNPajFkMThYenVPeGp6emphWHpqVnhjVDNIbVFER1JTUDFMSFlqcXdTZ2NTUXRBTm1zN01MYVU5VnhIMUVwbExzZmRER05iNDB3NU5LMkh0YUIxWXZnVVlMcWpQdTd1SUYwU3JON0R1N09pRUlSVzh5NEE3TmZGK3FOcjdqeWlxamN6eTZ0Zm1vZ1h1T2NTRW12UlViNnBoZEkzQzFHL1l0ZERwWHhoMEFGTGFjcTBsZ2o3b1hlQ2NkbXQ0MlZJZU5SOTdqMVZNUFJzazM2UFM1Q1FTeVFMOG5ocVcvcWJTNUhDZHJpaTlHblo2VkxwVFhCVWRuNUx0YUZPc0dEMm5KU3plekJkRjUwRXZUN0M1TTVqRUFPeE95bUllbGIyaG9JclE3Z0E1Ulppb1lhY0NpYUdocDFpNXVaQTBRQ2dBVmIvRVdBcEtDbWJ6WFlQYjFQVVBZSTZ3Z2wwSmlPRWYzbERFQVFQcVN5V0JTWVFwajNxbUNDZzd0OXBMc1dnMCt6dWZuNUNQWG1RcGVpbDczV1IvUDF0MzBGWUh5YkQ4N200NGFFYWtlNzhnd2xidlFjNWljVHBDMEpwMFQwQ3VRdFBNMEI1VDNZVDhmOHdzNXZIUnVMUHNQRlBaNnZMS1hHTlB3amlCRW5BMmVNalluNmpnK2pWcHhIa201QlZ3dWRrSm1SeUlpTkJYRHQ0SDdzTEtEZlhqMjV4Um5IaS9lL3FQamI2dWNQQ0h4TnNKV3pZNFN6THY1b2xFd2luYXVsV1pibFRHZG9aVWRMSXAvcVZpWitPUTU4QkJlN3hKSlJhMWVFRkNUOHZiRTdoNkdOWUFhR1g2VVRZNmFVTVN1blJUcEJSek1acjM5UmlsTENSSmhkaWpqRGxMbm9ZUjBWSU9JUS8xTjA1bDQwcnVXSThDSi9UdFVxbFBOU0lva2hnTTdNbGVXa3BmdFlQcTN5M3kySTVlQzY2V0JVMWp4c2FqNEIzM1RzVjU1NGhEQ2tCanhKNUgwU0VkZU0xVVc5QTIwSUVuUW9EN0ZMZVFlZXlkbWRZVnBkR04rRGRPaGVud21TOURJMklJRzIyZ0NLeUQ5dEt5MU1iM2I1RnhKUkRsblE1bDkxL2ZGNnB0bE9WYlVsUWI5eXNick5iaWxmQUJJMFh5TWtWVWw4YUZ3MHVsZ1RGY1FFTi9sNUpJTEpVenU0RXFtZmJBVkFVVGF5dllDR1dac1IzWmRkcWFKa3Q1dHJOaVEwampRUTZCWHFBcUFYbW9KcndIeThqVmZNbUJDWmRpYXM2dGJEMzJ2dU05dzNydVRIdlhvaGlKN2RXZm5qN0JnMWpmYWpMekUwQlM2VEFTMHBlUVRPdTJIRWZtQW9QQWhXSytZYTM2K0FveGczblBLcWtEamZnNnhjR0pEYU5XeXNBMHVIQUlDMkNBcU1ScElwdk0wenNlSUY5eG9jZE83WW1yUGpmYU9TOHlSRi92WVpnSnZncDJJRGM3czhGVlRQZEthQUNhUlNVZ3daOE1yazlRVGhNOXBFM1FmcFZuYjhoQU1HVlkrQkZ6bm5QYUdMV0dMOGh6STJGNW5xZTkxaTFsNzRkMVRvODlPNTZkQ3g1QnJlcmNDRjRtK3duTmVralNqbktyMm9TUWJhTjJjdjNHUHJiYnJQbWJCUTBJK3JNdCtxMHp4MW5WTE5GSDQ1SmFCTFVjVHNhMXlBYlBpNWdUc2xmaDNvcmJGZEpwRi9CZUlyK3loelFKaU8xWmdiWEpIUDFVeitxNjd3NWJvTXdPSVRJQXQxekRLTW5iekR5N1QzWC9sMTBUL1ZzaTBydWRUNk9Hb1hGeWV5WExkL0RrQlpZYTBsOW5oWXQvcUc3OTlON3B4QklHQVpMdmNjRHVVUFc1a0J0a0haUk8vYVFQTVllSDhVYWZ2U1N6dzNNVTB4RnduQk9PMlZzSkYybnRkK3dxQ0NrYzFGK28vVFFjY1JFKzhwM1diNHI2YVNqYVNTMC9zMkRNZWttTU9HbmI3V0pCQjU1bWY1eXB1K2JadmxiOW41cTZvb1AvMUZycVQ2SUMvOW5pRHc4ZG1pbU1iN0pBWmNDb0lkb1kzM0ljTTFFVmxUZ0VKVGJ0Mjk3VTdtektRTHhKNkpzYUNUeUg5ZTAwY2Y1YVFXeTAxZ2dVbUw3VVRxQi9VdGZvU1FrcEtPVVd4QjdoU1ZZYU52ZmxyOEFSUldJaGRrVUJKUjZURkdEMjdRM3IyK0ZtUG1xWnh5Q3ZGM3AxeWtTMHl2M29oZDZZWDVhYVNKeXVzMWs2YTkrb0VETUdYWm5PSFhmcUpuQWduK3RvWlhzZFpFaEt0enpIN1ZId1ZwMTdDTm8rRkwyaDBxTkoxQS9ra3FOYlFvU3dKaXNVcmxMTEVnZW82WlhqSlpUVnYyQkZLRlZDRzNSQ01acTJ3VS94bmtRYm5UbCtUTTY5VkhzNDFnMEg0SFA3R3lEL09OSzMxMkh0UzB1Q3p6Z3RjdGlFbW96UW1nNDNNcFRGR1hqM3FLQWJ2MGNDQ1U2NVhJb0NUSEwxRGVjR3FGSms4b1dkYlljRFVTdTA3R2sxc3U4N05heVFhRU1QVXlFYWw1SEkzRHcyOTdnMEN4dUtnRGJiVVN0aFFsR3BobFVicUJ5YkNlajZZZVRkNTRRaTBDcFk0RktRVDR6a1JjOHRjY2xPTmdzdEpCeHBUNGg4WlN3UnJNZ3Y1MXNzSm02REZkSDhyVnNkTWdCdmVidmFBbE1qQXNMUEhVNUpBNXBDU0N5b2oxa3BlUTNGeVhxbmJnNkVrbmRQS1pGek9QUmpIUm9lK3IvWG1oR04xWXBPdXVHSEZ0TVRuQWcweFoxQWJyaG81TzZ4S0ExM1Z5SUF1TjlER3JHMi9FQTk2QldjUkFpUi9iQXFrV1F0Zy9BaTlCamw4c2RFZTNNZUcyZnMyMG1ramdEeDRjbG93SVpTeXBxenBUOGRtK3B6eS94c0UxSHgzbzNDRXhZUkF6QTlFQXg5RnREWDZQMzdoUXdISFM1QlA4MnRTTnNXVlJRbEtOdXUxYmY2aEJyWlJwdVQvSXlQMDcxMVUwdVFpRUhCbVpUZU5WcURTaVp2OUQ5TC9iMnA4b1ZBSk9jVm5JV2todVRlVFVwOUg2QzVsZEFhcDBFQlE2K1lBRGlJMktrcWQ5cDZSclpJSHJVVmxRMEcyRUNEK3E5MFJQVUhXRDRtN3hyc2hldzVsa2pWTmJ6bnpsalpKZGFCQ1hpMzl2cm0yUkdNOW1zRU00MUJRNmwxVkxHOGNyRU9WYTk3MGxsM2dTajJOdWxaZWhiaGc3dDY5MElZVkp4WG4wenVGM2lCMmhKZFV6UE5HcTFSRzVCeDBEWVViSFlndEl3L1JCb2xSd3MzK2IvTnJHaU1XMkxvOWhtZEVlWVlhclQrZ0dRUFRCNzJKOHFRWjdzOE9CZWxDQW5OOCtFNnNlMGtRendNbGo5SlM5R21FTFlrTVI0MVV4dlFqUHRNVXpTeCt6WVgxR1VhYmtLV0Q1YlJwanRsNHB0NDRxUUVNQmRtUlpLZDF0VlRtcGlVR2kxcWFqbE5pWUlFN1FqU013MWxLbm45TzhRUFVMOFFkMzUrZWJjTmtJUjNLcmd1OFNWT1d3OWRUVlpseXp5ODNncTdPMG5QeHRyTGluTUxNT3FyZHVxbFRlS2J3TldPSE1kd0s3S1ZIR1VtL1R3NDNQbElncWpoTUU1bjVRTXhjalFOWVdHMEswcVJpU1pYNzVidkNLUXpqckszMnJURmZrSVkzcmpFSUFEQndNWTE5Z0dHeFpXMFBpK09rNi96N3FXZHB6K1pSY3Frdk9PNFV6VUZXcGszbWtEbkNNRlZDbU85UkFTMnF0Zk5YQ3pkRG13eTBBZ0pUSjFLTitmb2tmRjJsN29yREk3K0oxbkhiU1NEQThNTDMxNjFPd0hmMXJKekZyQVpmeTFJZkkyQnFjZGl3NUdxT2owTWRIcnNwSHpWN3BLSHZWOTdZbjIva0E5TDZxQzFlWDlGZUhoRHVZS0pDNjBKZEQzOG1wUzYrOGIvQ2xsNVFYeXIveGZmQjR1RG9UWTBQUk05Zyt0RUJnTnNMai9GYWxyYUsvVFJJelFxTzRlL2FpR1Q5eHV6NjBBc3o2R2dWaHJKanl3allGbzZRSFRENTBvY01ITURDYTZnN3AzRE90c1ZHbnVKZ1hxeEpLLzJBa1IwVGNaWnphZ09nTUxTbVphTHBEWlMzRzcvVVR0U0wxQ0xXS3BWNVBoV1hNdjR0cFZLT2x1RFZrNFpDT3o2MDNDYm5hUjRlSCtZRXdvby9xWkR1enFPd3BibkhEaEttd0ZDUWx4WWd5ZTZIL2hiRTZzMDF3N2ZxUndjNnlHWk5EcEtaU2Y2V0tNR2t0L0djTUw0bEFhc1FERDJpVThVZXgxeW0xR3NXVFFuL3VNTUZuT3oza0RLVU9adVgzNzR6N0tST3I2TU9tajl5cGI0d1VWYlU0cERSOEFIaGlGUlZOOS9rd2Rnd0JYS0pBT3lRWmRFQ1dmUVhLQmdsK2Y1M0ZmbUdjeVF5b2VrZ0pxU2szb1V4V1lvRDFYT0JrRWdnd2lKOGtnNzNoYksvM2JyUnhoM0tLWlBDZ283Wm45UnhMN0RJa2s5emszT2tzWEVDMTlMZXAxZDRmSmlycTFmTEE2dzdXbUlEb1M1WUlmRm9LcW1GQ1dSQXhNck9sM2pKUWdmUlVVc2txVEhsS3I3Zjh0QmZUMHlIL3lSdS9DWTZrZDRLSXZJUjVqNXp0T0dLVFJpSTRZRGE1TDNvWFRQa2kwMmJEU2c5N2YrazhJaHBNYXBkbnJyT2l3QXBNTWpKWkFYVHB2MEFSRWNJVTNiYUpoZWtlZlBoS04wY3ZINzZFZEJNdnl1VWQ2dUUrdmpGeUxYcVJXZGN3MU8zSzNrV2wvWDJNeWxSWUtvVDh2MVN2WEhCdm1GU0Y4WnJURFhiVG1yNXZ6dTlRN3owWDVZNTFxWTdCRGMyZVZ4SnJFVVhWRkdNRE9QeHBoSGpNdHVWWkhXT0laZlZXV0JYVHhIWlY0TnpONWFvbk5jd1Z3aUVYOUlYSGpzenk4dnFHeE1zQThRVnBOMGdiZGNTWDZuNkpLN0lKekFlMGtvaFVNaGRwczFJWjFMZTZiOVdycER2Z25RRHg5S0NWUEhlVzVjS1ZxMVpBRVhud3luL0w3N1VNLytXTDdBSGN5TWR3QzVnWjduZ003Y283SmpWMmFXQm9FRXhpMlcreng5KzRUbjB3cWI3cTZTOHZ0T1pTdGhIZE9TVTEvQW8yOGEvMmk0bm9JLzhLdVFibzNEeU9jd0tyYVEyNkhZK1BiRjI2dTE2c29LcGdBOEF6VlZOTjE2am9ub1hUWEhRSUpTdzJUV0RZazEyUGFvaU1IOVEzRktKYXN1UWU4SXN3NXFZcldJMEVUNGxEVThDenVoRTdSbnFyVTI4YW9VMlVGWVVVY2RHN1FHWDR2Yi9tbmpXQThKS0Rtbi95M1dUM3IwVyswYTZNTmdrR1JOdWdkb1FuazhaWUx6TUhzTzMvQmNhMU1pZ3VDUElSS0lOQmRRaW9vUEZMaHF2MzM5ckZ2SHBZTVRMZGZva1Y0Sy9mZ2RneDQ1MnlVRjdFOUowK1RwZDVjMHlKNlhWMG1KQnZycm5NdE9lUlNoV0dLa3lNWmJPdGJJVkJnTDcvdmdiZHFML05VRTI1SFhNNU9MbFlqZ1JPV3BhVHkvVE9KQWRxRlVWVlV6anVHbGIvL0w2Ym5nVEdjVDJSeUpOYmpDZFd4eHBqUTF6a0pjOVhkVzYzN1VOVVRkaG5kSTdtc0gvcjZjWFlDdU1WSUViYmJFNzNEelR6SHhXdGhjWWo5Umt4YkZ3dHd1QW9BNng2S1NTRWxnTmVpSEora1dyNEF6bXcwQm1td1V0MG54ek84OFVuWEx4THpYd0JkNXlMRzE5V0tNVkdDYnVRVmJUMzVVTG56L3o4U290K0k1Y2JLNC96bVNEaGVUK296R3NQdmJFOFVYazdjNThVTTRxZFpMa0FKSU80U1IyKzQvWGwySllOK3NkaFRpZlpNY0NET0ZneVhEM0d0YWg3bDZiZ0FRUFlrSDlDc2pmUmFGc244MDlWNWxpQXlncjU4M1RnMUN0S1EyVVM2ZW0wdHBzR3kxUElZeDBZOEkzaWptZGRUbWFEbmdxYjBnRTVQN242M3kwcndFcGt0V3htYUJ6SjBNVHNld2FHbXpjeXM0anNQZllHVjJEL3FVUGR6ZHJGdEFiWUpRS0laeGw5ajU2RU5ON042UkxnaFFyK2FvVHFKYk5BSWhUMXdyRFZmdGR4S1RUSTlVeE1TaGM3ZWNBTmhoRXNQcC9rbThTTWlCR3EvODJBTjhCaERoZThnaTlkTEY0bUJhYUhHbXhmckFsTUJZa3IwSzNQR1N3NjhRaU0xbUlXZVZNRkFaajhGNkh4OE9iRG83bVY3b2krZjgxRUVlWmZiYkNqTG9QODI4bnVXVE94ODBFWVNoSVl3enBxRWZKbjBuak9kSSs1dGYrVno4a2lGdDRyd1huK0x2YjdGQVR2cDZrTHc1VURrdG4wRi9sYy9XR1hKWmFVa2JOTFY1aTl3cmFhZ2h6dHJaSTU3RVRQVjlkT0ozNUxhMExuZFN2cWJEdzZaVWIzeHBOQzhIZXdreGpDZ0kzRGFBQyt2citSMFJiVXk0WVl3eDlnOS9VdTl2Wk11aVN3VDduWUphWmpSSkpYSEVmeUdOTWNDTG1hVmF3OW85V1JWT0x0NFcydlJmRjMxczhsVmY4RFJTa01XRTkvZUV2UDkwMmM5Q2RhelYrcFhJdjJoT1VTMTVLc1lXMHV5bHRkWlc0L0NacVRlTDJSdS9xOTc1SXJtWlRKMTA3bHZMYkRmMWp1UVFNaHJMZGZVV0hrMTA1MWxwTjR3a3hmdkduTElXNmljV2lXeXlRT2U4QWtDbFRTVE9KY3V2OERGVUY1eFRkNE5YbEc1cG1acnlVTW5XTlBXb0loaCtXb0pwL0lnS01menNxRFpKelBVajV0ZWR5RUJKRk0vc2ZET3VrSDM5T3E5ZXZkeEZEVkpZZ0J2Yk8zcHo1SHJCREtpcnhNOHlQR2E0RnRUM3RXSTdYQnRINm92R2oySGVDRGE4NWFOMjc1elhCM09vYU1IdEx0QmhlcE90Uy9zUUhyakl0ZWR5Mm5WMW1wN2tnVjQ5cXdRQmVyQWpJRWR4aWZpQkpuMXlYV3hWdzJtdFpLOFFIdFBtcmhHZTJRZlExRU9jaXJNVmQyRXpSeWFnQUNYQlRackQ1b09CdDNsNDNqVWQyd1VHZ3dNWXl2dWorb05XNUxKYmFBV1MyRHdLRWNZSTF0alVCQmd0SnR3WkJnbzk0UWsyeEV5VXFMU0xyNWJPdDBqLzlRbFpGN3ZlZ0VKaklidzd0WEdyZUhSTXlmcGgzL3hTZHN4cGlkWFRkWE9VOWMyTi9WS2JQc1hIVVVFVzlVZFlVM01IWnRVUG8wTTNyZ0xQU3haY1JMS3NpL3RITVA3VDVGMzJCQk5VSmFoQ1FnWjQzY0NsMXJXdlVUNkFVdUxaMXdaRXgvVWhFK2xRWnJtQ0VWZVZuREl4MkdiSEE1di9OS2k3Q29WVitLQVZBWi9zSE9JT255ZnF2cEtNb3ExamR2OFE2S25uVzRDZVpxVzJia284MW9UcTA1OFgvaUgvcXFLc3pKdmF4citwT3Rwdkh6U3RNYjJCMWJuK1hTbnZuSXdKN0FkMWNqalNSRTgrb3ZDTTlTTUh4YmFjUDRZOG1GYWRyczJJRjlBWFN0RXdVeFdIQ2VROTVaV3lWeFFNN3RkUFZ3NXIwYTBPQnBpNWd5M1c3UjRxUzJJazZRZGNjcGFkZmh0NkZVKzQvSkdKTDYzWEUxRlcvd1NiWStOMWtmZlo2MktpWk5JSWg1NlB0SENpWndoQUFUWllOUmpUWjZXYk5JS3R2aGRUZlpON1luL1JWclE3aC92dElUbVdVc01LYmF0bHZBOXZQK1hsaHhXZG40RHhrcXhVVjRSbVFMRUc3NmhhdG1oNEdseGJGbXNhNHRmOVVONG9ZRXdZS0RHSE5BbHladTJMUjJPTVNrZDFlNkcrMisxOFFvdUpPdlJPbnh0elM4Vm1JRXpRem54YlVtQjg4RUNDOGJoTHlUWkJZSHNmdDRRZFdFNXVCSnJ4MXE2MkNTRGhGU2UyN0lPS1BDVGlqcDdNVkZzTlJLOU9RbjVxYkttbXAvRGh0NnBMWmQ3RWdOeGtWUi9hV0VuMDFxKzRudW5uUjdUQTlkcHlVNktIN3M3M3dBRkYxbDVoWGJIQmVwRms5Q1NxWFdWQkRXK3FpM2UrR2ZWeXpYZ3FEV3RQemhXUGRTN3NqNDF1Vm9NaGlFeWxiTlNQc0MrYmRTODVQbWNKN09udExBTlM4Q0EvK0cyOXNXTUZTSlZTMGJPMGhzMlFweXpKZXNJMFB5cFFpKzc1VXc3blQwVkhXaEo4dUc1eGNSTHNTd0NQbE5hN2NnaDBCR0tsY1MrV0xJL0RWWVNZRnB3VWxoQTlOUHZzN0hTekl0Y3crQjh1bU1QUE5tNjI1TSt5NWgzTTRpT0RJRFBhSjk2enJ3K24yaittbGVwdEwzZmJCM1VmVTRuRzA0TVFRSTRBdHZ3REhjZEpHUWoza3ZITTRGOEx5NlYwVjZEL2NQemUrUE9vNGdkRzNTUHhvTkdaSzdoZE9HUmVnK2UzWUFNSkh6azgwSFhoRGxTMGpscWU3aytTNVdocVExQnVla3lRVHZzQk55ZjBCRXc2dDA4NWRVditRWE80SWxWQ1c0cGxyYURvc01BTWs0c3MreEV1dnN6ZmpNQXJaQ1hBenp0aE1CZUN5YTdqbHlkTHAyM1cwVm5wbFd4VzArZDdQc1NTWTBOVGJ2MnBUb0wyR1Z3N1ZLbURJTnZITlZUaDVPMzh2a0Nwc0ZLWkVGOWo4TmpUVDBpaElJU2s0dExld1Z4dFVkZkZoV2duOU1Cd2pPY29jZzJkYTB0YkJha1BIRytFWVVadE1LWWJFVllSclFjWHZLVFI2Y2JHdjRjTHdBZFYzbWk0ZUhXbnAvYmEwSW80T3hkQ2RZQkVQd1NOSDNsbVY2eTJhQmpIRWlsS3NBTnVyWld4NE5HN1hsOUJLOGtkWUsyTXdIQmV1TVNJSUJ3NVVXTFFjNEFPUXp2alZlSFFKZU1PNUpoVm54bWM5cjlwckJLWHp6cjVDVUlFTVlLTWsyZUxPUW9oVERvM1QyVGVWbHVReUlpTlNQaDY5WU14ejN6Um9wMjBXTnprb3p6MzFYTWxoMUJRSEhhT0VSSEFtVFBnWnU0aEtGUVVHZXFveUQ0YXc0Zk9SY0VjdFE3dWd5T21vV1BLejhwMmlXeFlTV1Y3WDBKWlVISEd1c0gvYW13ZlF3Tjk4TnNTaW1KcEphNFdvMEJJRnlYQ0xiVVZnUmQ4am13UTJKa2RFekNqK2xtOTBJZUtkSUpYQU1nSkNWRzYxNWJEc3hYQnZrRlZicThKUGFiK3VTWWphbEQxR1NDR01RZVlqc3NnVndqL25JMFl5TnRNYU5FQ0tJeHZkRDExN2NOdUVmNWdEZG05WUxVSWlBZ0ZGTGNKL0pOZmhPL0pBWnRCeVZGZG1VSzQyNUt5ek9rcmJYYmFlUU1XNXhiOWxGaXNQMDQ5ZWlvZENMNFJKZEw3TTJCVFBxWURSMjJxOUZoelF4VXE4VkVFemZjdVJuNTVmak0yZHcxSWxlNmFmT0IvR2ZhSkdDdm9Wb2JFdnJ4c1E5cnNiSGdXNEN4MDlhSXhrMEVBZVFRejRmQkJkbXMya1BIT2E5eHMvU3Nnbi9wa2VaYnYwT1NXekJHREd0aDNuOFRyMk93OW1mZ0hTcm5KazRFRUNJYTBHYitZYkZRNmd3azZTOFgvUDd2c2pjTjlVOWRxb2tMcXdLK0JoUHllbkdXcTByZC9IK0t0VlVsTWpKdE1vbFlscW9TZUtSWFpBMzJDTlliUWVHWjZVUnJleXlvcUZaNHFJWTZFVlZJZ1RQOGFWVFpodFcvOWpiY0dFclRUNFhiQzdZR0I1RDZVRlpvVnNOTnpJMGY1UHg4N3lUbzZpMWpQcHdFR1ltS0U3Y29UcHBjNG9kUUhyeDlDdy9TWXFObTNKejA2NFZzVitZVnVPUVpQUWEyNHg0RmxoamthQ3FGUWNmc0NaVm5tTzlOQXdsQTZMVzBPZjlBdERiTDhZcmlmbVRDbTZpelV0R2RQR0ZpTFYrdTMrV0tBY0pWeUFrQTgxN09LUndySGJKWU5XVUxOa24zMFFYRjRrWFRVd1VrYzBNd1NCQWpxSVdZVmlnRmdVR1NNeTVBRGFsVmxjc2ozQTVoWG9yU0IrRG5Db2tvTjY3cnNiWXlVWDRieTVSODYxSlNEWEsyMngvcTJvMHdOQVZ6TWJUQStwbTVKWk03MWs3VmR6L3N4bmJMZTJSTmhxMHM3Q0tMbGc0MWlyQXc3TFVpUzF4ck1sSTczekU3WFJERDJqajJoTDdUdnV3ejhZV3dmU3JQOHBaRmFZdDZxdUFXWGNIbXNtY2RBWFB4QzdJSVNHVDRacjYvKzlVbGh6bDAyVHcvZi9iejNSZVc2RkJDWmNDSUNycmdwNkgxQ3JXYWVZSEhGallDYVNVdGVzSnBKdDNYTCtHQXc0NDZNSTVCU3ZSaFU2SkZOaU1kQVBOQ0tUTkJXbE8zMC9GZzMzdGNMcUdxM2hSdmpRemg3UHVKQUQyQWZIVVR3L2RMZlZad3U3OHdxbVd6UDVwQXIwZnRUL1hhMDNYWWZWVUh1OG5qZ0NPY3hEWXY0Sm95UFdRZm9yQzhPRU5IOS9ac0VqQVBhaE40MzdYVTZRQXUzN0lmQTgxNVh1ZkwvSVpOZlR2UWd1Q1ErQ05pZ2dxMS82RVdWd0l6ejZZS3Raa0IxWkJnK0ZIakcycGtrelFUL0Y0Sk5pQnA1SXkrVXVmL1pTOWxDelI2QkdXbVZqSFFYK1VPTXZZSmhDZEZxdlphVURqUHNZUHl5cWFXTHdkaGo1ZzZUb0QyR0d1U1p3OTFTaHJTSnlrLy9BbHBFYzd5d3BOSWtYVStHeEpuc3hWTjhuUTNjbGtsc1d4S0JRNm53cmpsUHRmU2hJMVJzOWw5V0hyMVUxcGFmUlFGS29TdEJBbTk0VVZZbXB3Q093ODZkQUJCWVRMQVUzRVhqQVUzWnowZ1R2bUs4bm5MOWV6cjlIbkNjSmlJUzFla1JQUUZzQmRqTWg1TFQ3TkUyb0Iwc25WaXhNMGhYM3pnNUNUdXVaUUVJYTFPcXZTaGJMODhRTm4reXl5SDgydktacVZ6UnFqb0dhSUJCSmtXRHFoaEpEaWJmNTRDTHVyVDYvQmxoQ2xpVi9DYW41YlVOZzcybWNjeEJSZ211QUFkeHZOY3lRNFNGOURIaGQ3V2JCbEhvOHVsUnY5ODFMQnI0dTNYQUJRbktaUzRGalUxQ0ZtRGp1enRIb3gveFV0ZjI4RGw3ZDdGTHZ1SnBzU0t4Sjk3NVJEOGlON21MUGpXb3dNT3A0UmRiUGt4cFU3OEVhS0lQcUNLa2VXRFZYMDVqL3RtQjlmeXZZcXhTbk4rU1NaWnRLd01nQ3VIcWRiV0l2MGgxUng4ZGNCTDdCTU1DOVVpbXVrVlN0TjNpaWpyMU5QT2orZklsV25oVzhFSjRleEZLQ0VUMEdMeWpvZldPWW5abnc0UlNCNTA1OUlsVlB6alpaeFpIK2VtREFWMTQ1OWRZSmN2NE9RUTVQNmJpL1FxVkpvaUI4R2hOUDMrUWIzY0RHL2NReXRXekdWOTY3UVZTQkxwMHcxN21qWVFLTlB0RVhZSUszK2Q0TnhOSTJzUnNOS1FqcTQ4c00wNFlGYUhGZFVYUUFDMlFwSnpreGNJb1ZMTk0rYm9obENIZ010VjRhN2Q5ZW1uV1EyMkVUTjNhQ0RmeWdxcTVUYUNLQmtiS0tRbWNmak9may8xRGFGVVp6L2p0dnZTMXp3bERIUStiT3N4ck42eS9rQkl0WDFSb2lmT3MybXlmUEhubWN3ZHpmNm9CTnFpaFM4ZmZJajhBVnUxVzBLbkRTaFRXbW9sOVhLdm9XWDBXY1NmZzlweGNYOVlwbnYrQThJMTg2UjNIeUNrQ0paTkFZTlc2cmxzNGhxMXRuWndvVjEvbWVQRGFNRmF0WHFQMTNNam83bEJVQXBndURPQTlaYk1WdG5KUHJxL2JneHQxZ2MzaVBnUGJ5SkZWQU1yVmkvSGFOTmJBZnlJSTM1aWYrSXNnSDBycG9OQXdta0RIekNxV28zYTlqbmhkenprL0pkR1YzaWZ0aUZVVnBSc2NnS0ZaZUk0Y3dEV0d2OENYTE5lekRSaDRkSGNuSnh6cm5jVGVqd2pRMlhwQkJBdTdjMXRrdE9YYzd2T0ZINy96V3QwbDBneUs2NUduSTJ2Y3dTYWU2a0VUbmpaRU5rTE5iRFhTaGJpMHhLQ1JKWHA5VkVEVGtiejF1aXRzeVJOcTJnZ3J3SkFVMDJGaHVzcTZWMytmejloQ2plS1lQUzBoYk9JSm0rODdNd05Jb0EydlVvNHhSN0QyQThBb2tFb3FDVTJRbWtFSlVLZTBmV0JGMVJORXNFTGRwSFozQjVsQ0FoMm5FSTlJaCs0UWNhQXpHSW15MjBhZEI4Tjc3QWZFQXNaY1RMNDJLNENiMENqeE14MlVVeGI3ZWh1RFNEOXpvOUpSL1NIY2hKSUJVRVQzZnFoN08vaGJBSEpuUmk4ZEE0U3kwWS9OWEFFNlF5SnZGVTBQVkZwMFpja0gyOW9BNVdHRUQ5enR3c0tLT29kcVRDWitlVVVlRGc4c0lTdFFIaXh6dHRQWlN6alJzL09zaXVDMG9oK0hXYjQxNjZvZUUyQUFmUnVRUmZyY0JCS1J6eHo4YmFYNzRSd1RQd25EVDF4RGU2aDltQVBjd0tUUFYySTQvWjdFUll2ZERPdjZLSHRJcGdTN0ppM2MzQXFaSlN3bTJZUHBNU2ZlTjRuS1JUWHk1ajZBWTZ4RFZFVXZuUjIwK1JxZEV1TEY0L3BkWEZzTE1XYk1VNVRRSG00VFN3bEhTRzNyaHJ0OC9oUmRocVh6RkF0azBPYW5GbkRBWElySXd0ak9UaGJYMWQzZlRKS2hqR0U1eGtPWDdZN0NsTzJBTHUvVjNoLzJXQ2R1aGxrMTB0MDNubVhkZUdSZHhkanZxeGZZVHRxeFJHbFRzY2R3NE5BNkFtSkhaTDBlbEJMQ1NETk42dVNmTUM1OFM3SlQwbjRudTB3aEtFZlc5L21jSkUvYzEwWE44amJ1QjhpMEFpQXRXRzVaVzlMaGhabyt4cCs2WEZJVXl5NXhGU0U3MkVOMXR5aHdKZ1N4SkxwOEpCRFNIUEN0OGppVkI2TU1PeWlBWDZZZXZ5SlNnelorMEx1bldCOGpYL0gyQjVHTTVxcHJPMmRWdTMwL2dubWNiUU9QTkNmT3lwU0ZjbjdhM1JHc2xOa2NrdjZ4VDNseXROTzl1NmZTN1BrOFJ2RCtnRUVuOTlRQ0M4dVFySTgwMWdLS2Z6c0E1Wi9HVDB1UTh5aDIyN2tSYSs4MlJBenljQ1dQOFBpaTBVNjNoaWFwQkxNVzE3bXlZZXhPUUpmTktWeHN4QlhIUEN5czFOSzdPSjg5VkNEUTl1UkEzYUtOcjNiNHAvQy9vMWpNMEQ5RnpIWFh0ZDZLWXh1RUV2VkNKd21HRUtMSS8zazQ2U3FpaUFKeTZGSUg2ZGZ6eFV4RlhXVlNyZHZoL0R2L2xrUWh6WnZyN1R0L2RSMHBwL25INzU1T1h4d1RMdHJuV2l4ZXdXWkZFVktPYk5EL0NINzFJZFl2eU5jUy95TllqY1R2VFJMbEhacnhqYkxXNlNvOEpkdTNidnRPUUd4eGpveldIUzJSa2cvTVRlUXpYZVhqWFg0TnlWcEFvL0ovUUtsTS9qL2dmTjVubHdRbThSb1hhd2w3c25ZZHFCSW54NnpRNVgreVlXTWVIaTNzN01kcFc1M3NrMjJWVURFQndBbDNmMkNLaXc1UEhicGpyNERBZ0JscTFCOHEyYVdFZW81TGZqb0FDZUxVb0tDaXhHWDk2ckVPZzB1T05XbjVWVTVFSi9vSWd1b0ZhQkhFa3RaYUo4Wk5TUmlEWFV3Vm8yeTlkN0dqUFNISnU3NjZsa0NER3VoV2xtVFRvTVE2M3FmbldmT05NOGI0NGM4N3A2Q0dTeE9uVnlqak10cGFLVHJCSVhBRTFQVFBKdzRtRzZtN0lpZ1FDY205L0JpeFVRNlVrZjBLSXJyMDNaMTQ3OVo0S0JEcmVEeTBOYkZFZ05oVEdIUjhLb3dYNnF3Z3VHbXB3bHZheW1DR3RLelhWZm1KWG51WHJ1WlplTXZ6STFGaVQ4SmhQeFJVWGl2eEhDQVZONFp4Y0F3RXZha2RURDUrR1lPYlZ3Nll5S2g1RjIyNGV6NWc4K1oyeGZXM2hOS3pUb2NSOFJaaitacC9rMFdQRnB4OTZFclNQMm9Ic2luMHU3dkwxYzZjZXVlQ0U0ck10LzdySFM4ZUw5dnVJN09VVWxMVFhIR2FyUzJydzRFMVBjSjBUNlJjcUxqNmMxdnY1aTBZdTFkNzRPaUNEeEdzMGc2V1ovd21vQkpEZEJCSk5WK3JFVGY1VDZFanFkUllhZ2cxQkxiSmVCSjBJbCtEb1RzekphL0tPbkxORm9zaU5vbFZkeDEySDJDVnNJdlJQUXFYVnJ2d2lpMG53aWNQUW9JempwWEM5cEF3bFFsS0ZkdnlXdDdjS2J0WEVMN0pPamR3NmkxbEtsZFcwUnFiMDhtdHg1Y0hCbVM4cTB6VlU3NmdpNHdYalYvSTBUOEVoZjFabTdsUWl6MkNpdDFHOGZadEN3NUVGdXBWNFQrQ0g1TnZ6UkZzTTZlQ3lIbDRZaDlISjB5YytsNXVyVDlRM3BtaDk1dUp3VHNOVFNZc0hnYUNsUzRPSGk3azJkdUpteFBRVUIxY2xHamZrU3NQWXd0ZEh1ZEVQZjJwTkpGcTh6aktyMDdQN2NMQkZtMXVrVlcxamtMYzZxQ00valNybUZjNFlQUDR6MFVrcW41QUxlSnVGeEZFL2ZpRUxNb2dtUlVPbk1QN2xKM2cxdlpEZXJsd0tZak9hS3BuUHdCdmI1ZVdFTFpqMXNnVEtQVmJBdWFBaEFhZlNkbHBFRWl3SU5zWXZ6aGExM0lKMEcyUUhMSzlXLzRKdGxjMlgwZU9XY2g3OHA0ckFaMUlua1BLb080R2Zrc0duVDFYRUJtVW5RSDRUcHg5UWRhQ1RqbjU2TmNtS3Z1NVRuV05MZnUyVjFxSWtoSzVPc25FSm53d2VsTis0VVFNYlhEWmhEaVlmTXpqMmpJMzlLUkFGVVRyQ3RUeFVWak43VXhDWm1QaWFBS2JpTFQ1VVl6TCtyOGFuZDRxNUNISUF5Rk16VG1LbnlzVXU4UTJqbzNYRHhxM2t3L0FMVEJsb0dYd0hYRXFVWkZsR0pUNk5NZmxteG1VQTM4WTI3elEvUm5JY1RZQVdZcEcwZGxoY01mSENRWGxzNFJmcUlBMis3azU3ZUJFVGhnVWsyc05YWnJCOEU0Mm8zN0R3Rm1BUXMreE95YjlqaFNGNHR3RlNBNk1HT1JKYkpiTHR1NjZCMFR0aGppcEJBNnM2ZnhxeHF3YWlOdkVxUm9HcVhvSENoNXFLTGlkZWRaQVlOelMrdElDM2ViOTJzWHZzSkRDMkJHUXJZUGhWY1pLcXV3N09GZVJVVHc5TzRXb2VvTVltcy9HTFlzOXBnQjIxVXRyNDczZERKZjdmY01SazY2MGtOdnRzQjd3YzhaSWllVXNVVnZyc3RZZXhRNVIrU1RYWmZGajlLNWdISFFSbHJxc2lFck56VmtOQWgvUjNNbTdjTG1WOHp1dnA1NkZMT21nUnFaSGJWWTN0Wk9EOW5uTlFYZEVKVWdIdkpGZ05QSUZTZjliMFIyUG0yYmVseWI1dVlTYWJtZjUza1RPSWRRdlVqSVljSDIvNHlkQkVvbUlyUDNmdjlvR2pJeU03T0Z4UXpsc0ZmblpOZXBXOFlJSFBVQUwvbVR4elJWNUcvKzZwZnRISHFjV1FLU2N6T0phL0kvM2NxUFg0eGhVNFpVNXJNWmh5b01EeURFeFo1cU5GamFEZzNRdURaNnphd2hVTGNpUzRSbDVNV2ZCVGVYZG1ieUdWQ2JwaHZid1pyYkJTTWtkeGZ6YjBzbXJSRWRTVk13ZXNYZm1HRVRkbkhyUVVmR2JFcFFkc2wveVJIb0ZHMDR2bkYvWm1Sclh1c1o4SzM4aGpLZ0VJNUo5SkVsUDN1Rzl5M0RwMDluOHR3QTRYN3M2THFrY21NS29zQ3lBM1JFNG5HMGRvMU1heUdqdUtlMkgwSk5VWS8rc3IxeXh2WHpyOWxUOWlvZ1BwVW1sZy80NVFYOEw5VE1veDl5ZTNrRTk4Q0I1TmlaS3pZamJYUXhUQVVsZ0E1RElDN3YrOElnZHk3dzQrRmc0MGV6VG9jQkZ4YW1kN3NNNlNRNU5tb2FPb2JoWGc4WTRwLzNid1RBZVMvd1IxVGpacGhuUkRiVzRIUGR4bVFjblVaQlkxWjFnUjJIbm90YmxqU21XNlZTYVpkUGRFaVBpa3k1UGRJb1QzUTAyakx5c1lSZTBZenVpNk42UFc5VmllOW02Rlk4YVJRRDY0RVBtdnRrRlQ5SUsvcFc3WDdwVnhtOXJnRitQMjFGUGp2S2loS1BycW5UcjZKYjZFRTlLSU50UzE1SS91U09DWmcrVEp2RVpScnAxbFRnQUdycEJ0Q01jeUloU2ptRkI5bi9QY3BjY1dVSmlSWGUzTU43ckVpaE0zckV6VzFWdmVIYjFybGRReWVjMkE5dVRVM1hVd1U0cGZZbjV5V2FHTVdtZXhKVXZweVRZVDQ4ZmNobExwNkFLaEp0U3NQNjZwZndoN2ZtZldHR2RRSG50dmk0UmlBRWw3OWZjQkJQMUtKdFRtR1JGUThINjhadThuUjhZSndrVUJxTTJab0NJMHZXUkwwYmJ2bVFkd1IyN255VGtQYnFDOGZMVEZ1dURhNTFybmt1TTFZMUNSMFdsR011OEVsb2ovYUxOMHN0cDd2T29KOUJiS1R5YytMaE1iU0wvU1RndTREc2ZEV3BFUytXRSttbWd4ZzNVdUlDM3doNEU1N0VxMTBMYWJZcWwzV1RKU1B2YlB4UjViVm54NHJSTnIwVjI5MmhDMW9mUHA0aDNpTjViLzVjbTl1SU5jSSs0THVETE5Rai9LVE5XSVoyQUJwWUlZNGhFSEhsdHBXaWYwZGYwYkc2ZXo0MUJnMC9QY0JtSXJVRHZwV0s4SFJCdUw2TXUwcG5HcXFRTTY1VHBXdmZhK0pGaFdNaytER0tVOTd1OEtBM25pcGxuNmJMMkZPS0ZCWmoyUmJvaDhWa2szN3BSNG9DZW5jT0x2dStSbzV5RTJXbUw0WkVpeE1UOW5WM3FEaU15Zy82WjlBTldMMUV6QzdRSWk1azkvSkFLUGZDZ051bU82djV0eVV0THFwb1VQOGpLUW9zaElwYWxzRUdFSXFldzJlRUNrWlYvN2xjanhpbEdhUWdYSE11cEMzY3YvempiZ3k5a251b1lPMzJXNDlnNGVndzRVeGU2Q2dBNWJQT01nbTR2NHhUb1BnOGViMjN2aGpBNG9sTzNtQlFMMlI1cXNvV0FEL1JwRGdxVkZVK1pxeWEvYkNoNU1BemV4Ky9XRkgrR1VGYTlvSU9Cc1NmVXFGcGNEUXkxWUIwRW1udmxseitiOTgwSVpDYVFCTndiT3VTdytqYmVVbzdEb3ZFOG5QL0xYNlRDd2IxM2RrUmhpY0IrVFFWcDBuOTVKcmlmL1FwbjFOMS9nc3NldnZuRHlzYlRlQVpEcldCZ2IwZU9GYkRTdDlKd25DSlhJVjIzbzdPcnF3SUM5S2dySEVhVDhRNnJPU1NqZHcrWXBVTVdvamxwNVpVYmhGYk1UZTZxU0JkdGZVSk9JZGxOL1V2Nyt0Q1RNUWpjMFZ5SDVKdHFWYnJxYmh5VzRFWE1vbWtVRk12dE1Fc0M4ZTRoVzZ6OERGTjR5eE5qRnhLVUt4dWVMTW02dmdhTDlhdjF5WmV2R21hdjBkQzBKbmpJU2Y3anFoMlptMXUxRythL3JrU1lrZmVhRUVvWmZ0QUJ3aVU1bVcrY0hWZktSelluU2ZEWmdGdDdjUUhrRWhsWmNrWlVudlRXL3U2OXhEaThna1hKUUNMR2NGUm0yTWlEUkhvUGI3ekRUd1A3MDQzNHl0aFVqV3FvUDhZUTNRMENBeWdWelVlSEovTEZHYUwzdlZad3lCb1V0QTBLa2daMDlkMWE3UnhWeFpDcGhIWjZDSnNNOHJoUjNvR2NDOEhUWjVlVlFIeHhpS1FsOWJDZks5K2pFd1hTQVRZc2hDWVlzSEpCaHZBQ3hFbDk2K2U4MnZBK1J2b3RGSWZGVy9EYkdnZ3RoUnFPcmQySVRqYmlkeXczRWRCRDJjdnJQNmQvaGZFYzdtVFhGdGlHandUTUhtUmpGOHJ1NUlKUGwvVGExNmVRSVVhT2JVRFp5YzJGdjNZZ1htMlBLSXlDc2hGMjhNdGkvUithalZucjYwQm4yNGppV0hXS3dQbFZPbWhCMzV5YVp3Wko5WlRGTURPWTBGKzFpVTRCNmhqYXJ2bkdIUzgzTFZNdmhJeEJEOWtnZFBXbXExTmM3dnF5eEpoRVFmL1ppMitPbUl5M2pZa2dnQURlRTBJZUVrRWJBYnRtd0JuNkp5ektkdEFwUUpXZ0xOZVhtNE50TG14OGlmeVVwU0RvWmZCeE1KUnZIRGlQa0xLaTIxeWY3Q1AvZ3ptMXNaQStYQTViTlo5ekJjTG1yV25ybVlwMTJBQnNQajhkYlVDSkp1alh0eSsxZTMrSlFSZ3d3MHhaaHZMOHQzQnJXcVhyam8rNlY0Z21JVEpNK08wTEhvc2gxWnRkK3NTZmY2WkZiVEJtek9PSjVTc1A2WHdBRVlFUS9GeW85TkpFRUszTGJJZzRGUjdPVmVqY2lLV1o5WEU4QlVSaXhlaEp4dGV3eG5XT2Z0c2h0VFpxZEZ2dVZ6cS8wLzc5ODVGcjlFaGs3cXkxM05LcklhK2dFcHJ0RVEwOStoNUJiVnBKM0x6Y25TZUVGMnJ0cFhweTZIN3pDdWo5akpURVNZQXdGTWNWcUY5S010NjJRM1pqR0JjVlNFVHJvMkhzdEV4ZDBrR0d1ejFLeEl5WjRUc2dLRmZLMWx2NXB5dHRlRnJoNTJCTkx2RkhFeEliTEF3VzBMTTVBak9JazBPWHdabUovK3VoMGxrSlFqWnBsYkVmOHhmZ3pwcGJZRE0wZ0hZOURuNFZjcnNaOWRCVCtmeEFmMnAzdkxMRVNKR2x4dlFkTXlBbjlJS0tEN2tNYklwa0tabTMxelpMSVk4b0ZYVzZIbU1EbzIxT0k0NG9vUC9TRWlxbWwxMHZteE43dnZXRk9vSklaSGEzQ1lFUWJYVWRjMjV0eHNGaFp1ekJBVThPbm8yTVN1SXhhTTFPa2VtTmRhVGgyYzBJQ0FnZnNxclppRUFNSzBkLzVCS2hDWk5WRGFROGhoZENXbVBtOU0ySU1pTTBVVldEMGsyTGxiVGlqYlhGSlIrU0ZoRm9BaUJmd3ZrVTlaV0R0dVR1emNGbHVvVDlBUHZaM0ovdHhkSG1BVno3cVdrblYxc1NRb0dOdHdZVTNLZUk1cm4rSmRESjdDNmxVQmJscWU5NDJaNFhGQ3lrbUl6Wnkxbm9MWWZSVm1vUWdMMFlNVTNJeFNQZ2V0V0hoWGhMc0x3aGhsRlkrRjFYRHFILzNXU2Fya3lTblBjakJmTXFrUkNzdHQ2Lzl4dDJkK2dpbEYyR1JJSGdZd2NIQmJjNXFNUVROU0VCYXVzNlFrcUtDY252VTVSTkp6a21CSnREaHpLV2RBakE4WnIwbjI0eUhKZ0ptL1RLS3VpN0RZcTZ1U3F0WHlYS3FkR2xRczYxRmZ4S1IxbTdmQUsxZ1FDUkc0U2dCQzhOSEdSV0NHYTczZDJRSHJ3ZUhKNUU3MnNJSCsxOE5yQU1pN2Nab01iL1lPODdIRG14SVp5MEd5SzNEbnpvNFZVODR0K0pQS0ZrbjV1cmp1VUNUcWQwYW1tVXRqdWwxSDZRLzVDTWdTS09SSDU2Y3NTRThzTkVFcVNwaERwYTlndnZqZDVqVFlwMkU5aGoxY3RxYkdZV3R0K3lnMGJQdEx4UmpZL2dWNXl4dlNMa2M0cGdRZUp2R2gvWEkvaU9sQlcvK1dNRjBKT0QyNHJXNGxsN0VmWmZLbko5ZzhvWmd1cGVxQ2dXUEV0ODdyckU3Y3J3QXFOZEdxWE0rZ1oxclY1MzJsYlNQWkhTWk1XZ1NpekdsS0ZVZWZKWUhScUp4NTVJTWtMeHlJK1FGelMwK0ZtamxGNThBdmVFVGNkbDF6ZFJTd2p2akJxTEwxbXlsT2VzdVVwZUdDaUNOeHhUa0h0TURrZEQrcUpoZE0vWFB3M0h4SWFpRnBQZXBob1F6bTVKeTJ1cnhOZTVCOHlvRDd6Z0ZDMy9zYTk2MTcwVW0wV0Fza3Z6UXdiYWdJVmJUMjgxWk8rUVJISmRzWnZZTjhnL2NSNHJRQnI0bGxBQmJYR3pnbTBDUWZsZVBTczZDRHdhUHdNMy9YUmQxMkg4UzhXTlhjMzYyYXVNbnBCcTRJRWhqVTVJZHBIWHhjaDIreVpvTTN3ZjZEbnVPSjZGMSt1SnZmcUlGSHFjS0NwZ1Q4NHArditnU1Y2S3ZyeE4vSGdTV0xzMGM5UlBPbC9mbjkzcDl6YmRDMy9JK2gwdXFJdFZpNTYxd21HVHp0VXlFNGpMeUZsRHpyRzYzQ2kvdU5DK0JHZUtHb3NNaVJGZG9WcXFvZFlnWUNqS2Y3RFU1MzBSb2pUc1AzdFBNbThLNjN3YmdjU3MwM1pTbVZ6WTlVc0gxL1JOQUNYUm1STURCUFgxYi9OMGpUbEt0c0REWldZWVJvYnJ5KzNsR0J6OTRnbG4ycWtiQjhxZDFsaVBiQ2d5NmpqYTQwOW91VWtiMjFQeVVEamtIQm1oRTdsZnFKN0tQQUgxaUtJRERLSGNmR2RVQUpZL1VSS3V2WUxoZ2xjOHdyTWQrOHdNZlZzNUl5MEFIb1dnYXBJaXcxYmQweWZaRDNUbU82RFZxSlpwbUVRZlFCNUZHWGFGbTRmUVlkVUZmSkxRSFZrQXgxQmlrVmlRVFR4TWNKbzAzMC9ZN2MyVDZTSmVrNEszSTJwUXRXc2J0cWwyRlZGN1FFUWk3US9YTGtDcDYvTWhYZGNlZnRxSWYxcFE2WnBCcFFPOFY1QUgyOTdNcnd4U0Y5MUxZanhjWDIyd1N2UWQzZnR6eFdyamlhVDJZRFZjSE5ST2R2SkFWZTNFUWdodHZkU3k0Uk5JNXprMnQyOVR3eVg0VUZlUjBMWXFEc0ljRjdYYWc5eXNFWHpTeGpGMVZ3bmFublRpRGlEdVY3endoSGUzMEk2RzAxZkt3bitTR1dVeVR3bUQ3VVhtUkdDUHdxaVZla3RZdlIvREthakxsVnFLamRRZ1JNd2tzZW5kdDRZbFRzSUdGVlVPMzNkZFB0Vk5JUC9jSnJxUGxKeFlqVmVNNmVVV2RMeE1BVDJFYkE3Zk9yV29jczB4QjZBVitzUGxqSzJhUWUvSGxRWEJNVkdNRGpTK2ZzTFJ3SE14WnNFVEI5VjZlM29Ydk00UmhJY09Ecm9RWkU2eWdsN0VoRjBQcS9hUkJETkwyeDdjVlFPUzVIVkptdTBpbEV6NkVFanlNYUtVbkpHSDlTWitrY2lvaWZ6d0dVTTQ2dTA0WGNyQVU3SE9yT0dEa3hwL2Q0MVRnN212eEF1T0h3Y1JyaVdLVGgrOHhvZVkxTWNTRWROc2JmM2hIZ1dqNnhEeHFTeGFydmhXb0RmS1FoWkF1dGpvVDk1S29ZbU1XSUhtT0FjTHlRZWJpdjk3S293WWZsN0N2ZS9FT3JweGUxdTBwUTdJMGkxWnFzd1RWbmtEc2R3UGpVUmlHd0FzSGtmREhHUkxIbFNRem4xcVlGUjhYc01uSGZqYWVkZW1mek43ZHk1YkJ5SFJHc0VtaXkvQ3hnTjJReGR4SmpGUlZTVSszVm9PREw3M2pVUFpsVlRJdzFiYzNrNlc0THFIYjVINGJ2aHhJNWxFQVIxMS9xSFhxOUlsTlo5U3NuVDlWV2lhNjBzQnVlanFUSHE0UG5qcDhBMnZLNFFjQ0ZsdmNTWXRaK0wvQjBESFo2SUUwRVFIR0xqZDJScUh1NTNTM2ZYWDNnSGlsdE1FdHJLaUlIeERXeGF2dGR5WGxUTnJmUm1xV3UyL3c4UU9OQ2s1Ri9qeXdBaGRjRlM4QzIraVVTZmlTWTdRQ0k2b0NnNXdmNmdvT1JhcWw1NUFyaS8zNGt5SmM5T25INlJOTE83RE1aME5ybGtIY2MwWTFDWXdDWGhOTzd4Wmo5eWl1UkI4VWpmQ3BZNnUwRGtsV1k0bjJYbWxZQnV2dzk2VjVaVXN2U3dHZlNPVzBhZUM2TjJRUVJ2UGdIeVhYQ1lldWRjcVRwSXN0QjMxLytPbDN1Um5qQi9MSlQrVytYeENNZ1QxcmdwRmlUOG41Um96VFV1RHhUNitlUSthcCtKT0xYekFOUE5qcng2cno3U0JUWFMydE44TEdzM0NUL25kY1RGRHJaanBrUld5YTRlL29yZUdsR0p5cXZoNUY4QXUyd2Z5ckJ6M2pnb3lDZ051RmhtQ29Ec1FSYkpZYnFxU09MVUJMZktXU2NpeXI2RnpzRFRiUkFEbmZaQjR4ek9vUkR1NU9nUXNsRVdOdUV6Y1Y2YU1rZTVaNVBjUnkvQVdLOENlNVJXdXR3SlNGc1NlQkVsWEVNVms4M3dvM2xwMWR2OUtrS21zQUl2TGZNeEIxQVBraU5keXpLQ0l6TzRDdHRndTdDLzBiT253cTV1UEtEQ1FpTXVLTlVVV201ZXJFdWlRdHdkUXBwYlZ1QkRSVUVHaFFIbVZFa0lmRGQ4YmUwYzI5TWU5NHRQZVFteFdzSGJVRkcvZnpvM0d3cTFBQVZISk5QRDVRc1VFWGxiYnVtL0JWQStQeE83VmFYT2Q4WnpxZGVwNGJFcTAyaEpNWmlzbHpqRHlTTkxkblFQbnMyWEdlUzZ5MTR1TXlUeFNGYnE0a09jNWdoSURscFJPa096YThNRGJOTVhRODZCTkFXOXprUjJEUnZDVm9ZQWllYWJBTG44RTRVdmd3NktJSkEvSWk1emF0UHYxTUlvT0gxU3FJbFAxaGUvSFJWV2xpdTA2MW52eFgxY0pNZDdmZXlWdGd3cWFCc1ozWnFmclM4WE1ZblB2UzZydTJ5Ykk5RXRBS2VjTDVOMnRkaFkrRWdGRkF5bEhuVFAzZDk2YkdlbDRlSzV4RGs3L2paMCtDVmFFOFhnQ3QyMzdJOE5hY0lRMnV3WXBvTFhNdmhNRTdPRUtrK2tWY203Y1Irb05aaGpybVR0aUg5RmhabEhNUnkzZnNJeXE1cFdDQmpwU2hIcmRWcDQ2ZktsTnUwM3VKbXhuR0ZBVGtpNUVsbCtEdkRLMjMvb01WZzduUU1yTFp4M29ra2FCa2wvNElGTFBWeTFJcUlQbXhHcTR0UXZ0QkViWENZM2R0MFo1U2hOYTdLazVRMlFweTA5WXgzeXRZWmxzSmtZN3FIbTJTdm1USktNTDVOVDUzRzJOSGlZMENGNEN6a3YvUEhEYzN6Zkd2bDZTbEdvTnNaNE0zVWU0Vit6NDY3WC8vWjRraG05Zjk1M1BUYjB1NnBCYXIrV2kvSDlKeHNjbUpyL0hVb20ycHEvd0RDRndPODJWQWlEWFNxRzJGdkw1bGJtQmNuWEk4LzlaRnRNTWlORlgyWTRZamQvWWpha1htMWNrbE5QVmlJd2thR0d6TWNYbXdBN1ZDcTFEZmxMbVlzZnlTMFpGZUxHbnFmQm83K0F6QzUzbWVxby9FZ2tHQStNdWFQbS9pSWV1QUZXeDZoR3pGK0pxQUxFc3l6aVhEQUVuUDhkSGRkeFdlaDQvcTdCc29CYXE0T2d4bmtZSmI5ZHludWNOd0xLczRtSk5Sa2tEa2RmK3B3c3hNbFpSTEdSenNLQlJNcmVKdXFoM2dSckFhSFE0TzQ4N2lZbVQvcll2TVpzNDcxUGRobVhjQlJOVXU4ZmIzQXFWK0RCTGoraWFmdDFEenZQWktnRVM2NHljMGVVRzZsell3dXZpTkFMd2l1UEdrY1hRTTVhRFd0WU14VEZvNVN3NXFESHdXakNJNkZTRjZFT2Q3V1RLanhrUStzZXQ5RzViRk0vYTh6UUpRWDdhOFB2cmNQdXowMGY4RmUvMEowV29DaEpWS01ncXNrMkU2SFhPbkJvb00yN1BlREJnNEpITTE3eTJvL1JNM2VaOFdlNGU2RUg5WnA0RTFacDFSUU1sM2x2SlVYb1FpTkZlUmlnSm5vMitSSnN2dCtjanh6YXZoRXBDYk1rMzIwT2NsVkhWRDRlNlFaM1daQnNPaDA0WUVRa3hIZzJiSkVCZmdlNzBtRmFOU1JnNG1uSWVSM2d1bWhaOWwwby83d2M4alBKVit0cTd2Y0NaMlFtRjR3SEQ4NERvWEJSMjArYkF4dXVwR0hzRDk3VmxZWjNLaFY2MHpQWjNoQnFEdVJrNmhPeXZYTkRPUjBmRlAxWjc3YVlOZmFESXVVNjNDcVNWNkgwZG92aGtKcmpycDJLMmV2Yjh5ZXpCRGpBMlowWEdITXRMcEhCY2gxUkpUSXZTOUwyNFloL21jTE5tWmtBVnVRdjJMZDMrVzNhSnFJOXBydEc5M2JYTy9FNy9LeGZDeGdPYi9ZRTZ6RktqK0xQNTlWenpvcXhJQXpERzNPcUdSY0RRSFArZVJtcG4zeWNvSEhPbFdlNkFEZVRBVlhWazAzUkg0dnc2bEE0Y2NydGlieGFERVh2cGQrTGhOdmxHeXNJejA4L2ZXWjNSYndrU0d4dU8yZHQ3ZUJmS3NFaWI5SCtYU3R5NW00QVlneU5Sc0VUZXJUazVuaWplVWhXUUZpcjA2bFR0Y1lML2Z4TjVIa2NkaUg3VUJEcjAyN3padE1CM1JJVDMyY3VyZkxiYUVwTWRFaWNBMjV0SzVaRWVGKzJlTk4xVm52ZzhCMHNQYXBpWWpNckxvelhaMVlLTWlwZTJtM1pqV1pQY0lSN1hIbFdGZUt4Sy9ndVc1QmhNTFlHSWtjUk11V3VPWG9ON244M2h4L0hvTEdqVW96RjJ2MS9EVS9nVER4dUQ1bWoxRVhzLy8zQzRpcWU5MEJUU3pMejBiTzN5RGNGR3U0MXJrUW5LVlVlZndWdERtMHpRdGV6WEdTZURzUmF4MFplaEg5N2o0UlE4ZTgyWjZpOWREVlByeXRpenhxSnUyZVc4NXp2dkJTenVUR1hUVFdobXAvbGxaS2hWZWduMEM1bUVJNmFnaHFuTjBUcytVTzhPMEZUM3JFY2kvcUxTVlhUYUlCM01qUklXdkpCMmdmWTQxTGw3K0ljN3JZYi9LL1RDKzI5MlFpb0Y2bVpVaHdQS1RtSkwxWjUvWTNhSHlHR2h1YXE5eHRsQjRhOCtkcTJLZ3VLdFE0dmJ1OTdsSnREZkt2NlJvZmFpN3RRZDZoK0FYeWFuQ01pNjkvNEV6cDdpTkxBempVR0ZoOWdySlNxYUdjWHBvcy9WWEIwRU1UcXlaRlBpVGN5OXplRDZ5cXlWWlQrb2lrUDJmaFRPZ0pwN0lvRzdBcnVnbUd0WW1GUVFIVlVIcXp4ZnpKcXlQTXRTWlZ3alpZaGRmYVZZZlNUUDBiVmNJbWl2SU5Kd2xOcktURzVGaWV6K0xabU1nRXI5SjgyYWtzSW0vSjJTV0loSXBKMEtJNzlyTUdtMDZFdlQxVDV1T3FYWnVZTzVjekEvaWcrd3pmUkhmMjY0aGtFZmFwTnVabENUZkFCNXNmbHdidHF3RjZwY3UxZ1lNWWtPaVlQbGwvaFpMY05PcHlmMWRWeldSMUprVzNjQ0NiYzh4ajFjaHRHNElBZG5MRElTYzNjWkNKZVRUTkdvdWNESDYzQ0h4dUhPRzR0MDBzb1Q2NkloVUdpcitHdkd3ZjdQdHpZdllBTXVwa0hka3JNTFNKenNxWWpTNHFzQ0orRkU4dGFQR2JDckpRQjl1MjcwRnVsbjBYQmpHL3dVRlVGRzNYcW1XWFUrdVVKbzFncGQrOFdPV3N4cEpPQXdhV3FTcFQxRUdiakF4V091V09pU0ZEMURtSzg3TGlNUEpZb1dsckJRTGV4UnU1cXFmNmM5UWFXNDJleHFIeDM0M21sRStPTnV4ejJrcTFGcXc1R1FocUtCbE40bFRmZVJqVVdtMkJJemM2bk9MOEg0UzBvSFFOM1RQajhqL2VaWSswcVFFVnRYeWtnM1lQN3pTNE5ORmZpQWpmSWw1dVhpeTNidUZFTUM2WFNKblZoMnhjd01YaGliOWlTblYvRjN1NDFMenVYRnpWSmFjdnVtdkM2NEhRYUVYbzk5am5zcUcwc3VFWTNneEpqQnhkQzJZamFQUi9STmwySHFQSmdzN3l1ZTd0c1BRa3R0aW1ZL1NqZmJpOTY4UkFtQnZSVFEvbysvalNPRVZ3R294eHpsUWlXSjRobmhXRmNOY2IwcEFiNUIwSnhaUTdSbkIwMnptSFlMVVZkWHl1YXRnUmQ4QjNnbzl2QS9FeThJemRUdGN5N29hK0VBNEw5alYxWlFlbG5Ua1kyNFRrSXBZMFBhR2xaT2xlZ2gyaERjODVhMzlFOTZjaVd6NDd5ZGtBTndYU0FtRlQ0b2d1MlFCcWtGS095WG42eWRxWW5iZjlKVGhIVnJFREs5eFdWMnRkUXAvbHh3VnpyZVIrSnZ1MDcvM1EvdU00N1pGdE1Hak9xOHhxTENLbkVZQXArVENuZVViRWdnZnh3QndvM0dYd01lbldiOElpYy9UN0FsN2MwU2N3b0xOcytIZ1VzRXNWYTdEVGJacitNM05QVDRQMlZ6eGdZRXNpWGVIbWQrQkIzR1czVUg4VUorQU5ZVURwVEVkS2ZEQWtjRDdhQ25WeXZlVFI4U3FYMWpFejZQL3hMSDRJR0U2YjBTV25jdkhyR1Nja1UyTVJqYUJZelhwcEI0SlVJdmZaRzVwMWFWRlNhUk1GOFNmSW00WDhrTWV0cGQvUm5PU09EUERKOUVuZzlUZHZnVWd3NHVlZUk0YUJDZms3alJod0JhenFxdEtDcGloYjBlVTM2Q05jbENpZVV5TTNKeXhpR3Npc1phR0FFdTBZZWRJTHBMUHRTREhrQ0VLL1F4dENTdTIwU2xCNEdycGFxTXFxTzJaQU1jSFlUTm5FS0RHWCtIVTBnLzVyNDd2aVhzemV1R3dSS3JEWkl1QUlLcUhZUWZQTTNPbnRHb2o4R0RYdCthN1VYSm85SlhacUYyNVFSNzJXMi9JL1MxU1grMFlQQVdaVDA1bzRpVzdFSnNMT0NmbXY4eS96eFhoZzdjWmpDWVAveGFDUlZGSlpSQWwybWV5dkNGZ2ova0syR2l1VUN2WVNTSlBsN0VDMU1SMjdGQ0RCQVJZQi90M01VRjJhbjNudlFlZnNWSDVXd3VjZG5yR1pTOXRLMlc2RzhOSHRoZldqU1BjWVRuTUVWZHlPdUZjWHkvdnRsWnp4VURsNzdWdkg2Z0l4bXVHS1pQVHVlTGg0VDRaUkRKcXJyaWM5WkZzOGgzU295anA5aE0yZmk1dm53UnlGNWkvdzdjaThKZm4yRDhxNTVFVkFMS1ZrY3BoclRuRWxxVjY1Vm1kcmdIRnBxYmowc2EyZW9tYUhQWkxoZktJQVFINkpoU1h1Wm5kOUtHSTZDSmVkOGZxbTloQXpGL0V3SmQwYVg1bHNRUmpsM3pjaE94clZmeWJ5QmhxUnA4cVgzK0lmZWFqM0FPZDJQWXBlYlFoaWY4ZUVPM2p1aERId1IrOGo0VHIvcGZkRDQrSnQyNVZlS3R6WDA5Y2ljejd0aHFIcVllU0lnc0FSeVZXeC8wV2tjRVJuWW14RUx0ejRMOEI3RzhEbDcreHRSOEJkRGptQk42RVM1b2piTGFUUGFZamdhSEhVWFh3aHg5TnMzclJsMEVCNTFOVGorb3dlN2hBeXJCS0FUMzhmN2kzVmpQdkpVdFF6Uy94VzNGUlVyUkJ6eEg0WnhrNy94ZHhNWCtEZzF1SUwrWG1GaHAxTGorbndlTWdJVkpOY25KUEI2bjFYTThrZHVWSVoxbldVWG9OaWhaY25hdjdpbGlsM0pJd2FaYU11SDZBRTl6R3RHak83NDhZK1FveXRQWHM1QU5XdkJnRFFhdU5MTkNQZXJQbDFpVVRsWEVCQ2ljTmRFb0ZncEFrcm5IWDh5OStqUkc4bmsrMkJrV0JQTHVrOGcrRHd1MXBlUTE1Y1VzVFFaV2RVYVZBa1pGSnlSUi92OXo5NVBKT1VtU1RXd2xPbmlvTENSWXRIRHB0TnBtcG9yNTNFak1GUytpWUhOZ2FqeFhjWkZObnVINDBYMFlBVGZidExRVXR5RW8zNnd0a2FOZGw4dURPYlV4YWZhWW00ZjdrTWpPN01tc1Bnc04zMTJ5SU54S3hjVmM3YTIwVVc5WUExSGZDZzkyMDNpN0dNQ3BOc3hFRjhFV2RhZ2YzTk9WYlFKZmRDWXZJejF0N3lpS0ZHak5FSUJBQUFBQUFBQTVBQUFBQUFBQUFDTkRQenhpQlNDcy96Z1YyYUVMMGRlSWRielgzbTRIY2g5T0d2cXFxVStGeHoyTmlISHR3RTkwL25JYXZHbEJnQUJBRUhNaFFJTHFRT0pBQUFBQUFBQUFJc0FBSUFBQUFBQWdJQUFnQUVBQUFDTEFBQUFBUUFBQUFDQUFBQUJBQUFBaUlBQWdBRUFBQUNDQUFDQUFBQUFBQXNBQUFBQUFBQUFDZ0FBQUFFQUFBQ0NnQUFBQUFBQUFBT0FBQUFCQUFBQWk0QUFBQUVBQUFBTEFBQ0FBUUFBQUlvQUFJQUJBQUFBZ1FBQWdBQUFBQUNCQUFDQUFBQUFBQWdBQUlBQUFBQUFnd0FBQUFBQUFBQURnQUNBQVFBQUFJaUFBSUFBQUFBQWlBQUFnQUVBQUFBQWdBQUFBQUFBQUlLQUFJRC9BQUFBTFNzZ0lDQXdXREI0QUMwd1dDc3dXQ0F3V0Mwd2VDc3dlQ0F3ZUFBdlpHVjJMM04wWkc5MWRBQkxZVzVuWVhKdmIxUjNaV3gyWlY5R1gwRmljMjl5WWt4aGMzUkdaWGRDYVhSekFDOWtaWFl2YzNSa1pYSnlBQzlrWlhZdmMzUmthVzRBYm1GdUFDOWtaWFl2ZFhKaGJtUnZiUUJwYm1ZQWJHbGlMMHRoYm1kaGNtOXZWSGRsYkhabExtTUFTMkZ1WjJGeWIyOVVkMlZzZG1WZlJsOUJZbk52Y21JQVRrRk9BRWxPUmdCcGJuTjBZVzVqWlMwK2MzRjFaV1Y2YVc1bklEMDlJREFBTGdBb2JuVnNiQ2tBUVhOelpYSjBhVzl1SUdaaGFXeGxaRG9nSlhNZ0tDVnpPaUFsY3pvZ0pXUXBDZ0JCZ0lrQ0MwRVpBQW9BR1JrWkFBQUFBQVVBQUFBQUFBQUpBQUFBQUFzQUFBQUFBQUFBQUJrQUVRb1pHUmtEQ2djQUFRQUpDeGdBQUFrR0N3QUFDd0FHR1FBQUFCa1pHUUJCMFlrQ0N5RU9BQUFBQUFBQUFBQVpBQW9OR1JrWkFBMEFBQUlBQ1E0QUFBQUpBQTRBQUE0QVFZdUtBZ3NCREFCQmw0b0NDeFVUQUFBQUFCTUFBQUFBQ1F3QUFBQUFBQXdBQUF3QVFjV0tBZ3NCRUFCQjBZb0NDeFVQQUFBQUJBOEFBQUFBQ1JBQUFBQUFBQkFBQUJBQVFmK0tBZ3NCRWdCQmk0c0NDeDRSQUFBQUFCRUFBQUFBQ1JJQUFBQUFBQklBQUJJQUFCb0FBQUFhR2hvQVFjS0xBZ3NPR2dBQUFCb2FHZ0FBQUFBQUFBa0FRZk9MQWdzQkZBQkIvNHNDQ3hVWEFBQUFBQmNBQUFBQUNSUUFBQUFBQUJRQUFCUUFRYTJNQWdzQkZnQkJ1WXdDQ3ljVkFBQUFBQlVBQUFBQUNSWUFBQUFBQUJZQUFCWUFBREF4TWpNME5UWTNPRGxCUWtORVJVWUFRZUNNQWd1SkJVOTlHcDNnaHBZbFpyMm01cXlDVnZmZjVTdnF4YlZiL0FjQUFBQUFBQUFBKzNwaTNZUWR1dEdOalVZUFdEWFNLNG9QYktwTXNOU1BBd0FBQUFBQUFBQThJSXhuTXhvcG13S3AzR1hKMWl2RTlyci9DNDIvT05BQUFBQUFBQUFBQU1EOTUzZHJadVVTZ2oyWUZEZmN5NEVRaEMyaWR6Z0hHd01BQUFBQUFBQUF3M1RPNjN6VjNIUU0wdm82TE41a0dSSUFBQUFBQUFBQURBQUFBQUFBQUFCREFRQUFBQUFBQU9RQUFBQUFBQUFBY3ZNRERuZnJmVXdESDZpWmU5QzRJUWtBQUFBQUFBQUFCZ0FBQUFBQUFBQmhPdWQxdm1wdU9nWnBmUjBXYjdKTTl2Ly8vLy8vLy8vNS8vLy8vLy8vZjU3RkdJcEJsWkhGK1phQzR1bVFUVFB2UnVOblIzL3c3UUpLMVlPYW52a3FPZ0VBQUFBQUFBRGVBQUFBQUFBQUFEVHd6ZDdacHNxZVVvWUZJK3RBcDBvUkFBQUFBQUFBQVBULy8vLy8vLzkvQXdBQUFBQUFBQUFEQUFBQUFBQUFBRlZvN0RxU2pBbWhwQzZXcDFjRVJCSURBQUFBQUFBQUFBSUFBQUFBQUFBQXBDNldwMWNFUkpJcU5IWWRTY2FFVUFjQUFBQUFBQUFBQlFBQUFBQUFBQUQ1bG9MaTZaQk5NODlpRE1XZ3lzaGlGUUFBQUFBQUFBQVBBQUFBQUFBQUFKSHpIVThWdHl3c21GeWJiQ3NtMzNqMy8vLy8vLy8vL3dVQUFBQUFBQUFBR3ZobTcyeFRaVThwdzRLUmRhQlRKZkFBQUFBQUFBQUFxZ0FBQUFBQUFBRHdEbDByV0ZIaVJPWExGZ09HbjFJZjd3c0FBQUFBQUFCd0NBQUFBQUFBQUFVbGJwZElQazBCV3pjQS9wd3UxUThZQUFBQUFBQUFBQklBQUFBQUFBQUE1MXNLaXFkRE5zMDhpekVVZ3lvakN5TUFBQUFBQUFBQUdBQUFBQUFBQUFBYWVFaGZBNFBCWmhycTRwa2N2R001RHdBQUFBQUFBQUFLQUFBQUFBQUFBUE10QmNYVEladG1uc1VZaWtHVmtVWC8vLy8vSUl4UUFBVUFRZlNSQWdzQkFnQkJqSklDQ3dvREFBQUFCQUFBQUhTTEFFR2trZ0lMQVFJQVFiU1NBZ3NJLy8vLy8vLy8vLzg9JztcblxudmFyIE1vZHVsZSA9IHR5cGVvZiBNb2R1bGUgIT09ICd1bmRlZmluZWQnID8gTW9kdWxlIDoge307XG52YXIgbW9kdWxlT3ZlcnJpZGVzID0ge307XG52YXIga2V5O1xuZm9yIChrZXkgaW4gTW9kdWxlKSB7XG4gIGlmIChNb2R1bGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgIG1vZHVsZU92ZXJyaWRlc1trZXldID0gTW9kdWxlW2tleV07XG4gIH1cbn1cbnZhciBhcmd1bWVudHNfID0gW107XG52YXIgdGhpc1Byb2dyYW0gPSAnLi90aGlzLnByb2dyYW0nO1xudmFyIHF1aXRfID0gZnVuY3Rpb24gKHN0YXR1cywgdG9UaHJvdykge1xuICB0aHJvdyB0b1Rocm93O1xufTtcbnZhciBFTlZJUk9OTUVOVF9JU19XRUIgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JztcbnZhciBFTlZJUk9OTUVOVF9JU19XT1JLRVIgPSB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJztcbnZhciBFTlZJUk9OTUVOVF9JU19OT0RFID1cbiAgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zID09PSAnb2JqZWN0JyAmJlxuICB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlID09PSAnc3RyaW5nJztcbnZhciBzY3JpcHREaXJlY3RvcnkgPSAnJztcbi8qKlxuICogQHBhcmFtIHBhdGhcbiAqL1xuZnVuY3Rpb24gbG9jYXRlRmlsZShwYXRoKSB7XG4gIGlmIChNb2R1bGVbJ2xvY2F0ZUZpbGUnXSkge1xuICAgIHJldHVybiBNb2R1bGVbJ2xvY2F0ZUZpbGUnXShwYXRoLCBzY3JpcHREaXJlY3RvcnkpO1xuICB9XG4gIHJldHVybiBzY3JpcHREaXJlY3RvcnkgKyBwYXRoO1xufVxudmFyIHJlYWRfLCByZWFkQXN5bmMsIHJlYWRCaW5hcnksIHNldFdpbmRvd1RpdGxlO1xuXG4vKipcbiAqIEBwYXJhbSBlXG4gKi9cbmZ1bmN0aW9uIGxvZ0V4Y2VwdGlvbk9uRXhpdChlKSB7XG4gIGlmIChlIGluc3RhbmNlb2YgRXhpdFN0YXR1cykgcmV0dXJuO1xuICB2YXIgdG9Mb2cgPSBlO1xuICBlcnIoJ2V4aXRpbmcgZHVlIHRvIGV4Y2VwdGlvbjogJyArIHRvTG9nKTtcbn1cbnZhciBub2RlRlM7XG52YXIgbm9kZVBhdGg7XG4vLyBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuLy8gICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4vLyAgICAgc2NyaXB0RGlyZWN0b3J5ID0gcmVxdWlyZSgncGF0aCcpLmRpcm5hbWUoc2NyaXB0RGlyZWN0b3J5KSArICcvJztcbi8vICAgfSBlbHNlIHtcbi8vICAgICBzY3JpcHREaXJlY3RvcnkgPSAnLyc7XG4vLyAgIH1cbi8vICAgcmVhZF8gPSBmdW5jdGlvbiBzaGVsbF9yZWFkKGZpbGVuYW1lLCBiaW5hcnkpIHtcbi8vICAgICBpZiAoIW5vZGVGUykgbm9kZUZTID0gcmVxdWlyZSgnZnMnKTtcbi8vICAgICBpZiAoIW5vZGVQYXRoKSBub2RlUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbi8vICAgICBmaWxlbmFtZSA9IG5vZGVQYXRoWydub3JtYWxpemUnXShmaWxlbmFtZSk7XG4vLyAgICAgcmV0dXJuIG5vZGVGU1sncmVhZEZpbGVTeW5jJ10oZmlsZW5hbWUsIGJpbmFyeSA/IG51bGwgOiAndXRmOCcpO1xuLy8gICB9O1xuLy8gICByZWFkQmluYXJ5ID0gZnVuY3Rpb24gcmVhZEJpbmFyeShmaWxlbmFtZSkge1xuLy8gICAgIHZhciByZXQgPSByZWFkXyhmaWxlbmFtZSwgdHJ1ZSk7XG4vLyAgICAgaWYgKCFyZXQuYnVmZmVyKSB7XG4vLyAgICAgICByZXQgPSBuZXcgVWludDhBcnJheShyZXQpO1xuLy8gICAgIH1cbi8vICAgICBhc3NlcnQocmV0LmJ1ZmZlcik7XG4vLyAgICAgcmV0dXJuIHJldDtcbi8vICAgfTtcbi8vICAgcmVhZEFzeW5jID0gZnVuY3Rpb24gcmVhZEFzeW5jKGZpbGVuYW1lLCBvbmxvYWQsIG9uZXJyb3IpIHtcbi8vICAgICBpZiAoIW5vZGVGUykgbm9kZUZTID0gcmVxdWlyZSgnZnMnKTtcbi8vICAgICBpZiAoIW5vZGVQYXRoKSBub2RlUGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbi8vICAgICBmaWxlbmFtZSA9IG5vZGVQYXRoWydub3JtYWxpemUnXShmaWxlbmFtZSk7XG4vLyAgICAgbm9kZUZTWydyZWFkRmlsZSddKGZpbGVuYW1lLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4vLyAgICAgICBpZiAoZXJyKSBvbmVycm9yKGVycik7XG4vLyAgICAgICBlbHNlIG9ubG9hZChkYXRhLmJ1ZmZlcik7XG4vLyAgICAgfSk7XG4vLyAgIH07XG4vLyAgIGlmIChwcm9jZXNzWydhcmd2J10ubGVuZ3RoID4gMSkge1xuLy8gICAgIHRoaXNQcm9ncmFtID0gcHJvY2Vzc1snYXJndiddWzFdLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbi8vICAgfVxuLy8gICBhcmd1bWVudHNfID0gcHJvY2Vzc1snYXJndiddLnNsaWNlKDIpO1xuLy8gICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbi8vICAgICBtb2R1bGVbJ2V4cG9ydHMnXSA9IE1vZHVsZTtcbi8vICAgfVxuLy8gICBwcm9jZXNzWydvbiddKCd1bmNhdWdodEV4Y2VwdGlvbicsIGZ1bmN0aW9uIChleCkge1xuLy8gICAgIGlmICghKGV4IGluc3RhbmNlb2YgRXhpdFN0YXR1cykpIHtcbi8vICAgICAgIHRocm93IGV4O1xuLy8gICAgIH1cbi8vICAgfSk7XG4vLyAgIHByb2Nlc3NbJ29uJ10oJ3VuaGFuZGxlZFJlamVjdGlvbicsIGZ1bmN0aW9uIChyZWFzb24pIHtcbi8vICAgICB0aHJvdyByZWFzb247XG4vLyAgIH0pO1xuLy8gICBxdWl0XyA9IGZ1bmN0aW9uIChzdGF0dXMsIHRvVGhyb3cpIHtcbi8vICAgICBpZiAoa2VlcFJ1bnRpbWVBbGl2ZSgpKSB7XG4vLyAgICAgICBwcm9jZXNzWydleGl0Q29kZSddID0gc3RhdHVzO1xuLy8gICAgICAgdGhyb3cgdG9UaHJvdztcbi8vICAgICB9XG4vLyAgICAgbG9nRXhjZXB0aW9uT25FeGl0KHRvVGhyb3cpO1xuLy8gICAgIHByb2Nlc3NbJ2V4aXQnXShzdGF0dXMpO1xuLy8gICB9O1xuLy8gICBNb2R1bGVbJ2luc3BlY3QnXSA9IGZ1bmN0aW9uICgpIHtcbi8vICAgICByZXR1cm4gJ1tFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdJztcbi8vICAgfTtcbi8vIH0gZWxzZVxuaWYgKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHtcbiAgaWYgKEVOVklST05NRU5UX0lTX1dPUktFUikge1xuICAgIHNjcmlwdERpcmVjdG9yeSA9IHNlbGYubG9jYXRpb24uaHJlZjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHtcbiAgICBzY3JpcHREaXJlY3RvcnkgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYztcbiAgfVxuICBpZiAoc2NyaXB0RGlyZWN0b3J5LmluZGV4T2YoJ2Jsb2I6JykgIT09IDApIHtcbiAgICBzY3JpcHREaXJlY3RvcnkgPSBzY3JpcHREaXJlY3Rvcnkuc3Vic3RyKFxuICAgICAgMCxcbiAgICAgIHNjcmlwdERpcmVjdG9yeS5yZXBsYWNlKC9bPyNdLiovLCAnJykubGFzdEluZGV4T2YoJy8nKSArIDFcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHNjcmlwdERpcmVjdG9yeSA9ICcnO1xuICB9XG4gIHtcbiAgICByZWFkXyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcbiAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVRleHQ7XG4gICAgfTtcbiAgICBpZiAoRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7XG4gICAgICByZWFkQmluYXJ5ID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJlYWRBc3luYyA9IGZ1bmN0aW9uICh1cmwsIG9ubG9hZCwgb25lcnJvcikge1xuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh4aHIuc3RhdHVzID09IDIwMCB8fCAoeGhyLnN0YXR1cyA9PSAwICYmIHhoci5yZXNwb25zZSkpIHtcbiAgICAgICAgICBvbmxvYWQoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25lcnJvcigpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gb25lcnJvcjtcbiAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgIH07XG4gIH1cbiAgc2V0V2luZG93VGl0bGUgPSBmdW5jdGlvbiAodGl0bGUpIHtcbiAgICBkb2N1bWVudC50aXRsZSA9IHRpdGxlO1xuICB9O1xufSBlbHNlIHtcbn1cbnZhciBvdXQgPSBNb2R1bGVbJ3ByaW50J10gfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbnZhciBlcnIgPSBNb2R1bGVbJ3ByaW50RXJyJ10gfHwgY29uc29sZS53YXJuLmJpbmQoY29uc29sZSk7XG5mb3IgKGtleSBpbiBtb2R1bGVPdmVycmlkZXMpIHtcbiAgaWYgKG1vZHVsZU92ZXJyaWRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgTW9kdWxlW2tleV0gPSBtb2R1bGVPdmVycmlkZXNba2V5XTtcbiAgfVxufVxubW9kdWxlT3ZlcnJpZGVzID0gbnVsbDtcbmlmIChNb2R1bGVbJ2FyZ3VtZW50cyddKSBhcmd1bWVudHNfID0gTW9kdWxlWydhcmd1bWVudHMnXTtcbmlmIChNb2R1bGVbJ3RoaXNQcm9ncmFtJ10pIHRoaXNQcm9ncmFtID0gTW9kdWxlWyd0aGlzUHJvZ3JhbSddO1xuaWYgKE1vZHVsZVsncXVpdCddKSBxdWl0XyA9IE1vZHVsZVsncXVpdCddO1xudmFyIHdhc21CaW5hcnk7XG5pZiAoTW9kdWxlWyd3YXNtQmluYXJ5J10pIHdhc21CaW5hcnkgPSBNb2R1bGVbJ3dhc21CaW5hcnknXTtcbnZhciBub0V4aXRSdW50aW1lID0gTW9kdWxlWydub0V4aXRSdW50aW1lJ10gfHwgdHJ1ZTtcbmlmICh0eXBlb2YgV2ViQXNzZW1ibHkgIT09ICdvYmplY3QnKSB7XG4gIGFib3J0KCdubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkJyk7XG59XG52YXIgd2FzbU1lbW9yeTtcbnZhciBBQk9SVCA9IGZhbHNlO1xudmFyIEVYSVRTVEFUVVM7XG5cbi8qKlxuICogQHBhcmFtIGNvbmRpdGlvblxuICogQHBhcmFtIHRleHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgdGV4dCkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIGFib3J0KCdBc3NlcnRpb24gZmFpbGVkOiAnICsgdGV4dCk7XG4gIH1cbn1cbnZhciBVVEY4RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBAcGFyYW0gaGVhcFxuICogQHBhcmFtIGlkeFxuICogQHBhcmFtIG1heEJ5dGVzVG9SZWFkXG4gKi9cbmZ1bmN0aW9uIFVURjhBcnJheVRvU3RyaW5nKGhlYXAsIGlkeCwgbWF4Qnl0ZXNUb1JlYWQpIHtcbiAgdmFyIGVuZElkeCA9IGlkeCArIG1heEJ5dGVzVG9SZWFkO1xuICB2YXIgZW5kUHRyID0gaWR4O1xuICB3aGlsZSAoaGVhcFtlbmRQdHJdICYmICEoZW5kUHRyID49IGVuZElkeCkpICsrZW5kUHRyO1xuICBpZiAoZW5kUHRyIC0gaWR4ID4gMTYgJiYgaGVhcC5zdWJhcnJheSAmJiBVVEY4RGVjb2Rlcikge1xuICAgIHJldHVybiBVVEY4RGVjb2Rlci5kZWNvZGUoaGVhcC5zdWJhcnJheShpZHgsIGVuZFB0cikpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICB3aGlsZSAoaWR4IDwgZW5kUHRyKSB7XG4gICAgICB2YXIgdTAgPSBoZWFwW2lkeCsrXTtcbiAgICAgIGlmICghKHUwICYgMTI4KSkge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHUxID0gaGVhcFtpZHgrK10gJiA2MztcbiAgICAgIGlmICgodTAgJiAyMjQpID09IDE5Mikge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKHUwICYgMzEpIDw8IDYpIHwgdTEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciB1MiA9IGhlYXBbaWR4KytdICYgNjM7XG4gICAgICBpZiAoKHUwICYgMjQwKSA9PSAyMjQpIHtcbiAgICAgICAgdTAgPSAoKHUwICYgMTUpIDw8IDEyKSB8ICh1MSA8PCA2KSB8IHUyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdTAgPSAoKHUwICYgNykgPDwgMTgpIHwgKHUxIDw8IDEyKSB8ICh1MiA8PCA2KSB8IChoZWFwW2lkeCsrXSAmIDYzKTtcbiAgICAgIH1cbiAgICAgIGlmICh1MCA8IDY1NTM2KSB7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaCA9IHUwIC0gNjU1MzY7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgKGNoID4+IDEwKSwgNTYzMjAgfCAoY2ggJiAxMDIzKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogQHBhcmFtIHB0clxuICogQHBhcmFtIG1heEJ5dGVzVG9SZWFkXG4gKi9cbmZ1bmN0aW9uIFVURjhUb1N0cmluZyhwdHIsIG1heEJ5dGVzVG9SZWFkKSB7XG4gIHJldHVybiBwdHIgPyBVVEY4QXJyYXlUb1N0cmluZyhIRUFQVTgsIHB0ciwgbWF4Qnl0ZXNUb1JlYWQpIDogJyc7XG59XG5cbi8qKlxuICogQHBhcmFtIHN0clxuICogQHBhcmFtIGhlYXBcbiAqIEBwYXJhbSBvdXRJZHhcbiAqIEBwYXJhbSBtYXhCeXRlc1RvV3JpdGVcbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBoZWFwLCBvdXRJZHgsIG1heEJ5dGVzVG9Xcml0ZSkge1xuICBpZiAoIShtYXhCeXRlc1RvV3JpdGUgPiAwKSkgcmV0dXJuIDA7XG4gIHZhciBzdGFydElkeCA9IG91dElkeDtcbiAgdmFyIGVuZElkeCA9IG91dElkeCArIG1heEJ5dGVzVG9Xcml0ZSAtIDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAodSA+PSA1NTI5NiAmJiB1IDw9IDU3MzQzKSB7XG4gICAgICB2YXIgdTEgPSBzdHIuY2hhckNvZGVBdCgrK2kpO1xuICAgICAgdSA9ICg2NTUzNiArICgodSAmIDEwMjMpIDw8IDEwKSkgfCAodTEgJiAxMDIzKTtcbiAgICB9XG4gICAgaWYgKHUgPD0gMTI3KSB7XG4gICAgICBpZiAob3V0SWR4ID49IGVuZElkeCkgYnJlYWs7XG4gICAgICBoZWFwW291dElkeCsrXSA9IHU7XG4gICAgfSBlbHNlIGlmICh1IDw9IDIwNDcpIHtcbiAgICAgIGlmIChvdXRJZHggKyAxID49IGVuZElkeCkgYnJlYWs7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDE5MiB8ICh1ID4+IDYpO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAxMjggfCAodSAmIDYzKTtcbiAgICB9IGVsc2UgaWYgKHUgPD0gNjU1MzUpIHtcbiAgICAgIGlmIChvdXRJZHggKyAyID49IGVuZElkeCkgYnJlYWs7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDIyNCB8ICh1ID4+IDEyKTtcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gMTI4IHwgKCh1ID4+IDYpICYgNjMpO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAxMjggfCAodSAmIDYzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG91dElkeCArIDMgPj0gZW5kSWR4KSBicmVhaztcbiAgICAgIGhlYXBbb3V0SWR4KytdID0gMjQwIHwgKHUgPj4gMTgpO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAxMjggfCAoKHUgPj4gMTIpICYgNjMpO1xuICAgICAgaGVhcFtvdXRJZHgrK10gPSAxMjggfCAoKHUgPj4gNikgJiA2Myk7XG4gICAgICBoZWFwW291dElkeCsrXSA9IDEyOCB8ICh1ICYgNjMpO1xuICAgIH1cbiAgfVxuICBoZWFwW291dElkeF0gPSAwO1xuICByZXR1cm4gb3V0SWR4IC0gc3RhcnRJZHg7XG59XG5cbi8qKlxuICogQHBhcmFtIHN0clxuICogQHBhcmFtIG91dFB0clxuICogQHBhcmFtIG1heEJ5dGVzVG9Xcml0ZVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb1VURjgoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkge1xuICByZXR1cm4gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQVTgsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gc3RyXG4gKi9cbmZ1bmN0aW9uIGxlbmd0aEJ5dGVzVVRGOChzdHIpIHtcbiAgdmFyIGxlbiA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBpZiAodSA+PSA1NTI5NiAmJiB1IDw9IDU3MzQzKSB1ID0gKDY1NTM2ICsgKCh1ICYgMTAyMykgPDwgMTApKSB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMTAyMyk7XG4gICAgaWYgKHUgPD0gMTI3KSArK2xlbjtcbiAgICBlbHNlIGlmICh1IDw9IDIwNDcpIGxlbiArPSAyO1xuICAgIGVsc2UgaWYgKHUgPD0gNjU1MzUpIGxlbiArPSAzO1xuICAgIGVsc2UgbGVuICs9IDQ7XG4gIH1cbiAgcmV0dXJuIGxlbjtcbn1cbnZhciBidWZmZXIsIEhFQVA4LCBIRUFQVTgsIEhFQVAxNiwgSEVBUFUxNiwgSEVBUDMyLCBIRUFQVTMyLCBIRUFQRjMyLCBIRUFQRjY0O1xuXG4vKipcbiAqIEBwYXJhbSBidWZcbiAqL1xuZnVuY3Rpb24gdXBkYXRlR2xvYmFsQnVmZmVyQW5kVmlld3MoYnVmKSB7XG4gIGJ1ZmZlciA9IGJ1ZjtcbiAgTW9kdWxlWydIRUFQOCddID0gSEVBUDggPSBuZXcgSW50OEFycmF5KGJ1Zik7XG4gIE1vZHVsZVsnSEVBUDE2J10gPSBIRUFQMTYgPSBuZXcgSW50MTZBcnJheShidWYpO1xuICBNb2R1bGVbJ0hFQVAzMiddID0gSEVBUDMyID0gbmV3IEludDMyQXJyYXkoYnVmKTtcbiAgTW9kdWxlWydIRUFQVTgnXSA9IEhFQVBVOCA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gIE1vZHVsZVsnSEVBUFUxNiddID0gSEVBUFUxNiA9IG5ldyBVaW50MTZBcnJheShidWYpO1xuICBNb2R1bGVbJ0hFQVBVMzInXSA9IEhFQVBVMzIgPSBuZXcgVWludDMyQXJyYXkoYnVmKTtcbiAgTW9kdWxlWydIRUFQRjMyJ10gPSBIRUFQRjMyID0gbmV3IEZsb2F0MzJBcnJheShidWYpO1xuICBNb2R1bGVbJ0hFQVBGNjQnXSA9IEhFQVBGNjQgPSBuZXcgRmxvYXQ2NEFycmF5KGJ1Zik7XG59XG52YXIgSU5JVElBTF9NRU1PUlkgPSBNb2R1bGVbJ0lOSVRJQUxfTUVNT1JZJ10gfHwgMTY3NzcyMTY7XG52YXIgd2FzbVRhYmxlO1xudmFyIF9fQVRQUkVSVU5fXyA9IFtdO1xudmFyIF9fQVRJTklUX18gPSBbXTtcbnZhciBfX0FUTUFJTl9fID0gW107XG52YXIgX19BVFBPU1RSVU5fXyA9IFtdO1xudmFyIHJ1bnRpbWVJbml0aWFsaXplZCA9IGZhbHNlO1xudmFyIHJ1bnRpbWVFeGl0ZWQgPSBmYWxzZTtcbnZhciBydW50aW1lS2VlcGFsaXZlQ291bnRlciA9IDA7XG5cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24ga2VlcFJ1bnRpbWVBbGl2ZSgpIHtcbiAgcmV0dXJuIG5vRXhpdFJ1bnRpbWUgfHwgcnVudGltZUtlZXBhbGl2ZUNvdW50ZXIgPiAwO1xufVxuXG4vKipcbiAqXG4gKi9cbmZ1bmN0aW9uIHByZVJ1bigpIHtcbiAgaWYgKE1vZHVsZVsncHJlUnVuJ10pIHtcbiAgICBpZiAodHlwZW9mIE1vZHVsZVsncHJlUnVuJ10gPT0gJ2Z1bmN0aW9uJykgTW9kdWxlWydwcmVSdW4nXSA9IFtNb2R1bGVbJ3ByZVJ1biddXTtcbiAgICB3aGlsZSAoTW9kdWxlWydwcmVSdW4nXS5sZW5ndGgpIHtcbiAgICAgIGFkZE9uUHJlUnVuKE1vZHVsZVsncHJlUnVuJ10uc2hpZnQoKSk7XG4gICAgfVxuICB9XG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyk7XG59XG5cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24gaW5pdFJ1bnRpbWUoKSB7XG4gIHJ1bnRpbWVJbml0aWFsaXplZCA9IHRydWU7XG4gIGlmICghTW9kdWxlWydub0ZTSW5pdCddICYmICFGUy5pbml0LmluaXRpYWxpemVkKSBGUy5pbml0KCk7XG4gIEZTLmlnbm9yZVBlcm1pc3Npb25zID0gZmFsc2U7XG4gIFRUWS5pbml0KCk7XG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRJTklUX18pO1xufVxuXG4vKipcbiAqXG4gKi9cbmZ1bmN0aW9uIHByZU1haW4oKSB7XG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRNQUlOX18pO1xufVxuXG4vKipcbiAqXG4gKi9cbmZ1bmN0aW9uIGV4aXRSdW50aW1lKCkge1xuICBydW50aW1lRXhpdGVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKlxuICovXG5mdW5jdGlvbiBwb3N0UnVuKCkge1xuICBpZiAoTW9kdWxlWydwb3N0UnVuJ10pIHtcbiAgICBpZiAodHlwZW9mIE1vZHVsZVsncG9zdFJ1biddID09ICdmdW5jdGlvbicpIE1vZHVsZVsncG9zdFJ1biddID0gW01vZHVsZVsncG9zdFJ1biddXTtcbiAgICB3aGlsZSAoTW9kdWxlWydwb3N0UnVuJ10ubGVuZ3RoKSB7XG4gICAgICBhZGRPblBvc3RSdW4oTW9kdWxlWydwb3N0UnVuJ10uc2hpZnQoKSk7XG4gICAgfVxuICB9XG4gIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQT1NUUlVOX18pO1xufVxuXG4vKipcbiAqIEBwYXJhbSBjYlxuICovXG5mdW5jdGlvbiBhZGRPblByZVJ1bihjYikge1xuICBfX0FUUFJFUlVOX18udW5zaGlmdChjYik7XG59XG5cbi8qKlxuICogQHBhcmFtIGNiXG4gKi9cbmZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYikge1xuICBfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpO1xufVxudmFyIHJ1bkRlcGVuZGVuY2llcyA9IDA7XG52YXIgcnVuRGVwZW5kZW5jeVdhdGNoZXIgPSBudWxsO1xudmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIGlkXG4gKi9cbmZ1bmN0aW9uIGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koaWQpIHtcbiAgcmV0dXJuIGlkO1xufVxuXG4vKipcbiAqIEBwYXJhbSBpZFxuICovXG5mdW5jdGlvbiBhZGRSdW5EZXBlbmRlbmN5KGlkKSB7XG4gIHJ1bkRlcGVuZGVuY2llcysrO1xuICBpZiAoTW9kdWxlWydtb25pdG9yUnVuRGVwZW5kZW5jaWVzJ10pIHtcbiAgICBNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXShydW5EZXBlbmRlbmNpZXMpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIGlkXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpIHtcbiAgcnVuRGVwZW5kZW5jaWVzLS07XG4gIGlmIChNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXSkge1xuICAgIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKHJ1bkRlcGVuZGVuY2llcyk7XG4gIH1cbiAgaWYgKHJ1bkRlcGVuZGVuY2llcyA9PSAwKSB7XG4gICAgaWYgKHJ1bkRlcGVuZGVuY3lXYXRjaGVyICE9PSBudWxsKSB7XG4gICAgICBjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtcbiAgICAgIHJ1bkRlcGVuZGVuY3lXYXRjaGVyID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRlcGVuZGVuY2llc0Z1bGZpbGxlZCkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gZGVwZW5kZW5jaWVzRnVsZmlsbGVkO1xuICAgICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG59XG5Nb2R1bGVbJ3ByZWxvYWRlZEltYWdlcyddID0ge307XG5Nb2R1bGVbJ3ByZWxvYWRlZEF1ZGlvcyddID0ge307XG5cbi8qKlxuICogQHBhcmFtIHdoYXRcbiAqL1xuZnVuY3Rpb24gYWJvcnQod2hhdCkge1xuICB7XG4gICAgaWYgKE1vZHVsZVsnb25BYm9ydCddKSB7XG4gICAgICBNb2R1bGVbJ29uQWJvcnQnXSh3aGF0KTtcbiAgICB9XG4gIH1cbiAgd2hhdCA9ICdBYm9ydGVkKCcgKyB3aGF0ICsgJyknO1xuICBlcnIod2hhdCk7XG4gIEFCT1JUID0gdHJ1ZTtcbiAgRVhJVFNUQVRVUyA9IDE7XG4gIHdoYXQgKz0gJy4gQnVpbGQgd2l0aCAtcyBBU1NFUlRJT05TPTEgZm9yIG1vcmUgaW5mby4nO1xuICB2YXIgZSA9IG5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3Iod2hhdCk7XG4gIHRocm93IGU7XG59XG52YXIgZGF0YVVSSVByZWZpeCA9ICdkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsJztcblxuLyoqXG4gKiBAcGFyYW0gZmlsZW5hbWVcbiAqL1xuZnVuY3Rpb24gaXNEYXRhVVJJKGZpbGVuYW1lKSB7XG4gIHJldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSBmaWxlbmFtZVxuICovXG5mdW5jdGlvbiBpc0ZpbGVVUkkoZmlsZW5hbWUpIHtcbiAgcmV0dXJuIGZpbGVuYW1lLnN0YXJ0c1dpdGgoJ2ZpbGU6Ly8nKTtcbn1cbnZhciB3YXNtQmluYXJ5RmlsZTtcbndhc21CaW5hcnlGaWxlID0gJ2xpYkZvdXJRLndhc20nO1xuaWYgKCFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpKSB7XG4gIHdhc21CaW5hcnlGaWxlID0gbG9jYXRlRmlsZSh3YXNtQmluYXJ5RmlsZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIGZpbGVcbiAqL1xuZnVuY3Rpb24gZ2V0QmluYXJ5KGZpbGUpIHtcbiAgdHJ5IHtcbiAgICBpZiAoZmlsZSA9PSB3YXNtQmluYXJ5RmlsZSAmJiB3YXNtQmluYXJ5KSB7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2FzbUJpbmFyeSk7XG4gICAgfVxuICAgIGlmIChyZWFkQmluYXJ5KSB7XG4gICAgICByZXR1cm4gcmVhZEJpbmFyeShmaWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgJ2JvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkJztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGFib3J0KGVycik7XG4gIH1cbn1cblxuLyoqXG4gKlxuICovXG5mdW5jdGlvbiBnZXRCaW5hcnlQcm9taXNlKCkge1xuICBpZiAoIXdhc21CaW5hcnkgJiYgKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpKSB7XG4gICAgaWYgKHR5cGVvZiBmZXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNGaWxlVVJJKHdhc21CaW5hcnlGaWxlKSkge1xuICAgICAgcmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLCB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgIGlmICghcmVzcG9uc2VbJ29rJ10pIHtcbiAgICAgICAgICAgIHRocm93IFwiZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnXCIgKyB3YXNtQmluYXJ5RmlsZSArIFwiJ1wiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2VbJ2FycmF5QnVmZmVyJ10oKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0QmluYXJ5KHdhc21CaW5hcnlGaWxlKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZWFkQXN5bmMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZWFkQXN5bmMoXG4gICAgICAgICAgICB3YXNtQmluYXJ5RmlsZSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICByZXNvbHZlKG5ldyBVaW50OEFycmF5KHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0QmluYXJ5KHdhc21CaW5hcnlGaWxlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CaW5hcnkoc3RyKSB7XG4gIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBhdG9iKHN0cilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlY29kZShlbmNvZGVkKSB7XG4gIHZhciBiaW5hcnlTdHJpbmcgPSBhc2NpaVRvQmluYXJ5KGVuY29kZWQpO1xuICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBieXRlcy5idWZmZXI7XG59XG5cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24gY3JlYXRlV2FzbSgpIHtcbiAgdmFyIGluZm8gPSB7IGVudjogYXNtTGlicmFyeUFyZywgd2FzaV9zbmFwc2hvdF9wcmV2aWV3MTogYXNtTGlicmFyeUFyZyB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gaW5zdGFuY2VcbiAgICogQHBhcmFtIG1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLCBtb2R1bGUpIHtcbiAgICB2YXIgZXhwb3J0cyA9IGluc3RhbmNlLmV4cG9ydHM7XG4gICAgTW9kdWxlWydhc20nXSA9IGV4cG9ydHM7XG4gICAgd2FzbU1lbW9yeSA9IE1vZHVsZVsnYXNtJ11bJ21lbW9yeSddO1xuICAgIHVwZGF0ZUdsb2JhbEJ1ZmZlckFuZFZpZXdzKHdhc21NZW1vcnkuYnVmZmVyKTtcbiAgICB3YXNtVGFibGUgPSBNb2R1bGVbJ2FzbSddWydfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlJ107XG4gICAgcmVtb3ZlUnVuRGVwZW5kZW5jeSgnd2FzbS1pbnN0YW50aWF0ZScpO1xuICB9XG4gIGFkZFJ1bkRlcGVuZGVuY3koJ3dhc20taW5zdGFudGlhdGUnKTtcblxuICAvKipcbiAgICogQHBhcmFtIHJlc3VsdFxuICAgKi9cbiAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQocmVzdWx0KSB7XG4gICAgcmVjZWl2ZUluc3RhbmNlKHJlc3VsdFsnaW5zdGFuY2UnXSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHJlY2VpdmVyXG4gICAqL1xuICBmdW5jdGlvbiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVyKSB7XG4gICAgcmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGRlY29kZShlbmNvZGVkV2FzbUZpbGUpLCBpbmZvKVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgIH0pXG4gICAgICAudGhlbihyZWNlaXZlciwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBlcnIoJ2ZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICcgKyByZWFzb24pO1xuICAgICAgICBhYm9ydChyZWFzb24pO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICovXG4gIGZ1bmN0aW9uIGluc3RhbnRpYXRlQXN5bmMoKSB7XG4gICAgcmV0dXJuIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQpO1xuICB9XG4gIGlmIChNb2R1bGVbJ2luc3RhbnRpYXRlV2FzbSddKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBleHBvcnRzID0gTW9kdWxlWydpbnN0YW50aWF0ZVdhc20nXShpbmZvLCByZWNlaXZlSW5zdGFuY2UpO1xuICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyKCdNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAnICsgZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGluc3RhbnRpYXRlQXN5bmMoKTtcbiAgcmV0dXJuIHt9O1xufVxudmFyIHRlbXBEb3VibGU7XG52YXIgdGVtcEk2NDtcblxuLyoqXG4gKiBAcGFyYW0gY2FsbGJhY2tzXG4gKi9cbmZ1bmN0aW9uIGNhbGxSdW50aW1lQ2FsbGJhY2tzKGNhbGxiYWNrcykge1xuICB3aGlsZSAoY2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3Muc2hpZnQoKTtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrKE1vZHVsZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGZ1bmMgPSBjYWxsYmFjay5mdW5jO1xuICAgIGlmICh0eXBlb2YgZnVuYyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChjYWxsYmFjay5hcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnZXRXYXNtVGFibGVFbnRyeShmdW5jKSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0V2FzbVRhYmxlRW50cnkoZnVuYykoY2FsbGJhY2suYXJnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZnVuYyhjYWxsYmFjay5hcmcgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjay5hcmcpO1xuICAgIH1cbiAgfVxufVxudmFyIHdhc21UYWJsZU1pcnJvciA9IFtdO1xuXG4vKipcbiAqIEBwYXJhbSBmdW5jUHRyXG4gKi9cbmZ1bmN0aW9uIGdldFdhc21UYWJsZUVudHJ5KGZ1bmNQdHIpIHtcbiAgdmFyIGZ1bmMgPSB3YXNtVGFibGVNaXJyb3JbZnVuY1B0cl07XG4gIGlmICghZnVuYykge1xuICAgIGlmIChmdW5jUHRyID49IHdhc21UYWJsZU1pcnJvci5sZW5ndGgpIHdhc21UYWJsZU1pcnJvci5sZW5ndGggPSBmdW5jUHRyICsgMTtcbiAgICB3YXNtVGFibGVNaXJyb3JbZnVuY1B0cl0gPSBmdW5jID0gd2FzbVRhYmxlLmdldChmdW5jUHRyKTtcbiAgfVxuICByZXR1cm4gZnVuYztcbn1cblxuLyoqXG4gKiBAcGFyYW0gZVxuICovXG5mdW5jdGlvbiBoYW5kbGVFeGNlcHRpb24oZSkge1xuICBpZiAoZSBpbnN0YW5jZW9mIEV4aXRTdGF0dXMgfHwgZSA9PSAndW53aW5kJykge1xuICAgIHJldHVybiBFWElUU1RBVFVTO1xuICB9XG4gIHF1aXRfKDEsIGUpO1xufVxudmFyIFBBVEggPSB7XG4gIHNwbGl0UGF0aDogZnVuY3Rpb24gKGZpbGVuYW1lKSB7XG4gICAgdmFyIHNwbGl0UGF0aFJlID0gL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG4gICAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xuICB9LFxuICBub3JtYWxpemVBcnJheTogZnVuY3Rpb24gKHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAgIHZhciB1cCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgICB1cCsrO1xuICAgICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHVwLS07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgICAgZm9yICg7IHVwOyB1cC0tKSB7XG4gICAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbiAgfSxcbiAgbm9ybWFsaXplOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBpc0Fic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBwYXRoLnN1YnN0cigtMSkgPT09ICcvJztcbiAgICBwYXRoID0gUEFUSC5ub3JtYWxpemVBcnJheShcbiAgICAgIHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuICEhcDtcbiAgICAgIH0pLFxuICAgICAgIWlzQWJzb2x1dGVcbiAgICApLmpvaW4oJy8nKTtcbiAgICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICAgIHBhdGggPSAnLic7XG4gICAgfVxuICAgIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICAgIHBhdGggKz0gJy8nO1xuICAgIH1cbiAgICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xuICB9LFxuICBkaXJuYW1lOiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciByZXN1bHQgPSBQQVRILnNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG4gICAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAgIHJldHVybiAnLic7XG4gICAgfVxuICAgIGlmIChkaXIpIHtcbiAgICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdCArIGRpcjtcbiAgfSxcbiAgYmFzZW5hbWU6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHBhdGggPT09ICcvJykgcmV0dXJuICcvJztcbiAgICBwYXRoID0gUEFUSC5ub3JtYWxpemUocGF0aCk7XG4gICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICB2YXIgbGFzdFNsYXNoID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIGlmIChsYXN0U2xhc2ggPT09IC0xKSByZXR1cm4gcGF0aDtcbiAgICByZXR1cm4gcGF0aC5zdWJzdHIobGFzdFNsYXNoICsgMSk7XG4gIH0sXG4gIGV4dG5hbWU6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuIFBBVEguc3BsaXRQYXRoKHBhdGgpWzNdO1xuICB9LFxuICBqb2luOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICByZXR1cm4gUEFUSC5ub3JtYWxpemUocGF0aHMuam9pbignLycpKTtcbiAgfSxcbiAgam9pbjI6IGZ1bmN0aW9uIChsLCByKSB7XG4gICAgcmV0dXJuIFBBVEgubm9ybWFsaXplKGwgKyAnLycgKyByKTtcbiAgfSxcbn07XG5cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24gZ2V0UmFuZG9tRGV2aWNlKCkge1xuICBpZiAodHlwZW9mIGNyeXB0byA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGNyeXB0b1snZ2V0UmFuZG9tVmFsdWVzJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmFuZG9tQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMocmFuZG9tQnVmZmVyKTtcbiAgICAgIHJldHVybiByYW5kb21CdWZmZXJbMF07XG4gICAgfTtcbiAgfSBcbiAgLy8gZWxzZSBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkge1xuICAvLyAgIHRyeSB7XG4gIC8vICAgICB2YXIgY3J5cHRvX21vZHVsZSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAvLyAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgLy8gICAgICAgcmV0dXJuIGNyeXB0b19tb2R1bGVbJ3JhbmRvbUJ5dGVzJ10oMSlbMF07XG4gIC8vICAgICB9O1xuICAvLyAgIH0gY2F0Y2ggKGUpIHt9XG4gIC8vIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBhYm9ydCgncmFuZG9tRGV2aWNlJyk7XG4gIH07XG59XG52YXIgUEFUSF9GUyA9IHtcbiAgcmVzb2x2ZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgICAgdmFyIHBhdGggPSBpID49IDAgPyBhcmd1bWVudHNbaV0gOiBGUy5jd2QoKTtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICAgIH1cbiAgICByZXNvbHZlZFBhdGggPSBQQVRILm5vcm1hbGl6ZUFycmF5KFxuICAgICAgcmVzb2x2ZWRQYXRoLnNwbGl0KCcvJykuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiAhIXA7XG4gICAgICB9KSxcbiAgICAgICFyZXNvbHZlZEFic29sdXRlXG4gICAgKS5qb2luKCcvJyk7XG4gICAgcmV0dXJuIChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoIHx8ICcuJztcbiAgfSxcbiAgcmVsYXRpdmU6IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgIGZyb20gPSBQQVRIX0ZTLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICAgIHRvID0gUEFUSF9GUy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJyXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICAgIHZhciBzdGFydCA9IDA7XG4gICAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID4gZW5kKSByZXR1cm4gW107XG4gICAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICAgIH1cbiAgICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICAgIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTtcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpO1xuICAgIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkge1xuICAgICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgICB9XG4gICAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcbiAgICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xuICB9LFxufTtcbnZhciBUVFkgPSB7XG4gIHR0eXM6IFtdLFxuICBpbml0OiBmdW5jdGlvbiAoKSB7fSxcbiAgc2h1dGRvd246IGZ1bmN0aW9uICgpIHt9LFxuICByZWdpc3RlcjogZnVuY3Rpb24gKGRldiwgb3BzKSB7XG4gICAgVFRZLnR0eXNbZGV2XSA9IHsgaW5wdXQ6IFtdLCBvdXRwdXQ6IFtdLCBvcHM6IG9wcyB9O1xuICAgIEZTLnJlZ2lzdGVyRGV2aWNlKGRldiwgVFRZLnN0cmVhbV9vcHMpO1xuICB9LFxuICBzdHJlYW1fb3BzOiB7XG4gICAgb3BlbjogZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgdmFyIHR0eSA9IFRUWS50dHlzW3N0cmVhbS5ub2RlLnJkZXZdO1xuICAgICAgaWYgKCF0dHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgfVxuICAgICAgc3RyZWFtLnR0eSA9IHR0eTtcbiAgICAgIHN0cmVhbS5zZWVrYWJsZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgY2xvc2U6IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgIHN0cmVhbS50dHkub3BzLmZsdXNoKHN0cmVhbS50dHkpO1xuICAgIH0sXG4gICAgZmx1c2g6IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgIHN0cmVhbS50dHkub3BzLmZsdXNoKHN0cmVhbS50dHkpO1xuICAgIH0sXG4gICAgcmVhZDogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSB7XG4gICAgICBpZiAoIXN0cmVhbS50dHkgfHwgIXN0cmVhbS50dHkub3BzLmdldF9jaGFyKSB7XG4gICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYwKTtcbiAgICAgIH1cbiAgICAgIHZhciBieXRlc1JlYWQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdCA9IHN0cmVhbS50dHkub3BzLmdldF9jaGFyKHN0cmVhbS50dHkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCAmJiBieXRlc1JlYWQgPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgICAgYnl0ZXNSZWFkKys7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmIChieXRlc1JlYWQpIHtcbiAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlc1JlYWQ7XG4gICAgfSxcbiAgICB3cml0ZTogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSB7XG4gICAgICBpZiAoIXN0cmVhbS50dHkgfHwgIXN0cmVhbS50dHkub3BzLnB1dF9jaGFyKSB7XG4gICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYwKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5wdXRfY2hhcihzdHJlYW0udHR5LCBidWZmZXJbb2Zmc2V0ICsgaV0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgIH1cbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH0sXG4gIH0sXG4gIGRlZmF1bHRfdHR5X29wczoge1xuICAgIGdldF9jaGFyOiBmdW5jdGlvbiAodHR5KSB7XG4gICAgICBpZiAoIXR0eS5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGlmIChFTlZJUk9OTUVOVF9JU19OT0RFKSB7XG4gICAgICAgICAgdmFyIEJVRlNJWkUgPSAyNTY7XG4gICAgICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyhCVUZTSVpFKTtcbiAgICAgICAgICB2YXIgYnl0ZXNSZWFkID0gMDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYnl0ZXNSZWFkID0gbm9kZUZTLnJlYWRTeW5jKHByb2Nlc3Muc3RkaW4uZmQsIGJ1ZiwgMCwgQlVGU0laRSwgbnVsbCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5pbmNsdWRlcygnRU9GJykpIGJ5dGVzUmVhZCA9IDA7XG4gICAgICAgICAgICBlbHNlIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChieXRlc1JlYWQgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBidWYuc2xpY2UoMCwgYnl0ZXNSZWFkKS50b1N0cmluZygndXRmLTgnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LnByb21wdCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmVzdWx0ID0gd2luZG93LnByb21wdCgnSW5wdXQ6ICcpO1xuICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlYWRsaW5lID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXN1bHQgPSByZWFkbGluZSgpO1xuICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0dHkuaW5wdXQgPSBpbnRBcnJheUZyb21TdHJpbmcocmVzdWx0LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0dHkuaW5wdXQuc2hpZnQoKTtcbiAgICB9LFxuICAgIHB1dF9jaGFyOiBmdW5jdGlvbiAodHR5LCB2YWwpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSAxMCkge1xuICAgICAgICBvdXQoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsICE9IDApIHR0eS5vdXRwdXQucHVzaCh2YWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZmx1c2g6IGZ1bmN0aW9uICh0dHkpIHtcbiAgICAgIGlmICh0dHkub3V0cHV0ICYmIHR0eS5vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICBvdXQoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbiAgZGVmYXVsdF90dHkxX29wczoge1xuICAgIHB1dF9jaGFyOiBmdW5jdGlvbiAodHR5LCB2YWwpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSAxMCkge1xuICAgICAgICBlcnIoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsICE9IDApIHR0eS5vdXRwdXQucHVzaCh2YWwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZmx1c2g6IGZ1bmN0aW9uICh0dHkpIHtcbiAgICAgIGlmICh0dHkub3V0cHV0ICYmIHR0eS5vdXRwdXQubGVuZ3RoID4gMCkge1xuICAgICAgICBlcnIoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwgMCkpO1xuICAgICAgICB0dHkub3V0cHV0ID0gW107XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbn07XG4vKipcbiAqIEBwYXJhbSBzaXplXG4gKi9cbmZ1bmN0aW9uIG1tYXBBbGxvYyhzaXplKSB7XG4gIGFib3J0KCk7XG59XG52YXIgTUVNRlMgPSB7XG4gIG9wc190YWJsZTogbnVsbCxcbiAgbW91bnQ6IGZ1bmN0aW9uIChtb3VudCkge1xuICAgIHJldHVybiBNRU1GUy5jcmVhdGVOb2RlKG51bGwsICcvJywgMTYzODQgfCA1MTEsIDApO1xuICB9LFxuICBjcmVhdGVOb2RlOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHtcbiAgICBpZiAoRlMuaXNCbGtkZXYobW9kZSkgfHwgRlMuaXNGSUZPKG1vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgfVxuICAgIGlmICghTUVNRlMub3BzX3RhYmxlKSB7XG4gICAgICBNRU1GUy5vcHNfdGFibGUgPSB7XG4gICAgICAgIGRpcjoge1xuICAgICAgICAgIG5vZGU6IHtcbiAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsXG4gICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyLFxuICAgICAgICAgICAgbG9va3VwOiBNRU1GUy5ub2RlX29wcy5sb29rdXAsXG4gICAgICAgICAgICBta25vZDogTUVNRlMubm9kZV9vcHMubWtub2QsXG4gICAgICAgICAgICByZW5hbWU6IE1FTUZTLm5vZGVfb3BzLnJlbmFtZSxcbiAgICAgICAgICAgIHVubGluazogTUVNRlMubm9kZV9vcHMudW5saW5rLFxuICAgICAgICAgICAgcm1kaXI6IE1FTUZTLm5vZGVfb3BzLnJtZGlyLFxuICAgICAgICAgICAgcmVhZGRpcjogTUVNRlMubm9kZV9vcHMucmVhZGRpcixcbiAgICAgICAgICAgIHN5bWxpbms6IE1FTUZTLm5vZGVfb3BzLnN5bWxpbmssXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHJlYW06IHsgbGxzZWVrOiBNRU1GUy5zdHJlYW1fb3BzLmxsc2VlayB9LFxuICAgICAgICB9LFxuICAgICAgICBmaWxlOiB7XG4gICAgICAgICAgbm9kZTogeyBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLCBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyIH0sXG4gICAgICAgICAgc3RyZWFtOiB7XG4gICAgICAgICAgICBsbHNlZWs6IE1FTUZTLnN0cmVhbV9vcHMubGxzZWVrLFxuICAgICAgICAgICAgcmVhZDogTUVNRlMuc3RyZWFtX29wcy5yZWFkLFxuICAgICAgICAgICAgd3JpdGU6IE1FTUZTLnN0cmVhbV9vcHMud3JpdGUsXG4gICAgICAgICAgICBhbGxvY2F0ZTogTUVNRlMuc3RyZWFtX29wcy5hbGxvY2F0ZSxcbiAgICAgICAgICAgIG1tYXA6IE1FTUZTLnN0cmVhbV9vcHMubW1hcCxcbiAgICAgICAgICAgIG1zeW5jOiBNRU1GUy5zdHJlYW1fb3BzLm1zeW5jLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGxpbms6IHtcbiAgICAgICAgICBub2RlOiB7XG4gICAgICAgICAgICBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLFxuICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0cixcbiAgICAgICAgICAgIHJlYWRsaW5rOiBNRU1GUy5ub2RlX29wcy5yZWFkbGluayxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0cmVhbToge30sXG4gICAgICAgIH0sXG4gICAgICAgIGNocmRldjoge1xuICAgICAgICAgIG5vZGU6IHsgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0ciwgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0ciB9LFxuICAgICAgICAgIHN0cmVhbTogRlMuY2hyZGV2X3N0cmVhbV9vcHMsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpO1xuICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmRpci5ub2RlO1xuICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTUVNRlMub3BzX3RhYmxlLmRpci5zdHJlYW07XG4gICAgICBub2RlLmNvbnRlbnRzID0ge307XG4gICAgfSBlbHNlIGlmIChGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5maWxlLm5vZGU7XG4gICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZmlsZS5zdHJlYW07XG4gICAgICBub2RlLnVzZWRCeXRlcyA9IDA7XG4gICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKEZTLmlzTGluayhub2RlLm1vZGUpKSB7XG4gICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmxpbmsubm9kZTtcbiAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5saW5rLnN0cmVhbTtcbiAgICB9IGVsc2UgaWYgKEZTLmlzQ2hyZGV2KG5vZGUubW9kZSkpIHtcbiAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuY2hyZGV2Lm5vZGU7XG4gICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuY2hyZGV2LnN0cmVhbTtcbiAgICB9XG4gICAgbm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5jb250ZW50c1tuYW1lXSA9IG5vZGU7XG4gICAgICBwYXJlbnQudGltZXN0YW1wID0gbm9kZS50aW1lc3RhbXA7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBnZXRGaWxlRGF0YUFzVHlwZWRBcnJheTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuY29udGVudHMpIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICBpZiAobm9kZS5jb250ZW50cy5zdWJhcnJheSkgcmV0dXJuIG5vZGUuY29udGVudHMuc3ViYXJyYXkoMCwgbm9kZS51c2VkQnl0ZXMpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShub2RlLmNvbnRlbnRzKTtcbiAgfSxcbiAgZXhwYW5kRmlsZVN0b3JhZ2U6IGZ1bmN0aW9uIChub2RlLCBuZXdDYXBhY2l0eSkge1xuICAgIHZhciBwcmV2Q2FwYWNpdHkgPSBub2RlLmNvbnRlbnRzID8gbm9kZS5jb250ZW50cy5sZW5ndGggOiAwO1xuICAgIGlmIChwcmV2Q2FwYWNpdHkgPj0gbmV3Q2FwYWNpdHkpIHJldHVybjtcbiAgICB2YXIgQ0FQQUNJVFlfRE9VQkxJTkdfTUFYID0gMTAyNCAqIDEwMjQ7XG4gICAgbmV3Q2FwYWNpdHkgPSBNYXRoLm1heChcbiAgICAgIG5ld0NhcGFjaXR5LFxuICAgICAgKHByZXZDYXBhY2l0eSAqIChwcmV2Q2FwYWNpdHkgPCBDQVBBQ0lUWV9ET1VCTElOR19NQVggPyAyIDogMS4xMjUpKSA+Pj4gMFxuICAgICk7XG4gICAgaWYgKHByZXZDYXBhY2l0eSAhPSAwKSBuZXdDYXBhY2l0eSA9IE1hdGgubWF4KG5ld0NhcGFjaXR5LCAyNTYpO1xuICAgIHZhciBvbGRDb250ZW50cyA9IG5vZGUuY29udGVudHM7XG4gICAgbm9kZS5jb250ZW50cyA9IG5ldyBVaW50OEFycmF5KG5ld0NhcGFjaXR5KTtcbiAgICBpZiAobm9kZS51c2VkQnl0ZXMgPiAwKSBub2RlLmNvbnRlbnRzLnNldChvbGRDb250ZW50cy5zdWJhcnJheSgwLCBub2RlLnVzZWRCeXRlcyksIDApO1xuICB9LFxuICByZXNpemVGaWxlU3RvcmFnZTogZnVuY3Rpb24gKG5vZGUsIG5ld1NpemUpIHtcbiAgICBpZiAobm9kZS51c2VkQnl0ZXMgPT0gbmV3U2l6ZSkgcmV0dXJuO1xuICAgIGlmIChuZXdTaXplID09IDApIHtcbiAgICAgIG5vZGUuY29udGVudHMgPSBudWxsO1xuICAgICAgbm9kZS51c2VkQnl0ZXMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb2xkQ29udGVudHMgPSBub2RlLmNvbnRlbnRzO1xuICAgICAgbm9kZS5jb250ZW50cyA9IG5ldyBVaW50OEFycmF5KG5ld1NpemUpO1xuICAgICAgaWYgKG9sZENvbnRlbnRzKSB7XG4gICAgICAgIG5vZGUuY29udGVudHMuc2V0KG9sZENvbnRlbnRzLnN1YmFycmF5KDAsIE1hdGgubWluKG5ld1NpemUsIG5vZGUudXNlZEJ5dGVzKSkpO1xuICAgICAgfVxuICAgICAgbm9kZS51c2VkQnl0ZXMgPSBuZXdTaXplO1xuICAgIH1cbiAgfSxcbiAgbm9kZV9vcHM6IHtcbiAgICBnZXRhdHRyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgdmFyIGF0dHIgPSB7fTtcbiAgICAgIGF0dHIuZGV2ID0gRlMuaXNDaHJkZXYobm9kZS5tb2RlKSA/IG5vZGUuaWQgOiAxO1xuICAgICAgYXR0ci5pbm8gPSBub2RlLmlkO1xuICAgICAgYXR0ci5tb2RlID0gbm9kZS5tb2RlO1xuICAgICAgYXR0ci5ubGluayA9IDE7XG4gICAgICBhdHRyLnVpZCA9IDA7XG4gICAgICBhdHRyLmdpZCA9IDA7XG4gICAgICBhdHRyLnJkZXYgPSBub2RlLnJkZXY7XG4gICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICBhdHRyLnNpemUgPSA0MDk2O1xuICAgICAgfSBlbHNlIGlmIChGUy5pc0ZpbGUobm9kZS5tb2RlKSkge1xuICAgICAgICBhdHRyLnNpemUgPSBub2RlLnVzZWRCeXRlcztcbiAgICAgIH0gZWxzZSBpZiAoRlMuaXNMaW5rKG5vZGUubW9kZSkpIHtcbiAgICAgICAgYXR0ci5zaXplID0gbm9kZS5saW5rLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHIuc2l6ZSA9IDA7XG4gICAgICB9XG4gICAgICBhdHRyLmF0aW1lID0gbmV3IERhdGUobm9kZS50aW1lc3RhbXApO1xuICAgICAgYXR0ci5tdGltZSA9IG5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTtcbiAgICAgIGF0dHIuY3RpbWUgPSBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7XG4gICAgICBhdHRyLmJsa3NpemUgPSA0MDk2O1xuICAgICAgYXR0ci5ibG9ja3MgPSBNYXRoLmNlaWwoYXR0ci5zaXplIC8gYXR0ci5ibGtzaXplKTtcbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH0sXG4gICAgc2V0YXR0cjogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAgIGlmIChhdHRyLm1vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLm1vZGUgPSBhdHRyLm1vZGU7XG4gICAgICB9XG4gICAgICBpZiAoYXR0ci50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLnRpbWVzdGFtcCA9IGF0dHIudGltZXN0YW1wO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHIuc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIE1FTUZTLnJlc2l6ZUZpbGVTdG9yYWdlKG5vZGUsIGF0dHIuc2l6ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsb29rdXA6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHtcbiAgICAgIHRocm93IEZTLmdlbmVyaWNFcnJvcnNbNDRdO1xuICAgIH0sXG4gICAgbWtub2Q6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUsIG1vZGUsIGRldikge1xuICAgICAgcmV0dXJuIE1FTUZTLmNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpO1xuICAgIH0sXG4gICAgcmVuYW1lOiBmdW5jdGlvbiAob2xkX25vZGUsIG5ld19kaXIsIG5ld19uYW1lKSB7XG4gICAgICBpZiAoRlMuaXNEaXIob2xkX25vZGUubW9kZSkpIHtcbiAgICAgICAgdmFyIG5ld19ub2RlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ld19ub2RlID0gRlMubG9va3VwTm9kZShuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIGlmIChuZXdfbm9kZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gbmV3X25vZGUuY29udGVudHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBvbGRfbm9kZS5wYXJlbnQuY29udGVudHNbb2xkX25vZGUubmFtZV07XG4gICAgICBvbGRfbm9kZS5wYXJlbnQudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgIG9sZF9ub2RlLm5hbWUgPSBuZXdfbmFtZTtcbiAgICAgIG5ld19kaXIuY29udGVudHNbbmV3X25hbWVdID0gb2xkX25vZGU7XG4gICAgICBuZXdfZGlyLnRpbWVzdGFtcCA9IG9sZF9ub2RlLnBhcmVudC50aW1lc3RhbXA7XG4gICAgICBvbGRfbm9kZS5wYXJlbnQgPSBuZXdfZGlyO1xuICAgIH0sXG4gICAgdW5saW5rOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lKSB7XG4gICAgICBkZWxldGUgcGFyZW50LmNvbnRlbnRzW25hbWVdO1xuICAgICAgcGFyZW50LnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgfSxcbiAgICBybWRpcjogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSkge1xuICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7XG4gICAgICBmb3IgKHZhciBpIGluIG5vZGUuY29udGVudHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTUpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHBhcmVudC5jb250ZW50c1tuYW1lXTtcbiAgICAgIHBhcmVudC50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIH0sXG4gICAgcmVhZGRpcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBlbnRyaWVzID0gWycuJywgJy4uJ107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbm9kZS5jb250ZW50cykge1xuICAgICAgICBpZiAoIW5vZGUuY29udGVudHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVudHJpZXMucHVzaChrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVudHJpZXM7XG4gICAgfSxcbiAgICBzeW1saW5rOiBmdW5jdGlvbiAocGFyZW50LCBuZXduYW1lLCBvbGRwYXRoKSB7XG4gICAgICB2YXIgbm9kZSA9IE1FTUZTLmNyZWF0ZU5vZGUocGFyZW50LCBuZXduYW1lLCA1MTEgfCA0MDk2MCwgMCk7XG4gICAgICBub2RlLmxpbmsgPSBvbGRwYXRoO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICByZWFkbGluazogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmICghRlMuaXNMaW5rKG5vZGUubW9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUubGluaztcbiAgICB9LFxuICB9LFxuICBzdHJlYW1fb3BzOiB7XG4gICAgcmVhZDogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgaWYgKHBvc2l0aW9uID49IHN0cmVhbS5ub2RlLnVzZWRCeXRlcykgcmV0dXJuIDA7XG4gICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKHN0cmVhbS5ub2RlLnVzZWRCeXRlcyAtIHBvc2l0aW9uLCBsZW5ndGgpO1xuICAgICAgaWYgKHNpemUgPiA4ICYmIGNvbnRlbnRzLnN1YmFycmF5KSB7XG4gICAgICAgIGJ1ZmZlci5zZXQoY29udGVudHMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgc2l6ZSksIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykgYnVmZmVyW29mZnNldCArIGldID0gY29udGVudHNbcG9zaXRpb24gKyBpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaXplO1xuICAgIH0sXG4gICAgd3JpdGU6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYW5Pd24pIHtcbiAgICAgIGlmICghbGVuZ3RoKSByZXR1cm4gMDtcbiAgICAgIHZhciBub2RlID0gc3RyZWFtLm5vZGU7XG4gICAgICBub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7XG4gICAgICBpZiAoYnVmZmVyLnN1YmFycmF5ICYmICghbm9kZS5jb250ZW50cyB8fCBub2RlLmNvbnRlbnRzLnN1YmFycmF5KSkge1xuICAgICAgICBpZiAoY2FuT3duKSB7XG4gICAgICAgICAgbm9kZS5jb250ZW50cyA9IGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBsZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnVzZWRCeXRlcyA9PT0gMCAmJiBwb3NpdGlvbiA9PT0gMCkge1xuICAgICAgICAgIG5vZGUuY29udGVudHMgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpO1xuICAgICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gKyBsZW5ndGggPD0gbm9kZS51c2VkQnl0ZXMpIHtcbiAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpLCBwb3NpdGlvbik7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgTUVNRlMuZXhwYW5kRmlsZVN0b3JhZ2Uobm9kZSwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgICAgaWYgKG5vZGUuY29udGVudHMuc3ViYXJyYXkgJiYgYnVmZmVyLnN1YmFycmF5KSB7XG4gICAgICAgIG5vZGUuY29udGVudHMuc2V0KGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCksIHBvc2l0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlLmNvbnRlbnRzW3Bvc2l0aW9uICsgaV0gPSBidWZmZXJbb2Zmc2V0ICsgaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUudXNlZEJ5dGVzID0gTWF0aC5tYXgobm9kZS51c2VkQnl0ZXMsIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfSxcbiAgICBsbHNlZWs6IGZ1bmN0aW9uIChzdHJlYW0sIG9mZnNldCwgd2hlbmNlKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSBvZmZzZXQ7XG4gICAgICBpZiAod2hlbmNlID09PSAxKSB7XG4gICAgICAgIHBvc2l0aW9uICs9IHN0cmVhbS5wb3NpdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAod2hlbmNlID09PSAyKSB7XG4gICAgICAgIGlmIChGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgICBwb3NpdGlvbiArPSBzdHJlYW0ubm9kZS51c2VkQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0sXG4gICAgYWxsb2NhdGU6IGZ1bmN0aW9uIChzdHJlYW0sIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICBNRU1GUy5leHBhbmRGaWxlU3RvcmFnZShzdHJlYW0ubm9kZSwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgIHN0cmVhbS5ub2RlLnVzZWRCeXRlcyA9IE1hdGgubWF4KHN0cmVhbS5ub2RlLnVzZWRCeXRlcywgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICB9LFxuICAgIG1tYXA6IGZ1bmN0aW9uIChzdHJlYW0sIGFkZHJlc3MsIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSB7XG4gICAgICBpZiAoYWRkcmVzcyAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgICB9XG4gICAgICBpZiAoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myk7XG4gICAgICB9XG4gICAgICB2YXIgcHRyO1xuICAgICAgdmFyIGFsbG9jYXRlZDtcbiAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgaWYgKCEoZmxhZ3MgJiAyKSAmJiBjb250ZW50cy5idWZmZXIgPT09IGJ1ZmZlcikge1xuICAgICAgICBhbGxvY2F0ZWQgPSBmYWxzZTtcbiAgICAgICAgcHRyID0gY29udGVudHMuYnl0ZU9mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA+IDAgfHwgcG9zaXRpb24gKyBsZW5ndGggPCBjb250ZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoY29udGVudHMuc3ViYXJyYXkpIHtcbiAgICAgICAgICAgIGNvbnRlbnRzID0gY29udGVudHMuc3ViYXJyYXkocG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250ZW50cywgcG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWxsb2NhdGVkID0gdHJ1ZTtcbiAgICAgICAgcHRyID0gbW1hcEFsbG9jKGxlbmd0aCk7XG4gICAgICAgIGlmICghcHRyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDgpO1xuICAgICAgICB9XG4gICAgICAgIEhFQVA4LnNldChjb250ZW50cywgcHRyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHB0cjogcHRyLCBhbGxvY2F0ZWQ6IGFsbG9jYXRlZCB9O1xuICAgIH0sXG4gICAgbXN5bmM6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIG1tYXBGbGFncykge1xuICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgICAgfVxuICAgICAgaWYgKG1tYXBGbGFncyAmIDIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB2YXIgYnl0ZXNXcml0dGVuID0gTUVNRlMuc3RyZWFtX29wcy53cml0ZShzdHJlYW0sIGJ1ZmZlciwgMCwgbGVuZ3RoLCBvZmZzZXQsIGZhbHNlKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gIH0sXG59O1xuXG4vKipcbiAqIEBwYXJhbSB1cmxcbiAqIEBwYXJhbSBvbmxvYWRcbiAqIEBwYXJhbSBvbmVycm9yXG4gKiBAcGFyYW0gbm9SdW5EZXBcbiAqL1xuZnVuY3Rpb24gYXN5bmNMb2FkKHVybCwgb25sb2FkLCBvbmVycm9yLCBub1J1bkRlcCkge1xuICB2YXIgZGVwID0gIW5vUnVuRGVwID8gZ2V0VW5pcXVlUnVuRGVwZW5kZW5jeSgnYWwgJyArIHVybCkgOiAnJztcbiAgcmVhZEFzeW5jKFxuICAgIHVybCxcbiAgICBmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcbiAgICAgIGFzc2VydChhcnJheUJ1ZmZlciwgJ0xvYWRpbmcgZGF0YSBmaWxlIFwiJyArIHVybCArICdcIiBmYWlsZWQgKG5vIGFycmF5QnVmZmVyKS4nKTtcbiAgICAgIG9ubG9hZChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICAgICAgaWYgKGRlcCkgcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApO1xuICAgIH0sXG4gICAgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAob25lcnJvcikge1xuICAgICAgICBvbmVycm9yKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyAnTG9hZGluZyBkYXRhIGZpbGUgXCInICsgdXJsICsgJ1wiIGZhaWxlZC4nO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgaWYgKGRlcCkgYWRkUnVuRGVwZW5kZW5jeShkZXApO1xufVxudmFyIEZTID0ge1xuICByb290OiBudWxsLFxuICBtb3VudHM6IFtdLFxuICBkZXZpY2VzOiB7fSxcbiAgc3RyZWFtczogW10sXG4gIG5leHRJbm9kZTogMSxcbiAgbmFtZVRhYmxlOiBudWxsLFxuICBjdXJyZW50UGF0aDogJy8nLFxuICBpbml0aWFsaXplZDogZmFsc2UsXG4gIGlnbm9yZVBlcm1pc3Npb25zOiB0cnVlLFxuICBFcnJub0Vycm9yOiBudWxsLFxuICBnZW5lcmljRXJyb3JzOiB7fSxcbiAgZmlsZXN5c3RlbXM6IG51bGwsXG4gIHN5bmNGU1JlcXVlc3RzOiAwLFxuICBsb29rdXBQYXRoOiBmdW5jdGlvbiAocGF0aCwgb3B0cykge1xuICAgIHBhdGggPSBQQVRIX0ZTLnJlc29sdmUoRlMuY3dkKCksIHBhdGgpO1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIGlmICghcGF0aCkgcmV0dXJuIHsgcGF0aDogJycsIG5vZGU6IG51bGwgfTtcbiAgICB2YXIgZGVmYXVsdHMgPSB7IGZvbGxvd19tb3VudDogdHJ1ZSwgcmVjdXJzZV9jb3VudDogMCB9O1xuICAgIGZvciAodmFyIGtleSBpbiBkZWZhdWx0cykge1xuICAgICAgaWYgKG9wdHNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdHNba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRzLnJlY3Vyc2VfY291bnQgPiA4KSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMik7XG4gICAgfVxuICAgIHZhciBwYXJ0cyA9IFBBVEgubm9ybWFsaXplQXJyYXkoXG4gICAgICBwYXRoLnNwbGl0KCcvJykuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiAhIXA7XG4gICAgICB9KSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICB2YXIgY3VycmVudCA9IEZTLnJvb3Q7XG4gICAgdmFyIGN1cnJlbnRfcGF0aCA9ICcvJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXNsYXN0ID0gaSA9PT0gcGFydHMubGVuZ3RoIC0gMTtcbiAgICAgIGlmIChpc2xhc3QgJiYgb3B0cy5wYXJlbnQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gRlMubG9va3VwTm9kZShjdXJyZW50LCBwYXJ0c1tpXSk7XG4gICAgICBjdXJyZW50X3BhdGggPSBQQVRILmpvaW4yKGN1cnJlbnRfcGF0aCwgcGFydHNbaV0pO1xuICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChjdXJyZW50KSkge1xuICAgICAgICBpZiAoIWlzbGFzdCB8fCAoaXNsYXN0ICYmIG9wdHMuZm9sbG93X21vdW50KSkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm1vdW50ZWQucm9vdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc2xhc3QgfHwgb3B0cy5mb2xsb3cpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgd2hpbGUgKEZTLmlzTGluayhjdXJyZW50Lm1vZGUpKSB7XG4gICAgICAgICAgdmFyIGxpbmsgPSBGUy5yZWFkbGluayhjdXJyZW50X3BhdGgpO1xuICAgICAgICAgIGN1cnJlbnRfcGF0aCA9IFBBVEhfRlMucmVzb2x2ZShQQVRILmRpcm5hbWUoY3VycmVudF9wYXRoKSwgbGluayk7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgoY3VycmVudF9wYXRoLCB7IHJlY3Vyc2VfY291bnQ6IG9wdHMucmVjdXJzZV9jb3VudCB9KTtcbiAgICAgICAgICBjdXJyZW50ID0gbG9va3VwLm5vZGU7XG4gICAgICAgICAgaWYgKGNvdW50KysgPiA0MCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBwYXRoOiBjdXJyZW50X3BhdGgsIG5vZGU6IGN1cnJlbnQgfTtcbiAgfSxcbiAgZ2V0UGF0aDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgcGF0aDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKEZTLmlzUm9vdChub2RlKSkge1xuICAgICAgICB2YXIgbW91bnQgPSBub2RlLm1vdW50Lm1vdW50cG9pbnQ7XG4gICAgICAgIGlmICghcGF0aCkgcmV0dXJuIG1vdW50O1xuICAgICAgICByZXR1cm4gbW91bnRbbW91bnQubGVuZ3RoIC0gMV0gIT09ICcvJyA/IG1vdW50ICsgJy8nICsgcGF0aCA6IG1vdW50ICsgcGF0aDtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBwYXRoID8gbm9kZS5uYW1lICsgJy8nICsgcGF0aCA6IG5vZGUubmFtZTtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9XG4gIH0sXG4gIGhhc2hOYW1lOiBmdW5jdGlvbiAocGFyZW50aWQsIG5hbWUpIHtcbiAgICB2YXIgaGFzaCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWUuY2hhckNvZGVBdChpKSkgfCAwO1xuICAgIH1cbiAgICByZXR1cm4gKChwYXJlbnRpZCArIGhhc2gpID4+PiAwKSAlIEZTLm5hbWVUYWJsZS5sZW5ndGg7XG4gIH0sXG4gIGhhc2hBZGROb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBoYXNoID0gRlMuaGFzaE5hbWUobm9kZS5wYXJlbnQuaWQsIG5vZGUubmFtZSk7XG4gICAgbm9kZS5uYW1lX25leHQgPSBGUy5uYW1lVGFibGVbaGFzaF07XG4gICAgRlMubmFtZVRhYmxlW2hhc2hdID0gbm9kZTtcbiAgfSxcbiAgaGFzaFJlbW92ZU5vZGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGhhc2ggPSBGUy5oYXNoTmFtZShub2RlLnBhcmVudC5pZCwgbm9kZS5uYW1lKTtcbiAgICBpZiAoRlMubmFtZVRhYmxlW2hhc2hdID09PSBub2RlKSB7XG4gICAgICBGUy5uYW1lVGFibGVbaGFzaF0gPSBub2RlLm5hbWVfbmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGN1cnJlbnQgPSBGUy5uYW1lVGFibGVbaGFzaF07XG4gICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICBpZiAoY3VycmVudC5uYW1lX25leHQgPT09IG5vZGUpIHtcbiAgICAgICAgICBjdXJyZW50Lm5hbWVfbmV4dCA9IG5vZGUubmFtZV9uZXh0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5hbWVfbmV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGxvb2t1cE5vZGU6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHtcbiAgICB2YXIgZXJyQ29kZSA9IEZTLm1heUxvb2t1cChwYXJlbnQpO1xuICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlLCBwYXJlbnQpO1xuICAgIH1cbiAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKHBhcmVudC5pZCwgbmFtZSk7XG4gICAgZm9yICh2YXIgbm9kZSA9IEZTLm5hbWVUYWJsZVtoYXNoXTsgbm9kZTsgbm9kZSA9IG5vZGUubmFtZV9uZXh0KSB7XG4gICAgICB2YXIgbm9kZU5hbWUgPSBub2RlLm5hbWU7XG4gICAgICBpZiAobm9kZS5wYXJlbnQuaWQgPT09IHBhcmVudC5pZCAmJiBub2RlTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEZTLmxvb2t1cChwYXJlbnQsIG5hbWUpO1xuICB9LFxuICBjcmVhdGVOb2RlOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgRlMuRlNOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgcmRldik7XG4gICAgRlMuaGFzaEFkZE5vZGUobm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG4gIGRlc3Ryb3lOb2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIEZTLmhhc2hSZW1vdmVOb2RlKG5vZGUpO1xuICB9LFxuICBpc1Jvb3Q6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgPT09IG5vZGUucGFyZW50O1xuICB9LFxuICBpc01vdW50cG9pbnQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuICEhbm9kZS5tb3VudGVkO1xuICB9LFxuICBpc0ZpbGU6IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSAzMjc2ODtcbiAgfSxcbiAgaXNEaXI6IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSAxNjM4NDtcbiAgfSxcbiAgaXNMaW5rOiBmdW5jdGlvbiAobW9kZSkge1xuICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gNDA5NjA7XG4gIH0sXG4gIGlzQ2hyZGV2OiBmdW5jdGlvbiAobW9kZSkge1xuICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gODE5MjtcbiAgfSxcbiAgaXNCbGtkZXY6IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSAyNDU3NjtcbiAgfSxcbiAgaXNGSUZPOiBmdW5jdGlvbiAobW9kZSkge1xuICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gNDA5NjtcbiAgfSxcbiAgaXNTb2NrZXQ6IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgcmV0dXJuIChtb2RlICYgNDkxNTIpID09PSA0OTE1MjtcbiAgfSxcbiAgZmxhZ01vZGVzOiB7IHI6IDAsICdyKyc6IDIsIHc6IDU3NywgJ3crJzogNTc4LCBhOiAxMDg5LCAnYSsnOiAxMDkwIH0sXG4gIG1vZGVTdHJpbmdUb0ZsYWdzOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIGZsYWdzID0gRlMuZmxhZ01vZGVzW3N0cl07XG4gICAgaWYgKHR5cGVvZiBmbGFncyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBmaWxlIG9wZW4gbW9kZTogJyArIHN0cik7XG4gICAgfVxuICAgIHJldHVybiBmbGFncztcbiAgfSxcbiAgZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmc6IGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgdmFyIHBlcm1zID0gWydyJywgJ3cnLCAncncnXVtmbGFnICYgM107XG4gICAgaWYgKGZsYWcgJiA1MTIpIHtcbiAgICAgIHBlcm1zICs9ICd3JztcbiAgICB9XG4gICAgcmV0dXJuIHBlcm1zO1xuICB9LFxuICBub2RlUGVybWlzc2lvbnM6IGZ1bmN0aW9uIChub2RlLCBwZXJtcykge1xuICAgIGlmIChGUy5pZ25vcmVQZXJtaXNzaW9ucykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChwZXJtcy5pbmNsdWRlcygncicpICYmICEobm9kZS5tb2RlICYgMjkyKSkge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfSBlbHNlIGlmIChwZXJtcy5pbmNsdWRlcygndycpICYmICEobm9kZS5tb2RlICYgMTQ2KSkge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfSBlbHNlIGlmIChwZXJtcy5pbmNsdWRlcygneCcpICYmICEobm9kZS5tb2RlICYgNzMpKSB7XG4gICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIG1heUxvb2t1cDogZnVuY3Rpb24gKGRpcikge1xuICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3gnKTtcbiAgICBpZiAoZXJyQ29kZSkgcmV0dXJuIGVyckNvZGU7XG4gICAgaWYgKCFkaXIubm9kZV9vcHMubG9va3VwKSByZXR1cm4gMjtcbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgbWF5Q3JlYXRlOiBmdW5jdGlvbiAoZGlyLCBuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShkaXIsIG5hbWUpO1xuICAgICAgcmV0dXJuIDIwO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsICd3eCcpO1xuICB9LFxuICBtYXlEZWxldGU6IGZ1bmN0aW9uIChkaXIsIG5hbWUsIGlzZGlyKSB7XG4gICAgdmFyIG5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIG5vZGUgPSBGUy5sb29rdXBOb2RlKGRpciwgbmFtZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGUuZXJybm87XG4gICAgfVxuICAgIHZhciBlcnJDb2RlID0gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3d4Jyk7XG4gICAgaWYgKGVyckNvZGUpIHtcbiAgICAgIHJldHVybiBlcnJDb2RlO1xuICAgIH1cbiAgICBpZiAoaXNkaXIpIHtcbiAgICAgIGlmICghRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgICByZXR1cm4gNTQ7XG4gICAgICB9XG4gICAgICBpZiAoRlMuaXNSb290KG5vZGUpIHx8IEZTLmdldFBhdGgobm9kZSkgPT09IEZTLmN3ZCgpKSB7XG4gICAgICAgIHJldHVybiAxMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKEZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgcmV0dXJuIDMxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgbWF5T3BlbjogZnVuY3Rpb24gKG5vZGUsIGZsYWdzKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gNDQ7XG4gICAgfVxuICAgIGlmIChGUy5pc0xpbmsobm9kZS5tb2RlKSkge1xuICAgICAgcmV0dXJuIDMyO1xuICAgIH0gZWxzZSBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkge1xuICAgICAgaWYgKEZTLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWdzKSAhPT0gJ3InIHx8IGZsYWdzICYgNTEyKSB7XG4gICAgICAgIHJldHVybiAzMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCBGUy5mbGFnc1RvUGVybWlzc2lvblN0cmluZyhmbGFncykpO1xuICB9LFxuICBNQVhfT1BFTl9GRFM6IDQwOTYsXG4gIG5leHRmZDogZnVuY3Rpb24gKGZkX3N0YXJ0LCBmZF9lbmQpIHtcbiAgICBmZF9zdGFydCA9IGZkX3N0YXJ0IHx8IDA7XG4gICAgZmRfZW5kID0gZmRfZW5kIHx8IEZTLk1BWF9PUEVOX0ZEUztcbiAgICBmb3IgKHZhciBmZCA9IGZkX3N0YXJ0OyBmZCA8PSBmZF9lbmQ7IGZkKyspIHtcbiAgICAgIGlmICghRlMuc3RyZWFtc1tmZF0pIHtcbiAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMyk7XG4gIH0sXG4gIGdldFN0cmVhbTogZnVuY3Rpb24gKGZkKSB7XG4gICAgcmV0dXJuIEZTLnN0cmVhbXNbZmRdO1xuICB9LFxuICBjcmVhdGVTdHJlYW06IGZ1bmN0aW9uIChzdHJlYW0sIGZkX3N0YXJ0LCBmZF9lbmQpIHtcbiAgICBpZiAoIUZTLkZTU3RyZWFtKSB7XG4gICAgICBGUy5GU1N0cmVhbSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgRlMuRlNTdHJlYW0ucHJvdG90eXBlID0ge1xuICAgICAgICBvYmplY3Q6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZSA9IHZhbDtcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBpc1JlYWQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIwOTcxNTUpICE9PSAxO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGlzV3JpdGU6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIwOTcxNTUpICE9PSAwO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGlzQXBwZW5kOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbGFncyAmIDEwMjQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuICAgIHZhciBuZXdTdHJlYW0gPSBuZXcgRlMuRlNTdHJlYW0oKTtcbiAgICBmb3IgKHZhciBwIGluIHN0cmVhbSkge1xuICAgICAgbmV3U3RyZWFtW3BdID0gc3RyZWFtW3BdO1xuICAgIH1cbiAgICBzdHJlYW0gPSBuZXdTdHJlYW07XG4gICAgdmFyIGZkID0gRlMubmV4dGZkKGZkX3N0YXJ0LCBmZF9lbmQpO1xuICAgIHN0cmVhbS5mZCA9IGZkO1xuICAgIEZTLnN0cmVhbXNbZmRdID0gc3RyZWFtO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH0sXG4gIGNsb3NlU3RyZWFtOiBmdW5jdGlvbiAoZmQpIHtcbiAgICBGUy5zdHJlYW1zW2ZkXSA9IG51bGw7XG4gIH0sXG4gIGNocmRldl9zdHJlYW1fb3BzOiB7XG4gICAgb3BlbjogZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgdmFyIGRldmljZSA9IEZTLmdldERldmljZShzdHJlYW0ubm9kZS5yZGV2KTtcbiAgICAgIHN0cmVhbS5zdHJlYW1fb3BzID0gZGV2aWNlLnN0cmVhbV9vcHM7XG4gICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMub3Blbikge1xuICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5vcGVuKHN0cmVhbSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBsbHNlZWs6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICB9LFxuICB9LFxuICBtYWpvcjogZnVuY3Rpb24gKGRldikge1xuICAgIHJldHVybiBkZXYgPj4gODtcbiAgfSxcbiAgbWlub3I6IGZ1bmN0aW9uIChkZXYpIHtcbiAgICByZXR1cm4gZGV2ICYgMjU1O1xuICB9LFxuICBtYWtlZGV2OiBmdW5jdGlvbiAobWEsIG1pKSB7XG4gICAgcmV0dXJuIChtYSA8PCA4KSB8IG1pO1xuICB9LFxuICByZWdpc3RlckRldmljZTogZnVuY3Rpb24gKGRldiwgb3BzKSB7XG4gICAgRlMuZGV2aWNlc1tkZXZdID0geyBzdHJlYW1fb3BzOiBvcHMgfTtcbiAgfSxcbiAgZ2V0RGV2aWNlOiBmdW5jdGlvbiAoZGV2KSB7XG4gICAgcmV0dXJuIEZTLmRldmljZXNbZGV2XTtcbiAgfSxcbiAgZ2V0TW91bnRzOiBmdW5jdGlvbiAobW91bnQpIHtcbiAgICB2YXIgbW91bnRzID0gW107XG4gICAgdmFyIGNoZWNrID0gW21vdW50XTtcbiAgICB3aGlsZSAoY2hlY2subGVuZ3RoKSB7XG4gICAgICB2YXIgbSA9IGNoZWNrLnBvcCgpO1xuICAgICAgbW91bnRzLnB1c2gobSk7XG4gICAgICBjaGVjay5wdXNoLmFwcGx5KGNoZWNrLCBtLm1vdW50cyk7XG4gICAgfVxuICAgIHJldHVybiBtb3VudHM7XG4gIH0sXG4gIHN5bmNmczogZnVuY3Rpb24gKHBvcHVsYXRlLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgcG9wdWxhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gcG9wdWxhdGU7XG4gICAgICBwb3B1bGF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBGUy5zeW5jRlNSZXF1ZXN0cysrO1xuICAgIGlmIChGUy5zeW5jRlNSZXF1ZXN0cyA+IDEpIHtcbiAgICAgIGVycihcbiAgICAgICAgJ3dhcm5pbmc6ICcgK1xuICAgICAgICAgIEZTLnN5bmNGU1JlcXVlc3RzICtcbiAgICAgICAgICAnIEZTLnN5bmNmcyBvcGVyYXRpb25zIGluIGZsaWdodCBhdCBvbmNlLCBwcm9iYWJseSBqdXN0IGRvaW5nIGV4dHJhIHdvcmsnXG4gICAgICApO1xuICAgIH1cbiAgICB2YXIgbW91bnRzID0gRlMuZ2V0TW91bnRzKEZTLnJvb3QubW91bnQpO1xuICAgIHZhciBjb21wbGV0ZWQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGVyckNvZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0NhbGxiYWNrKGVyckNvZGUpIHtcbiAgICAgIEZTLnN5bmNGU1JlcXVlc3RzLS07XG4gICAgICByZXR1cm4gY2FsbGJhY2soZXJyQ29kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGVyckNvZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb25lKGVyckNvZGUpIHtcbiAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgIGlmICghZG9uZS5lcnJvcmVkKSB7XG4gICAgICAgICAgZG9uZS5lcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gZG9DYWxsYmFjayhlcnJDb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKytjb21wbGV0ZWQgPj0gbW91bnRzLmxlbmd0aCkge1xuICAgICAgICBkb0NhbGxiYWNrKG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBtb3VudHMuZm9yRWFjaChmdW5jdGlvbiAobW91bnQpIHtcbiAgICAgIGlmICghbW91bnQudHlwZS5zeW5jZnMpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUobnVsbCk7XG4gICAgICB9XG4gICAgICBtb3VudC50eXBlLnN5bmNmcyhtb3VudCwgcG9wdWxhdGUsIGRvbmUpO1xuICAgIH0pO1xuICB9LFxuICBtb3VudDogZnVuY3Rpb24gKHR5cGUsIG9wdHMsIG1vdW50cG9pbnQpIHtcbiAgICB2YXIgcm9vdCA9IG1vdW50cG9pbnQgPT09ICcvJztcbiAgICB2YXIgcHNldWRvID0gIW1vdW50cG9pbnQ7XG4gICAgdmFyIG5vZGU7XG4gICAgaWYgKHJvb3QgJiYgRlMucm9vdCkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgIH0gZWxzZSBpZiAoIXJvb3QgJiYgIXBzZXVkbykge1xuICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobW91bnRwb2ludCwgeyBmb2xsb3dfbW91bnQ6IGZhbHNlIH0pO1xuICAgICAgbW91bnRwb2ludCA9IGxvb2t1cC5wYXRoO1xuICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCk7XG4gICAgICB9XG4gICAgICBpZiAoIUZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbW91bnQgPSB7IHR5cGU6IHR5cGUsIG9wdHM6IG9wdHMsIG1vdW50cG9pbnQ6IG1vdW50cG9pbnQsIG1vdW50czogW10gfTtcbiAgICB2YXIgbW91bnRSb290ID0gdHlwZS5tb3VudChtb3VudCk7XG4gICAgbW91bnRSb290Lm1vdW50ID0gbW91bnQ7XG4gICAgbW91bnQucm9vdCA9IG1vdW50Um9vdDtcbiAgICBpZiAocm9vdCkge1xuICAgICAgRlMucm9vdCA9IG1vdW50Um9vdDtcbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIG5vZGUubW91bnRlZCA9IG1vdW50O1xuICAgICAgaWYgKG5vZGUubW91bnQpIHtcbiAgICAgICAgbm9kZS5tb3VudC5tb3VudHMucHVzaChtb3VudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb3VudFJvb3Q7XG4gIH0sXG4gIHVubW91bnQ6IGZ1bmN0aW9uIChtb3VudHBvaW50KSB7XG4gICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobW91bnRwb2ludCwgeyBmb2xsb3dfbW91bnQ6IGZhbHNlIH0pO1xuICAgIGlmICghRlMuaXNNb3VudHBvaW50KGxvb2t1cC5ub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgIHZhciBtb3VudCA9IG5vZGUubW91bnRlZDtcbiAgICB2YXIgbW91bnRzID0gRlMuZ2V0TW91bnRzKG1vdW50KTtcbiAgICBPYmplY3Qua2V5cyhGUy5uYW1lVGFibGUpLmZvckVhY2goZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gRlMubmFtZVRhYmxlW2hhc2hdO1xuICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgdmFyIG5leHQgPSBjdXJyZW50Lm5hbWVfbmV4dDtcbiAgICAgICAgaWYgKG1vdW50cy5pbmNsdWRlcyhjdXJyZW50Lm1vdW50KSkge1xuICAgICAgICAgIEZTLmRlc3Ryb3lOb2RlKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgfVxuICAgIH0pO1xuICAgIG5vZGUubW91bnRlZCA9IG51bGw7XG4gICAgdmFyIGlkeCA9IG5vZGUubW91bnQubW91bnRzLmluZGV4T2YobW91bnQpO1xuICAgIG5vZGUubW91bnQubW91bnRzLnNwbGljZShpZHgsIDEpO1xuICB9LFxuICBsb29rdXA6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHtcbiAgICByZXR1cm4gcGFyZW50Lm5vZGVfb3BzLmxvb2t1cChwYXJlbnQsIG5hbWUpO1xuICB9LFxuICBta25vZDogZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGRldikge1xuICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTtcbiAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7XG4gICAgaWYgKCFuYW1lIHx8IG5hbWUgPT09ICcuJyB8fCBuYW1lID09PSAnLi4nKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgfVxuICAgIHZhciBlcnJDb2RlID0gRlMubWF5Q3JlYXRlKHBhcmVudCwgbmFtZSk7XG4gICAgaWYgKGVyckNvZGUpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudC5ub2RlX29wcy5ta25vZCkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Lm5vZGVfb3BzLm1rbm9kKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KTtcbiAgfSxcbiAgY3JlYXRlOiBmdW5jdGlvbiAocGF0aCwgbW9kZSkge1xuICAgIG1vZGUgPSBtb2RlICE9PSB1bmRlZmluZWQgPyBtb2RlIDogNDM4O1xuICAgIG1vZGUgJj0gNDA5NTtcbiAgICBtb2RlIHw9IDMyNzY4O1xuICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCAwKTtcbiAgfSxcbiAgbWtkaXI6IGZ1bmN0aW9uIChwYXRoLCBtb2RlKSB7XG4gICAgbW9kZSA9IG1vZGUgIT09IHVuZGVmaW5lZCA/IG1vZGUgOiA1MTE7XG4gICAgbW9kZSAmPSA1MTEgfCA1MTI7XG4gICAgbW9kZSB8PSAxNjM4NDtcbiAgICByZXR1cm4gRlMubWtub2QocGF0aCwgbW9kZSwgMCk7XG4gIH0sXG4gIG1rZGlyVHJlZTogZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICB2YXIgZGlycyA9IHBhdGguc3BsaXQoJy8nKTtcbiAgICB2YXIgZCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCFkaXJzW2ldKSBjb250aW51ZTtcbiAgICAgIGQgKz0gJy8nICsgZGlyc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIEZTLm1rZGlyKGQsIG1vZGUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5lcnJubyAhPSAyMCkgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1rZGV2OiBmdW5jdGlvbiAocGF0aCwgbW9kZSwgZGV2KSB7XG4gICAgaWYgKHR5cGVvZiBkZXYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkZXYgPSBtb2RlO1xuICAgICAgbW9kZSA9IDQzODtcbiAgICB9XG4gICAgbW9kZSB8PSA4MTkyO1xuICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCBkZXYpO1xuICB9LFxuICBzeW1saW5rOiBmdW5jdGlvbiAob2xkcGF0aCwgbmV3cGF0aCkge1xuICAgIGlmICghUEFUSF9GUy5yZXNvbHZlKG9sZHBhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgfVxuICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG5ld3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgIH1cbiAgICB2YXIgbmV3bmFtZSA9IFBBVEguYmFzZW5hbWUobmV3cGF0aCk7XG4gICAgdmFyIGVyckNvZGUgPSBGUy5tYXlDcmVhdGUocGFyZW50LCBuZXduYW1lKTtcbiAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgfVxuICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLnN5bWxpbmspIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5zeW1saW5rKHBhcmVudCwgbmV3bmFtZSwgb2xkcGF0aCk7XG4gIH0sXG4gIHJlbmFtZTogZnVuY3Rpb24gKG9sZF9wYXRoLCBuZXdfcGF0aCkge1xuICAgIHZhciBvbGRfZGlybmFtZSA9IFBBVEguZGlybmFtZShvbGRfcGF0aCk7XG4gICAgdmFyIG5ld19kaXJuYW1lID0gUEFUSC5kaXJuYW1lKG5ld19wYXRoKTtcbiAgICB2YXIgb2xkX25hbWUgPSBQQVRILmJhc2VuYW1lKG9sZF9wYXRoKTtcbiAgICB2YXIgbmV3X25hbWUgPSBQQVRILmJhc2VuYW1lKG5ld19wYXRoKTtcbiAgICB2YXIgbG9va3VwLCBvbGRfZGlyLCBuZXdfZGlyO1xuICAgIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgob2xkX3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pO1xuICAgIG9sZF9kaXIgPSBsb29rdXAubm9kZTtcbiAgICBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG5ld19wYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICBuZXdfZGlyID0gbG9va3VwLm5vZGU7XG4gICAgaWYgKCFvbGRfZGlyIHx8ICFuZXdfZGlyKSB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgaWYgKG9sZF9kaXIubW91bnQgIT09IG5ld19kaXIubW91bnQpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDc1KTtcbiAgICB9XG4gICAgdmFyIG9sZF9ub2RlID0gRlMubG9va3VwTm9kZShvbGRfZGlyLCBvbGRfbmFtZSk7XG4gICAgdmFyIHJlbGF0aXZlID0gUEFUSF9GUy5yZWxhdGl2ZShvbGRfcGF0aCwgbmV3X2Rpcm5hbWUpO1xuICAgIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgIT09ICcuJykge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgIH1cbiAgICByZWxhdGl2ZSA9IFBBVEhfRlMucmVsYXRpdmUobmV3X3BhdGgsIG9sZF9kaXJuYW1lKTtcbiAgICBpZiAocmVsYXRpdmUuY2hhckF0KDApICE9PSAnLicpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KTtcbiAgICB9XG4gICAgdmFyIG5ld19ub2RlO1xuICAgIHRyeSB7XG4gICAgICBuZXdfbm9kZSA9IEZTLmxvb2t1cE5vZGUobmV3X2RpciwgbmV3X25hbWUpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKG9sZF9ub2RlID09PSBuZXdfbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXNkaXIgPSBGUy5pc0RpcihvbGRfbm9kZS5tb2RlKTtcbiAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShvbGRfZGlyLCBvbGRfbmFtZSwgaXNkaXIpO1xuICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICB9XG4gICAgZXJyQ29kZSA9IG5ld19ub2RlID8gRlMubWF5RGVsZXRlKG5ld19kaXIsIG5ld19uYW1lLCBpc2RpcikgOiBGUy5tYXlDcmVhdGUobmV3X2RpciwgbmV3X25hbWUpO1xuICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICB9XG4gICAgaWYgKCFvbGRfZGlyLm5vZGVfb3BzLnJlbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgIH1cbiAgICBpZiAoRlMuaXNNb3VudHBvaW50KG9sZF9ub2RlKSB8fCAobmV3X25vZGUgJiYgRlMuaXNNb3VudHBvaW50KG5ld19ub2RlKSkpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICB9XG4gICAgaWYgKG5ld19kaXIgIT09IG9sZF9kaXIpIHtcbiAgICAgIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMob2xkX2RpciwgJ3cnKTtcbiAgICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBGUy5oYXNoUmVtb3ZlTm9kZShvbGRfbm9kZSk7XG4gICAgdHJ5IHtcbiAgICAgIG9sZF9kaXIubm9kZV9vcHMucmVuYW1lKG9sZF9ub2RlLCBuZXdfZGlyLCBuZXdfbmFtZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgRlMuaGFzaEFkZE5vZGUob2xkX25vZGUpO1xuICAgIH1cbiAgfSxcbiAgcm1kaXI6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7XG4gICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlO1xuICAgIHZhciBuYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICB2YXIgbm9kZSA9IEZTLmxvb2t1cE5vZGUocGFyZW50LCBuYW1lKTtcbiAgICB2YXIgZXJyQ29kZSA9IEZTLm1heURlbGV0ZShwYXJlbnQsIG5hbWUsIHRydWUpO1xuICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnQubm9kZV9vcHMucm1kaXIpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKTtcbiAgICB9XG4gICAgaWYgKEZTLmlzTW91bnRwb2ludChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApO1xuICAgIH1cbiAgICBwYXJlbnQubm9kZV9vcHMucm1kaXIocGFyZW50LCBuYW1lKTtcbiAgICBGUy5kZXN0cm95Tm9kZShub2RlKTtcbiAgfSxcbiAgcmVhZGRpcjogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgIGlmICghbm9kZS5ub2RlX29wcy5yZWFkZGlyKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NCk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLm5vZGVfb3BzLnJlYWRkaXIobm9kZSk7XG4gIH0sXG4gIHVubGluazogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICB2YXIgcGFyZW50ID0gbG9va3VwLm5vZGU7XG4gICAgdmFyIG5hbWUgPSBQQVRILmJhc2VuYW1lKHBhdGgpO1xuICAgIHZhciBub2RlID0gRlMubG9va3VwTm9kZShwYXJlbnQsIG5hbWUpO1xuICAgIHZhciBlcnJDb2RlID0gRlMubWF5RGVsZXRlKHBhcmVudCwgbmFtZSwgZmFsc2UpO1xuICAgIGlmIChlcnJDb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKTtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnQubm9kZV9vcHMudW5saW5rKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgfVxuICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKTtcbiAgICB9XG4gICAgcGFyZW50Lm5vZGVfb3BzLnVubGluayhwYXJlbnQsIG5hbWUpO1xuICAgIEZTLmRlc3Ryb3lOb2RlKG5vZGUpO1xuICB9LFxuICByZWFkbGluazogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoKTtcbiAgICB2YXIgbGluayA9IGxvb2t1cC5ub2RlO1xuICAgIGlmICghbGluaykge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgIH1cbiAgICBpZiAoIWxpbmsubm9kZV9vcHMucmVhZGxpbmspIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICB9XG4gICAgcmV0dXJuIFBBVEhfRlMucmVzb2x2ZShGUy5nZXRQYXRoKGxpbmsucGFyZW50KSwgbGluay5ub2RlX29wcy5yZWFkbGluayhsaW5rKSk7XG4gIH0sXG4gIHN0YXQ6IGZ1bmN0aW9uIChwYXRoLCBkb250Rm9sbG93KSB7XG4gICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250Rm9sbG93IH0pO1xuICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCk7XG4gICAgfVxuICAgIGlmICghbm9kZS5ub2RlX29wcy5nZXRhdHRyKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLm5vZGVfb3BzLmdldGF0dHIobm9kZSk7XG4gIH0sXG4gIGxzdGF0OiBmdW5jdGlvbiAocGF0aCkge1xuICAgIHJldHVybiBGUy5zdGF0KHBhdGgsIHRydWUpO1xuICB9LFxuICBjaG1vZDogZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGRvbnRGb2xsb3cpIHtcbiAgICB2YXIgbm9kZTtcbiAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7XG4gICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBwYXRoO1xuICAgIH1cbiAgICBpZiAoIW5vZGUubm9kZV9vcHMuc2V0YXR0cikge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpO1xuICAgIH1cbiAgICBub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSwge1xuICAgICAgbW9kZTogKG1vZGUgJiA0MDk1KSB8IChub2RlLm1vZGUgJiB+NDA5NSksXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgfSk7XG4gIH0sXG4gIGxjaG1vZDogZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHtcbiAgICBGUy5jaG1vZChwYXRoLCBtb2RlLCB0cnVlKTtcbiAgfSxcbiAgZmNobW9kOiBmdW5jdGlvbiAoZmQsIG1vZGUpIHtcbiAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTtcbiAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgfVxuICAgIEZTLmNobW9kKHN0cmVhbS5ub2RlLCBtb2RlKTtcbiAgfSxcbiAgY2hvd246IGZ1bmN0aW9uIChwYXRoLCB1aWQsIGdpZCwgZG9udEZvbGxvdykge1xuICAgIHZhciBub2RlO1xuICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udEZvbGxvdyB9KTtcbiAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IHBhdGg7XG4gICAgfVxuICAgIGlmICghbm9kZS5ub2RlX29wcy5zZXRhdHRyKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgfVxuICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7IHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9KTtcbiAgfSxcbiAgbGNob3duOiBmdW5jdGlvbiAocGF0aCwgdWlkLCBnaWQpIHtcbiAgICBGUy5jaG93bihwYXRoLCB1aWQsIGdpZCwgdHJ1ZSk7XG4gIH0sXG4gIGZjaG93bjogZnVuY3Rpb24gKGZkLCB1aWQsIGdpZCkge1xuICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgIGlmICghc3RyZWFtKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICB9XG4gICAgRlMuY2hvd24oc3RyZWFtLm5vZGUsIHVpZCwgZ2lkKTtcbiAgfSxcbiAgdHJ1bmNhdGU6IGZ1bmN0aW9uIChwYXRoLCBsZW4pIHtcbiAgICBpZiAobGVuIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgIH1cbiAgICB2YXIgbm9kZTtcbiAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICAgIG5vZGUgPSBsb29rdXAubm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IHBhdGg7XG4gICAgfVxuICAgIGlmICghbm9kZS5ub2RlX29wcy5zZXRhdHRyKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myk7XG4gICAgfVxuICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMSk7XG4gICAgfVxuICAgIGlmICghRlMuaXNGaWxlKG5vZGUubW9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICB9XG4gICAgdmFyIGVyckNvZGUgPSBGUy5ub2RlUGVybWlzc2lvbnMobm9kZSwgJ3cnKTtcbiAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgfVxuICAgIG5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLCB7IHNpemU6IGxlbiwgdGltZXN0YW1wOiBEYXRlLm5vdygpIH0pO1xuICB9LFxuICBmdHJ1bmNhdGU6IGZ1bmN0aW9uIChmZCwgbGVuKSB7XG4gICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbShmZCk7XG4gICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgIH1cbiAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgfVxuICAgIEZTLnRydW5jYXRlKHN0cmVhbS5ub2RlLCBsZW4pO1xuICB9LFxuICB1dGltZTogZnVuY3Rpb24gKHBhdGgsIGF0aW1lLCBtdGltZSkge1xuICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pO1xuICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgbm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUsIHsgdGltZXN0YW1wOiBNYXRoLm1heChhdGltZSwgbXRpbWUpIH0pO1xuICB9LFxuICBvcGVuOiBmdW5jdGlvbiAocGF0aCwgZmxhZ3MsIG1vZGUsIGZkX3N0YXJ0LCBmZF9lbmQpIHtcbiAgICBpZiAocGF0aCA9PT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICB9XG4gICAgZmxhZ3MgPSB0eXBlb2YgZmxhZ3MgPT09ICdzdHJpbmcnID8gRlMubW9kZVN0cmluZ1RvRmxhZ3MoZmxhZ3MpIDogZmxhZ3M7XG4gICAgbW9kZSA9IHR5cGVvZiBtb2RlID09PSAndW5kZWZpbmVkJyA/IDQzOCA6IG1vZGU7XG4gICAgaWYgKGZsYWdzICYgNjQpIHtcbiAgICAgIG1vZGUgPSAobW9kZSAmIDQwOTUpIHwgMzI3Njg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGUgPSAwO1xuICAgIH1cbiAgICB2YXIgbm9kZTtcbiAgICBpZiAodHlwZW9mIHBhdGggPT09ICdvYmplY3QnKSB7XG4gICAgICBub2RlID0gcGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IFBBVEgubm9ybWFsaXplKHBhdGgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICEoZmxhZ3MgJiAxMzEwNzIpIH0pO1xuICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cbiAgICB2YXIgY3JlYXRlZCA9IGZhbHNlO1xuICAgIGlmIChmbGFncyAmIDY0KSB7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBpZiAoZmxhZ3MgJiAxMjgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBGUy5ta25vZChwYXRoLCBtb2RlLCAwKTtcbiAgICAgICAgY3JlYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO1xuICAgIH1cbiAgICBpZiAoRlMuaXNDaHJkZXYobm9kZS5tb2RlKSkge1xuICAgICAgZmxhZ3MgJj0gfjUxMjtcbiAgICB9XG4gICAgaWYgKGZsYWdzICYgNjU1MzYgJiYgIUZTLmlzRGlyKG5vZGUubW9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDU0KTtcbiAgICB9XG4gICAgaWYgKCFjcmVhdGVkKSB7XG4gICAgICB2YXIgZXJyQ29kZSA9IEZTLm1heU9wZW4obm9kZSwgZmxhZ3MpO1xuICAgICAgaWYgKGVyckNvZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmbGFncyAmIDUxMikge1xuICAgICAgRlMudHJ1bmNhdGUobm9kZSwgMCk7XG4gICAgfVxuICAgIGZsYWdzICY9IH4oMTI4IHwgNTEyIHwgMTMxMDcyKTtcbiAgICB2YXIgc3RyZWFtID0gRlMuY3JlYXRlU3RyZWFtKFxuICAgICAge1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBwYXRoOiBGUy5nZXRQYXRoKG5vZGUpLFxuICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgZmxhZ3M6IGZsYWdzLFxuICAgICAgICBtb2RlOiBub2RlLm1vZGUsXG4gICAgICAgIHNlZWthYmxlOiB0cnVlLFxuICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgc3RyZWFtX29wczogbm9kZS5zdHJlYW1fb3BzLFxuICAgICAgICBub2RlX29wczogbm9kZS5ub2RlX29wcyxcbiAgICAgICAgdW5nb3R0ZW46IFtdLFxuICAgICAgICBlcnJvcjogZmFsc2UsXG4gICAgICB9LFxuICAgICAgZmRfc3RhcnQsXG4gICAgICBmZF9lbmRcbiAgICApO1xuICAgIGlmIChzdHJlYW0uc3RyZWFtX29wcy5vcGVuKSB7XG4gICAgICBzdHJlYW0uc3RyZWFtX29wcy5vcGVuKHN0cmVhbSk7XG4gICAgfVxuICAgIGlmIChNb2R1bGVbJ2xvZ1JlYWRGaWxlcyddICYmICEoZmxhZ3MgJiAxKSkge1xuICAgICAgaWYgKCFGUy5yZWFkRmlsZXMpIEZTLnJlYWRGaWxlcyA9IHt9O1xuICAgICAgaWYgKCEocGF0aCBpbiBGUy5yZWFkRmlsZXMpKSB7XG4gICAgICAgIEZTLnJlYWRGaWxlc1twYXRoXSA9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW07XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmdldGRlbnRzKSBzdHJlYW0uZ2V0ZGVudHMgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMuY2xvc2UpIHtcbiAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBGUy5jbG9zZVN0cmVhbShzdHJlYW0uZmQpO1xuICAgIH1cbiAgICBzdHJlYW0uZmQgPSBudWxsO1xuICB9LFxuICBpc0Nsb3NlZDogZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIHJldHVybiBzdHJlYW0uZmQgPT09IG51bGw7XG4gIH0sXG4gIGxsc2VlazogZnVuY3Rpb24gKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpIHtcbiAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgfVxuICAgIGlmICghc3RyZWFtLnNlZWthYmxlIHx8ICFzdHJlYW0uc3RyZWFtX29wcy5sbHNlZWspIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKTtcbiAgICB9XG4gICAgaWYgKHdoZW5jZSAhPSAwICYmIHdoZW5jZSAhPSAxICYmIHdoZW5jZSAhPSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgfVxuICAgIHN0cmVhbS5wb3NpdGlvbiA9IHN0cmVhbS5zdHJlYW1fb3BzLmxsc2VlayhzdHJlYW0sIG9mZnNldCwgd2hlbmNlKTtcbiAgICBzdHJlYW0udW5nb3R0ZW4gPSBbXTtcbiAgICByZXR1cm4gc3RyZWFtLnBvc2l0aW9uO1xuICB9LFxuICByZWFkOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgIGlmIChsZW5ndGggPCAwIHx8IHBvc2l0aW9uIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpO1xuICAgIH1cbiAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgfVxuICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgIH1cbiAgICBpZiAoRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDMxKTtcbiAgICB9XG4gICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5yZWFkKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgfVxuICAgIHZhciBzZWVraW5nID0gdHlwZW9mIHBvc2l0aW9uICE9PSAndW5kZWZpbmVkJztcbiAgICBpZiAoIXNlZWtpbmcpIHtcbiAgICAgIHBvc2l0aW9uID0gc3RyZWFtLnBvc2l0aW9uO1xuICAgIH0gZWxzZSBpZiAoIXN0cmVhbS5zZWVrYWJsZSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNzApO1xuICAgIH1cbiAgICB2YXIgYnl0ZXNSZWFkID0gc3RyZWFtLnN0cmVhbV9vcHMucmVhZChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTtcbiAgICBpZiAoIXNlZWtpbmcpIHN0cmVhbS5wb3NpdGlvbiArPSBieXRlc1JlYWQ7XG4gICAgcmV0dXJuIGJ5dGVzUmVhZDtcbiAgfSxcbiAgd3JpdGU6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYW5Pd24pIHtcbiAgICBpZiAobGVuZ3RoIDwgMCB8fCBwb3NpdGlvbiA8IDApIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICB9XG4gICAgaWYgKEZTLmlzQ2xvc2VkKHN0cmVhbSkpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgIH1cbiAgICBpZiAoKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICB9XG4gICAgaWYgKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMSk7XG4gICAgfVxuICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMud3JpdGUpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5zZWVrYWJsZSAmJiBzdHJlYW0uZmxhZ3MgJiAxMDI0KSB7XG4gICAgICBGUy5sbHNlZWsoc3RyZWFtLCAwLCAyKTtcbiAgICB9XG4gICAgdmFyIHNlZWtpbmcgPSB0eXBlb2YgcG9zaXRpb24gIT09ICd1bmRlZmluZWQnO1xuICAgIGlmICghc2Vla2luZykge1xuICAgICAgcG9zaXRpb24gPSBzdHJlYW0ucG9zaXRpb247XG4gICAgfSBlbHNlIGlmICghc3RyZWFtLnNlZWthYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCk7XG4gICAgfVxuICAgIHZhciBieXRlc1dyaXR0ZW4gPSBzdHJlYW0uc3RyZWFtX29wcy53cml0ZShzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYW5Pd24pO1xuICAgIGlmICghc2Vla2luZykgc3RyZWFtLnBvc2l0aW9uICs9IGJ5dGVzV3JpdHRlbjtcbiAgICByZXR1cm4gYnl0ZXNXcml0dGVuO1xuICB9LFxuICBhbGxvY2F0ZTogZnVuY3Rpb24gKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgfVxuICAgIGlmIChvZmZzZXQgPCAwIHx8IGxlbmd0aCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCk7XG4gICAgfVxuICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgIH1cbiAgICBpZiAoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSAmJiAhRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKTtcbiAgICB9XG4gICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5hbGxvY2F0ZSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTM4KTtcbiAgICB9XG4gICAgc3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUoc3RyZWFtLCBvZmZzZXQsIGxlbmd0aCk7XG4gIH0sXG4gIG1tYXA6IGZ1bmN0aW9uIChzdHJlYW0sIGFkZHJlc3MsIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKSB7XG4gICAgaWYgKChwcm90ICYgMikgIT09IDAgJiYgKGZsYWdzICYgMikgPT09IDAgJiYgKHN0cmVhbS5mbGFncyAmIDIwOTcxNTUpICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyKTtcbiAgICB9XG4gICAgaWYgKChzdHJlYW0uZmxhZ3MgJiAyMDk3MTU1KSA9PT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMik7XG4gICAgfVxuICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMubW1hcCkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubW1hcChzdHJlYW0sIGFkZHJlc3MsIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKTtcbiAgfSxcbiAgbXN5bmM6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIG1tYXBGbGFncykge1xuICAgIGlmICghc3RyZWFtIHx8ICFzdHJlYW0uc3RyZWFtX29wcy5tc3luYykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5tc3luYyhzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIG1tYXBGbGFncyk7XG4gIH0sXG4gIG11bm1hcDogZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIHJldHVybiAwO1xuICB9LFxuICBpb2N0bDogZnVuY3Rpb24gKHN0cmVhbSwgY21kLCBhcmcpIHtcbiAgICBpZiAoIXN0cmVhbS5zdHJlYW1fb3BzLmlvY3RsKSB7XG4gICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1OSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5pb2N0bChzdHJlYW0sIGNtZCwgYXJnKTtcbiAgfSxcbiAgcmVhZEZpbGU6IGZ1bmN0aW9uIChwYXRoLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgb3B0cy5mbGFncyA9IG9wdHMuZmxhZ3MgfHwgMDtcbiAgICBvcHRzLmVuY29kaW5nID0gb3B0cy5lbmNvZGluZyB8fCAnYmluYXJ5JztcbiAgICBpZiAob3B0cy5lbmNvZGluZyAhPT0gJ3V0ZjgnICYmIG9wdHMuZW5jb2RpbmcgIT09ICdiaW5hcnknKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2RpbmcgdHlwZSBcIicgKyBvcHRzLmVuY29kaW5nICsgJ1wiJyk7XG4gICAgfVxuICAgIHZhciByZXQ7XG4gICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4ocGF0aCwgb3B0cy5mbGFncyk7XG4gICAgdmFyIHN0YXQgPSBGUy5zdGF0KHBhdGgpO1xuICAgIHZhciBsZW5ndGggPSBzdGF0LnNpemU7XG4gICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgRlMucmVhZChzdHJlYW0sIGJ1ZiwgMCwgbGVuZ3RoLCAwKTtcbiAgICBpZiAob3B0cy5lbmNvZGluZyA9PT0gJ3V0ZjgnKSB7XG4gICAgICByZXQgPSBVVEY4QXJyYXlUb1N0cmluZyhidWYsIDApO1xuICAgIH0gZWxzZSBpZiAob3B0cy5lbmNvZGluZyA9PT0gJ2JpbmFyeScpIHtcbiAgICAgIHJldCA9IGJ1ZjtcbiAgICB9XG4gICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICB3cml0ZUZpbGU6IGZ1bmN0aW9uIChwYXRoLCBkYXRhLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgb3B0cy5mbGFncyA9IG9wdHMuZmxhZ3MgfHwgNTc3O1xuICAgIHZhciBzdHJlYW0gPSBGUy5vcGVuKHBhdGgsIG9wdHMuZmxhZ3MsIG9wdHMubW9kZSk7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aEJ5dGVzVVRGOChkYXRhKSArIDEpO1xuICAgICAgdmFyIGFjdHVhbE51bUJ5dGVzID0gc3RyaW5nVG9VVEY4QXJyYXkoZGF0YSwgYnVmLCAwLCBidWYubGVuZ3RoKTtcbiAgICAgIEZTLndyaXRlKHN0cmVhbSwgYnVmLCAwLCBhY3R1YWxOdW1CeXRlcywgdW5kZWZpbmVkLCBvcHRzLmNhbk93bik7XG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICAgIEZTLndyaXRlKHN0cmVhbSwgZGF0YSwgMCwgZGF0YS5ieXRlTGVuZ3RoLCB1bmRlZmluZWQsIG9wdHMuY2FuT3duKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBkYXRhIHR5cGUnKTtcbiAgICB9XG4gICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgfSxcbiAgY3dkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEZTLmN1cnJlbnRQYXRoO1xuICB9LFxuICBjaGRpcjogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICBpZiAobG9va3VwLm5vZGUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICB9XG4gICAgaWYgKCFGUy5pc0Rpcihsb29rdXAubm9kZS5tb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpO1xuICAgIH1cbiAgICB2YXIgZXJyQ29kZSA9IEZTLm5vZGVQZXJtaXNzaW9ucyhsb29rdXAubm9kZSwgJ3gnKTtcbiAgICBpZiAoZXJyQ29kZSkge1xuICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSk7XG4gICAgfVxuICAgIEZTLmN1cnJlbnRQYXRoID0gbG9va3VwLnBhdGg7XG4gIH0sXG4gIGNyZWF0ZURlZmF1bHREaXJlY3RvcmllczogZnVuY3Rpb24gKCkge1xuICAgIEZTLm1rZGlyKCcvdG1wJyk7XG4gICAgRlMubWtkaXIoJy9ob21lJyk7XG4gICAgRlMubWtkaXIoJy9ob21lL3dlYl91c2VyJyk7XG4gIH0sXG4gIGNyZWF0ZURlZmF1bHREZXZpY2VzOiBmdW5jdGlvbiAoKSB7XG4gICAgRlMubWtkaXIoJy9kZXYnKTtcbiAgICBGUy5yZWdpc3RlckRldmljZShGUy5tYWtlZGV2KDEsIDMpLCB7XG4gICAgICByZWFkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgRlMubWtkZXYoJy9kZXYvbnVsbCcsIEZTLm1ha2VkZXYoMSwgMykpO1xuICAgIFRUWS5yZWdpc3RlcihGUy5tYWtlZGV2KDUsIDApLCBUVFkuZGVmYXVsdF90dHlfb3BzKTtcbiAgICBUVFkucmVnaXN0ZXIoRlMubWFrZWRldig2LCAwKSwgVFRZLmRlZmF1bHRfdHR5MV9vcHMpO1xuICAgIEZTLm1rZGV2KCcvZGV2L3R0eScsIEZTLm1ha2VkZXYoNSwgMCkpO1xuICAgIEZTLm1rZGV2KCcvZGV2L3R0eTEnLCBGUy5tYWtlZGV2KDYsIDApKTtcbiAgICB2YXIgcmFuZG9tX2RldmljZSA9IGdldFJhbmRvbURldmljZSgpO1xuICAgIEZTLmNyZWF0ZURldmljZSgnL2RldicsICdyYW5kb20nLCByYW5kb21fZGV2aWNlKTtcbiAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAndXJhbmRvbScsIHJhbmRvbV9kZXZpY2UpO1xuICAgIEZTLm1rZGlyKCcvZGV2L3NobScpO1xuICAgIEZTLm1rZGlyKCcvZGV2L3NobS90bXAnKTtcbiAgfSxcbiAgY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgRlMubWtkaXIoJy9wcm9jJyk7XG4gICAgdmFyIHByb2Nfc2VsZiA9IEZTLm1rZGlyKCcvcHJvYy9zZWxmJyk7XG4gICAgRlMubWtkaXIoJy9wcm9jL3NlbGYvZmQnKTtcbiAgICBGUy5tb3VudChcbiAgICAgIHtcbiAgICAgICAgbW91bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZU5vZGUocHJvY19zZWxmLCAnZmQnLCAxNjM4NCB8IDUxMSwgNzMpO1xuICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSB7XG4gICAgICAgICAgICBsb29rdXA6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIGZkID0gK25hbWU7XG4gICAgICAgICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpO1xuICAgICAgICAgICAgICBpZiAoIXN0cmVhbSkgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCk7XG4gICAgICAgICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIG1vdW50OiB7IG1vdW50cG9pbnQ6ICdmYWtlJyB9LFxuICAgICAgICAgICAgICAgIG5vZGVfb3BzOiB7XG4gICAgICAgICAgICAgICAgICByZWFkbGluazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyZWFtLnBhdGg7XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldC5wYXJlbnQgPSByZXQ7XG4gICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge30sXG4gICAgICAnL3Byb2Mvc2VsZi9mZCdcbiAgICApO1xuICB9LFxuICBjcmVhdGVTdGFuZGFyZFN0cmVhbXM6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoTW9kdWxlWydzdGRpbiddKSB7XG4gICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAnc3RkaW4nLCBNb2R1bGVbJ3N0ZGluJ10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBGUy5zeW1saW5rKCcvZGV2L3R0eScsICcvZGV2L3N0ZGluJyk7XG4gICAgfVxuICAgIGlmIChNb2R1bGVbJ3N0ZG91dCddKSB7XG4gICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAnc3Rkb3V0JywgbnVsbCwgTW9kdWxlWydzdGRvdXQnXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5JywgJy9kZXYvc3Rkb3V0Jyk7XG4gICAgfVxuICAgIGlmIChNb2R1bGVbJ3N0ZGVyciddKSB7XG4gICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAnc3RkZXJyJywgbnVsbCwgTW9kdWxlWydzdGRlcnInXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5MScsICcvZGV2L3N0ZGVycicpO1xuICAgIH1cbiAgICB2YXIgc3RkaW4gPSBGUy5vcGVuKCcvZGV2L3N0ZGluJywgMCk7XG4gICAgdmFyIHN0ZG91dCA9IEZTLm9wZW4oJy9kZXYvc3Rkb3V0JywgMSk7XG4gICAgdmFyIHN0ZGVyciA9IEZTLm9wZW4oJy9kZXYvc3RkZXJyJywgMSk7XG4gIH0sXG4gIGVuc3VyZUVycm5vRXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoRlMuRXJybm9FcnJvcikgcmV0dXJuO1xuICAgIEZTLkVycm5vRXJyb3IgPSBmdW5jdGlvbiBFcnJub0Vycm9yKGVycm5vLCBub2RlKSB7XG4gICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgdGhpcy5zZXRFcnJubyA9IGZ1bmN0aW9uIChlcnJubykge1xuICAgICAgICB0aGlzLmVycm5vID0gZXJybm87XG4gICAgICB9O1xuICAgICAgdGhpcy5zZXRFcnJubyhlcnJubyk7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSAnRlMgZXJyb3InO1xuICAgIH07XG4gICAgRlMuRXJybm9FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgICBGUy5FcnJub0Vycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZTLkVycm5vRXJyb3I7XG4gICAgWzQ0XS5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICBGUy5nZW5lcmljRXJyb3JzW2NvZGVdID0gbmV3IEZTLkVycm5vRXJyb3IoY29kZSk7XG4gICAgICBGUy5nZW5lcmljRXJyb3JzW2NvZGVdLnN0YWNrID0gJzxnZW5lcmljIGVycm9yLCBubyBzdGFjaz4nO1xuICAgIH0pO1xuICB9LFxuICBzdGF0aWNJbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgRlMuZW5zdXJlRXJybm9FcnJvcigpO1xuICAgIEZTLm5hbWVUYWJsZSA9IG5ldyBBcnJheSg0MDk2KTtcbiAgICBGUy5tb3VudChNRU1GUywge30sICcvJyk7XG4gICAgRlMuY3JlYXRlRGVmYXVsdERpcmVjdG9yaWVzKCk7XG4gICAgRlMuY3JlYXRlRGVmYXVsdERldmljZXMoKTtcbiAgICBGUy5jcmVhdGVTcGVjaWFsRGlyZWN0b3JpZXMoKTtcbiAgICBGUy5maWxlc3lzdGVtcyA9IHsgTUVNRlM6IE1FTUZTIH07XG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIChpbnB1dCwgb3V0cHV0LCBlcnJvcikge1xuICAgIEZTLmluaXQuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIEZTLmVuc3VyZUVycm5vRXJyb3IoKTtcbiAgICBNb2R1bGVbJ3N0ZGluJ10gPSBpbnB1dCB8fCBNb2R1bGVbJ3N0ZGluJ107XG4gICAgTW9kdWxlWydzdGRvdXQnXSA9IG91dHB1dCB8fCBNb2R1bGVbJ3N0ZG91dCddO1xuICAgIE1vZHVsZVsnc3RkZXJyJ10gPSBlcnJvciB8fCBNb2R1bGVbJ3N0ZGVyciddO1xuICAgIEZTLmNyZWF0ZVN0YW5kYXJkU3RyZWFtcygpO1xuICB9LFxuICBxdWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgRlMuaW5pdC5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHZhciBmZmx1c2ggPSBNb2R1bGVbJ19mZmx1c2gnXTtcbiAgICBpZiAoZmZsdXNoKSBmZmx1c2goMCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBGUy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc3RyZWFtID0gRlMuc3RyZWFtc1tpXTtcbiAgICAgIGlmICghc3RyZWFtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICB9XG4gIH0sXG4gIGdldE1vZGU6IGZ1bmN0aW9uIChjYW5SZWFkLCBjYW5Xcml0ZSkge1xuICAgIHZhciBtb2RlID0gMDtcbiAgICBpZiAoY2FuUmVhZCkgbW9kZSB8PSAyOTIgfCA3MztcbiAgICBpZiAoY2FuV3JpdGUpIG1vZGUgfD0gMTQ2O1xuICAgIHJldHVybiBtb2RlO1xuICB9LFxuICBmaW5kT2JqZWN0OiBmdW5jdGlvbiAocGF0aCwgZG9udFJlc29sdmVMYXN0TGluaykge1xuICAgIHZhciByZXQgPSBGUy5hbmFseXplUGF0aChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKTtcbiAgICBpZiAocmV0LmV4aXN0cykge1xuICAgICAgcmV0dXJuIHJldC5vYmplY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgYW5hbHl6ZVBhdGg6IGZ1bmN0aW9uIChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udFJlc29sdmVMYXN0TGluayB9KTtcbiAgICAgIHBhdGggPSBsb29rdXAucGF0aDtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHZhciByZXQgPSB7XG4gICAgICBpc1Jvb3Q6IGZhbHNlLFxuICAgICAgZXhpc3RzOiBmYWxzZSxcbiAgICAgIGVycm9yOiAwLFxuICAgICAgbmFtZTogbnVsbCxcbiAgICAgIHBhdGg6IG51bGwsXG4gICAgICBvYmplY3Q6IG51bGwsXG4gICAgICBwYXJlbnRFeGlzdHM6IGZhbHNlLFxuICAgICAgcGFyZW50UGF0aDogbnVsbCxcbiAgICAgIHBhcmVudE9iamVjdDogbnVsbCxcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IHBhcmVudDogdHJ1ZSB9KTtcbiAgICAgIHJldC5wYXJlbnRFeGlzdHMgPSB0cnVlO1xuICAgICAgcmV0LnBhcmVudFBhdGggPSBsb29rdXAucGF0aDtcbiAgICAgIHJldC5wYXJlbnRPYmplY3QgPSBsb29rdXAubm9kZTtcbiAgICAgIHJldC5uYW1lID0gUEFUSC5iYXNlbmFtZShwYXRoKTtcbiAgICAgIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250UmVzb2x2ZUxhc3RMaW5rIH0pO1xuICAgICAgcmV0LmV4aXN0cyA9IHRydWU7XG4gICAgICByZXQucGF0aCA9IGxvb2t1cC5wYXRoO1xuICAgICAgcmV0Lm9iamVjdCA9IGxvb2t1cC5ub2RlO1xuICAgICAgcmV0Lm5hbWUgPSBsb29rdXAubm9kZS5uYW1lO1xuICAgICAgcmV0LmlzUm9vdCA9IGxvb2t1cC5wYXRoID09PSAnLyc7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0LmVycm9yID0gZS5lcnJubztcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgY3JlYXRlUGF0aDogZnVuY3Rpb24gKHBhcmVudCwgcGF0aCwgY2FuUmVhZCwgY2FuV3JpdGUpIHtcbiAgICBwYXJlbnQgPSB0eXBlb2YgcGFyZW50ID09PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KTtcbiAgICB2YXIgcGFydHMgPSBwYXRoLnNwbGl0KCcvJykucmV2ZXJzZSgpO1xuICAgIHdoaWxlIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgIHZhciBwYXJ0ID0gcGFydHMucG9wKCk7XG4gICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgdmFyIGN1cnJlbnQgPSBQQVRILmpvaW4yKHBhcmVudCwgcGFydCk7XG4gICAgICB0cnkge1xuICAgICAgICBGUy5ta2RpcihjdXJyZW50KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICBwYXJlbnQgPSBjdXJyZW50O1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbiAgfSxcbiAgY3JlYXRlRmlsZTogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSwgcHJvcGVydGllcywgY2FuUmVhZCwgY2FuV3JpdGUpIHtcbiAgICB2YXIgcGF0aCA9IFBBVEguam9pbjIodHlwZW9mIHBhcmVudCA9PT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCksIG5hbWUpO1xuICAgIHZhciBtb2RlID0gRlMuZ2V0TW9kZShjYW5SZWFkLCBjYW5Xcml0ZSk7XG4gICAgcmV0dXJuIEZTLmNyZWF0ZShwYXRoLCBtb2RlKTtcbiAgfSxcbiAgY3JlYXRlRGF0YUZpbGU6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUsIGRhdGEsIGNhblJlYWQsIGNhbldyaXRlLCBjYW5Pd24pIHtcbiAgICB2YXIgcGF0aCA9IG5hbWVcbiAgICAgID8gUEFUSC5qb2luMih0eXBlb2YgcGFyZW50ID09PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KSwgbmFtZSlcbiAgICAgIDogcGFyZW50O1xuICAgIHZhciBtb2RlID0gRlMuZ2V0TW9kZShjYW5SZWFkLCBjYW5Xcml0ZSk7XG4gICAgdmFyIG5vZGUgPSBGUy5jcmVhdGUocGF0aCwgbW9kZSk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGFyciA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgKytpKSBhcnJbaV0gPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGRhdGEgPSBhcnI7XG4gICAgICB9XG4gICAgICBGUy5jaG1vZChub2RlLCBtb2RlIHwgMTQ2KTtcbiAgICAgIHZhciBzdHJlYW0gPSBGUy5vcGVuKG5vZGUsIDU3Nyk7XG4gICAgICBGUy53cml0ZShzdHJlYW0sIGRhdGEsIDAsIGRhdGEubGVuZ3RoLCAwLCBjYW5Pd24pO1xuICAgICAgRlMuY2xvc2Uoc3RyZWFtKTtcbiAgICAgIEZTLmNobW9kKG5vZGUsIG1vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcbiAgY3JlYXRlRGV2aWNlOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBpbnB1dCwgb3V0cHV0KSB7XG4gICAgdmFyIHBhdGggPSBQQVRILmpvaW4yKHR5cGVvZiBwYXJlbnQgPT09ICdzdHJpbmcnID8gcGFyZW50IDogRlMuZ2V0UGF0aChwYXJlbnQpLCBuYW1lKTtcbiAgICB2YXIgbW9kZSA9IEZTLmdldE1vZGUoISFpbnB1dCwgISFvdXRwdXQpO1xuICAgIGlmICghRlMuY3JlYXRlRGV2aWNlLm1ham9yKSBGUy5jcmVhdGVEZXZpY2UubWFqb3IgPSA2NDtcbiAgICB2YXIgZGV2ID0gRlMubWFrZWRldihGUy5jcmVhdGVEZXZpY2UubWFqb3IrKywgMCk7XG4gICAgRlMucmVnaXN0ZXJEZXZpY2UoZGV2LCB7XG4gICAgICBvcGVuOiBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5zZWVrYWJsZSA9IGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGNsb3NlOiBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIGlmIChvdXRwdXQgJiYgb3V0cHV0LmJ1ZmZlciAmJiBvdXRwdXQuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgIG91dHB1dCgxMCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZWFkOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpIHtcbiAgICAgICAgdmFyIGJ5dGVzUmVhZCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpbnB1dCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIGJ5dGVzUmVhZCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpIGJyZWFrO1xuICAgICAgICAgIGJ5dGVzUmVhZCsrO1xuICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZXNSZWFkKSB7XG4gICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXNSZWFkO1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXRwdXQoYnVmZmVyW29mZnNldCArIGldKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gRlMubWtkZXYocGF0aCwgbW9kZSwgZGV2KTtcbiAgfSxcbiAgZm9yY2VMb2FkRmlsZTogZnVuY3Rpb24gKG9iaikge1xuICAgIGlmIChvYmouaXNEZXZpY2UgfHwgb2JqLmlzRm9sZGVyIHx8IG9iai5saW5rIHx8IG9iai5jb250ZW50cykgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0xhenkgbG9hZGluZyBzaG91bGQgaGF2ZSBiZWVuIHBlcmZvcm1lZCAoY29udGVudHMgc2V0KSBpbiBjcmVhdGVMYXp5RmlsZSwgYnV0IGl0IHdhcyBub3QuIExhenkgbG9hZGluZyBvbmx5IHdvcmtzIGluIHdlYiB3b3JrZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2Mgb24gdGhlIG1haW4gdGhyZWFkLidcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChyZWFkXykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb2JqLmNvbnRlbnRzID0gaW50QXJyYXlGcm9tU3RyaW5nKHJlYWRfKG9iai51cmwpLCB0cnVlKTtcbiAgICAgICAgb2JqLnVzZWRCeXRlcyA9IG9iai5jb250ZW50cy5sZW5ndGg7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbG9hZCB3aXRob3V0IHJlYWQoKSBvciBYTUxIdHRwUmVxdWVzdC4nKTtcbiAgICB9XG4gIH0sXG4gIGNyZWF0ZUxhenlGaWxlOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCB1cmwsIGNhblJlYWQsIGNhbldyaXRlKSB7XG5cbiAgICBmdW5jdGlvbiBMYXp5VWludDhBcnJheSgpIHtcbiAgICAgIHRoaXMubGVuZ3RoS25vd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgfVxuICAgIExhenlVaW50OEFycmF5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBMYXp5VWludDhBcnJheV9nZXQoaWR4KSB7XG4gICAgICBpZiAoaWR4ID4gdGhpcy5sZW5ndGggLSAxIHx8IGlkeCA8IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHZhciBjaHVua09mZnNldCA9IGlkeCAlIHRoaXMuY2h1bmtTaXplO1xuICAgICAgdmFyIGNodW5rTnVtID0gKGlkeCAvIHRoaXMuY2h1bmtTaXplKSB8IDA7XG4gICAgICByZXR1cm4gdGhpcy5nZXR0ZXIoY2h1bmtOdW0pW2NodW5rT2Zmc2V0XTtcbiAgICB9O1xuICAgIExhenlVaW50OEFycmF5LnByb3RvdHlwZS5zZXREYXRhR2V0dGVyID0gZnVuY3Rpb24gTGF6eVVpbnQ4QXJyYXlfc2V0RGF0YUdldHRlcihnZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZ2V0dGVyO1xuICAgIH07XG4gICAgTGF6eVVpbnQ4QXJyYXkucHJvdG90eXBlLmNhY2hlTGVuZ3RoID0gZnVuY3Rpb24gTGF6eVVpbnQ4QXJyYXlfY2FjaGVMZW5ndGgoKSB7XG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICB4aHIub3BlbignSEVBRCcsIHVybCwgZmFsc2UpO1xuICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICBpZiAoISgoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkgfHwgeGhyLnN0YXR1cyA9PT0gMzA0KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgbG9hZCBcIiArIHVybCArICcuIFN0YXR1czogJyArIHhoci5zdGF0dXMpO1xuICAgICAgdmFyIGRhdGFsZW5ndGggPSBOdW1iZXIoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LWxlbmd0aCcpKTtcbiAgICAgIHZhciBoZWFkZXI7XG4gICAgICB2YXIgaGFzQnl0ZVNlcnZpbmcgPSAoaGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdBY2NlcHQtUmFuZ2VzJykpICYmIGhlYWRlciA9PT0gJ2J5dGVzJztcbiAgICAgIHZhciB1c2VzR3ppcCA9IChoZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtRW5jb2RpbmcnKSkgJiYgaGVhZGVyID09PSAnZ3ppcCc7XG4gICAgICB2YXIgY2h1bmtTaXplID0gMTAyNCAqIDEwMjQ7XG4gICAgICBpZiAoIWhhc0J5dGVTZXJ2aW5nKSBjaHVua1NpemUgPSBkYXRhbGVuZ3RoO1xuICAgICAgdmFyIGRvWEhSID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChmcm9tID4gdG8pXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJhbmdlICgnICsgZnJvbSArICcsICcgKyB0byArICcpIG9yIG5vIGJ5dGVzIHJlcXVlc3RlZCEnKTtcbiAgICAgICAgaWYgKHRvID4gZGF0YWxlbmd0aCAtIDEpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbmx5ICcgKyBkYXRhbGVuZ3RoICsgJyBieXRlcyBhdmFpbGFibGUhIHByb2dyYW1tZXIgZXJyb3IhJyk7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UpO1xuICAgICAgICBpZiAoZGF0YWxlbmd0aCAhPT0gY2h1bmtTaXplKSB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCAnYnl0ZXM9JyArIGZyb20gKyAnLScgKyB0byk7XG4gICAgICAgIGlmICh0eXBlb2YgVWludDhBcnJheSAhPSAndW5kZWZpbmVkJykgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIGlmICh4aHIub3ZlcnJpZGVNaW1lVHlwZSkge1xuICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICAgIGlmICghKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09PSAzMDQpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGxvYWQgXCIgKyB1cmwgKyAnLiBTdGF0dXM6ICcgKyB4aHIuc3RhdHVzKTtcbiAgICAgICAgaWYgKHhoci5yZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSB8fCBbXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGludEFycmF5RnJvbVN0cmluZyh4aHIucmVzcG9uc2VUZXh0IHx8ICcnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBsYXp5QXJyYXkgPSB0aGlzO1xuICAgICAgbGF6eUFycmF5LnNldERhdGFHZXR0ZXIoZnVuY3Rpb24gKGNodW5rTnVtKSB7XG4gICAgICAgIHZhciBzdGFydCA9IGNodW5rTnVtICogY2h1bmtTaXplO1xuICAgICAgICB2YXIgZW5kID0gKGNodW5rTnVtICsgMSkgKiBjaHVua1NpemUgLSAxO1xuICAgICAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGRhdGFsZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXSA9IGRvWEhSKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV0gPT09ICd1bmRlZmluZWQnKSB0aHJvdyBuZXcgRXJyb3IoJ2RvWEhSIGZhaWxlZCEnKTtcbiAgICAgICAgcmV0dXJuIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dO1xuICAgICAgfSk7XG4gICAgICBpZiAodXNlc0d6aXAgfHwgIWRhdGFsZW5ndGgpIHtcbiAgICAgICAgY2h1bmtTaXplID0gZGF0YWxlbmd0aCA9IDE7XG4gICAgICAgIGRhdGFsZW5ndGggPSB0aGlzLmdldHRlcigwKS5sZW5ndGg7XG4gICAgICAgIGNodW5rU2l6ZSA9IGRhdGFsZW5ndGg7XG4gICAgICAgIG91dCgnTGF6eUZpbGVzIG9uIGd6aXAgZm9yY2VzIGRvd25sb2FkIG9mIHRoZSB3aG9sZSBmaWxlIHdoZW4gbGVuZ3RoIGlzIGFjY2Vzc2VkJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sZW5ndGggPSBkYXRhbGVuZ3RoO1xuICAgICAgdGhpcy5fY2h1bmtTaXplID0gY2h1bmtTaXplO1xuICAgICAgdGhpcy5sZW5ndGhLbm93biA9IHRydWU7XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKCFFTlZJUk9OTUVOVF9JU19XT1JLRVIpXG4gICAgICAgIHRocm93ICdDYW5ub3QgZG8gc3luY2hyb25vdXMgYmluYXJ5IFhIUnMgb3V0c2lkZSB3ZWJ3b3JrZXJzIGluIG1vZGVybiBicm93c2Vycy4gVXNlIC0tZW1iZWQtZmlsZSBvciAtLXByZWxvYWQtZmlsZSBpbiBlbWNjJztcbiAgICAgIHZhciBsYXp5QXJyYXkgPSBuZXcgTGF6eVVpbnQ4QXJyYXkoKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlBcnJheSwge1xuICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sZW5ndGhLbm93bikge1xuICAgICAgICAgICAgICB0aGlzLmNhY2hlTGVuZ3RoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGNodW5rU2l6ZToge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxlbmd0aEtub3duKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2FjaGVMZW5ndGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaHVua1NpemU7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB7IGlzRGV2aWNlOiBmYWxzZSwgY29udGVudHM6IGxhenlBcnJheSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHsgaXNEZXZpY2U6IGZhbHNlLCB1cmw6IHVybCB9O1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZUZpbGUocGFyZW50LCBuYW1lLCBwcm9wZXJ0aWVzLCBjYW5SZWFkLCBjYW5Xcml0ZSk7XG4gICAgaWYgKHByb3BlcnRpZXMuY29udGVudHMpIHtcbiAgICAgIG5vZGUuY29udGVudHMgPSBwcm9wZXJ0aWVzLmNvbnRlbnRzO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydGllcy51cmwpIHtcbiAgICAgIG5vZGUuY29udGVudHMgPSBudWxsO1xuICAgICAgbm9kZS51cmwgPSBwcm9wZXJ0aWVzLnVybDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMobm9kZSwge1xuICAgICAgdXNlZEJ5dGVzOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRzLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgdmFyIHN0cmVhbV9vcHMgPSB7fTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUuc3RyZWFtX29wcyk7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBmbiA9IG5vZGUuc3RyZWFtX29wc1trZXldO1xuICAgICAgc3RyZWFtX29wc1trZXldID0gZnVuY3Rpb24gZm9yY2VMb2FkTGF6eUZpbGUoKSB7XG4gICAgICAgIEZTLmZvcmNlTG9hZEZpbGUobm9kZSk7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBzdHJlYW1fb3BzLnJlYWQgPSBmdW5jdGlvbiBzdHJlYW1fb3BzX3JlYWQoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikge1xuICAgICAgRlMuZm9yY2VMb2FkRmlsZShub2RlKTtcbiAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzO1xuICAgICAgaWYgKHBvc2l0aW9uID49IGNvbnRlbnRzLmxlbmd0aCkgcmV0dXJuIDA7XG4gICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKGNvbnRlbnRzLmxlbmd0aCAtIHBvc2l0aW9uLCBsZW5ndGgpO1xuICAgICAgaWYgKGNvbnRlbnRzLnNsaWNlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgYnVmZmVyW29mZnNldCArIGldID0gY29udGVudHNbcG9zaXRpb24gKyBpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBjb250ZW50cy5nZXQocG9zaXRpb24gKyBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfTtcbiAgICBub2RlLnN0cmVhbV9vcHMgPSBzdHJlYW1fb3BzO1xuICAgIHJldHVybiBub2RlO1xuICB9LFxuICBjcmVhdGVQcmVsb2FkZWRGaWxlOiBmdW5jdGlvbiAoXG4gICAgcGFyZW50LFxuICAgIG5hbWUsXG4gICAgdXJsLFxuICAgIGNhblJlYWQsXG4gICAgY2FuV3JpdGUsXG4gICAgb25sb2FkLFxuICAgIG9uZXJyb3IsXG4gICAgZG9udENyZWF0ZUZpbGUsXG4gICAgY2FuT3duLFxuICAgIHByZUZpbmlzaFxuICApIHtcbiAgICBCcm93c2VyLmluaXQoKTtcbiAgICB2YXIgZnVsbG5hbWUgPSBuYW1lID8gUEFUSF9GUy5yZXNvbHZlKFBBVEguam9pbjIocGFyZW50LCBuYW1lKSkgOiBwYXJlbnQ7XG4gICAgdmFyIGRlcCA9IGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koJ2NwICcgKyBmdWxsbmFtZSk7XG5cbiAgICBmdW5jdGlvbiBwcm9jZXNzRGF0YShieXRlQXJyYXkpIHtcblxuICAgICAgZnVuY3Rpb24gZmluaXNoKGJ5dGVBcnJheSkge1xuICAgICAgICBpZiAocHJlRmluaXNoKSBwcmVGaW5pc2goKTtcbiAgICAgICAgaWYgKCFkb250Q3JlYXRlRmlsZSkge1xuICAgICAgICAgIEZTLmNyZWF0ZURhdGFGaWxlKHBhcmVudCwgbmFtZSwgYnl0ZUFycmF5LCBjYW5SZWFkLCBjYW5Xcml0ZSwgY2FuT3duKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25sb2FkKSBvbmxvYWQoKTtcbiAgICAgICAgcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApO1xuICAgICAgfVxuICAgICAgdmFyIGhhbmRsZWQgPSBmYWxzZTtcbiAgICAgIE1vZHVsZVsncHJlbG9hZFBsdWdpbnMnXS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgICAgaWYgKGhhbmRsZWQpIHJldHVybjtcbiAgICAgICAgaWYgKHBsdWdpblsnY2FuSGFuZGxlJ10oZnVsbG5hbWUpKSB7XG4gICAgICAgICAgcGx1Z2luWydoYW5kbGUnXShieXRlQXJyYXksIGZ1bGxuYW1lLCBmaW5pc2gsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvbmVycm9yKSBvbmVycm9yKCk7XG4gICAgICAgICAgICByZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFoYW5kbGVkKSBmaW5pc2goYnl0ZUFycmF5KTtcbiAgICB9XG4gICAgYWRkUnVuRGVwZW5kZW5jeShkZXApO1xuICAgIGlmICh0eXBlb2YgdXJsID09ICdzdHJpbmcnKSB7XG4gICAgICBhc3luY0xvYWQoXG4gICAgICAgIHVybCxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVBcnJheSkge1xuICAgICAgICAgIHByb2Nlc3NEYXRhKGJ5dGVBcnJheSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uZXJyb3JcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3NEYXRhKHVybCk7XG4gICAgfVxuICB9LFxuICBpbmRleGVkREI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gd2luZG93LmluZGV4ZWREQiB8fCB3aW5kb3cubW96SW5kZXhlZERCIHx8IHdpbmRvdy53ZWJraXRJbmRleGVkREIgfHwgd2luZG93Lm1zSW5kZXhlZERCO1xuICB9LFxuICBEQl9OQU1FOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdFTV9GU18nICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICB9LFxuICBEQl9WRVJTSU9OOiAyMCxcbiAgREJfU1RPUkVfTkFNRTogJ0ZJTEVfREFUQScsXG4gIHNhdmVGaWxlc1RvREI6IGZ1bmN0aW9uIChwYXRocywgb25sb2FkLCBvbmVycm9yKSB7XG4gICAgb25sb2FkID0gb25sb2FkIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgIG9uZXJyb3IgPSBvbmVycm9yIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgIHZhciBpbmRleGVkREIgPSBGUy5pbmRleGVkREIoKTtcbiAgICB0cnkge1xuICAgICAgdmFyIG9wZW5SZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oRlMuREJfTkFNRSgpLCBGUy5EQl9WRVJTSU9OKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gb25lcnJvcihlKTtcbiAgICB9XG4gICAgb3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24gb3BlblJlcXVlc3Rfb251cGdyYWRlbmVlZGVkKCkge1xuICAgICAgb3V0KCdjcmVhdGluZyBkYicpO1xuICAgICAgdmFyIGRiID0gb3BlblJlcXVlc3QucmVzdWx0O1xuICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoRlMuREJfU1RPUkVfTkFNRSk7XG4gICAgfTtcbiAgICBvcGVuUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiBvcGVuUmVxdWVzdF9vbnN1Y2Nlc3MoKSB7XG4gICAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbRlMuREJfU1RPUkVfTkFNRV0sICdyZWFkd3JpdGUnKTtcbiAgICAgIHZhciBmaWxlcyA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKEZTLkRCX1NUT1JFX05BTUUpO1xuICAgICAgdmFyIG9rID0gMCxcbiAgICAgICAgZmFpbCA9IDAsXG4gICAgICAgIHRvdGFsID0gcGF0aHMubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgIGlmIChmYWlsID09IDApIG9ubG9hZCgpO1xuICAgICAgICBlbHNlIG9uZXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHB1dFJlcXVlc3QgPSBmaWxlcy5wdXQoRlMuYW5hbHl6ZVBhdGgocGF0aCkub2JqZWN0LmNvbnRlbnRzLCBwYXRoKTtcbiAgICAgICAgcHV0UmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiBwdXRSZXF1ZXN0X29uc3VjY2VzcygpIHtcbiAgICAgICAgICBvaysrO1xuICAgICAgICAgIGlmIChvayArIGZhaWwgPT0gdG90YWwpIGZpbmlzaCgpO1xuICAgICAgICB9O1xuICAgICAgICBwdXRSZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBwdXRSZXF1ZXN0X29uZXJyb3IoKSB7XG4gICAgICAgICAgZmFpbCsrO1xuICAgICAgICAgIGlmIChvayArIGZhaWwgPT0gdG90YWwpIGZpbmlzaCgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICB0cmFuc2FjdGlvbi5vbmVycm9yID0gb25lcnJvcjtcbiAgICB9O1xuICAgIG9wZW5SZXF1ZXN0Lm9uZXJyb3IgPSBvbmVycm9yO1xuICB9LFxuICBsb2FkRmlsZXNGcm9tREI6IGZ1bmN0aW9uIChwYXRocywgb25sb2FkLCBvbmVycm9yKSB7XG4gICAgb25sb2FkID0gb25sb2FkIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgIG9uZXJyb3IgPSBvbmVycm9yIHx8IGZ1bmN0aW9uICgpIHt9O1xuICAgIHZhciBpbmRleGVkREIgPSBGUy5pbmRleGVkREIoKTtcbiAgICB0cnkge1xuICAgICAgdmFyIG9wZW5SZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oRlMuREJfTkFNRSgpLCBGUy5EQl9WRVJTSU9OKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gb25lcnJvcihlKTtcbiAgICB9XG4gICAgb3BlblJlcXVlc3Qub251cGdyYWRlbmVlZGVkID0gb25lcnJvcjtcbiAgICBvcGVuUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiBvcGVuUmVxdWVzdF9vbnN1Y2Nlc3MoKSB7XG4gICAgICB2YXIgZGIgPSBvcGVuUmVxdWVzdC5yZXN1bHQ7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSBkYi50cmFuc2FjdGlvbihbRlMuREJfU1RPUkVfTkFNRV0sICdyZWFkb25seScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBvbmVycm9yKGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgZmlsZXMgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGUy5EQl9TVE9SRV9OQU1FKTtcbiAgICAgIHZhciBvayA9IDAsXG4gICAgICAgIGZhaWwgPSAwLFxuICAgICAgICB0b3RhbCA9IHBhdGhzLmxlbmd0aDtcblxuICAgICAgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICBpZiAoZmFpbCA9PSAwKSBvbmxvYWQoKTtcbiAgICAgICAgZWxzZSBvbmVycm9yKCk7XG4gICAgICB9XG4gICAgICBwYXRocy5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHZhciBnZXRSZXF1ZXN0ID0gZmlsZXMuZ2V0KHBhdGgpO1xuICAgICAgICBnZXRSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIGdldFJlcXVlc3Rfb25zdWNjZXNzKCkge1xuICAgICAgICAgIGlmIChGUy5hbmFseXplUGF0aChwYXRoKS5leGlzdHMpIHtcbiAgICAgICAgICAgIEZTLnVubGluayhwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgRlMuY3JlYXRlRGF0YUZpbGUoXG4gICAgICAgICAgICBQQVRILmRpcm5hbWUocGF0aCksXG4gICAgICAgICAgICBQQVRILmJhc2VuYW1lKHBhdGgpLFxuICAgICAgICAgICAgZ2V0UmVxdWVzdC5yZXN1bHQsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIHRydWVcbiAgICAgICAgICApO1xuICAgICAgICAgIG9rKys7XG4gICAgICAgICAgaWYgKG9rICsgZmFpbCA9PSB0b3RhbCkgZmluaXNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIGdldFJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGdldFJlcXVlc3Rfb25lcnJvcigpIHtcbiAgICAgICAgICBmYWlsKys7XG4gICAgICAgICAgaWYgKG9rICsgZmFpbCA9PSB0b3RhbCkgZmluaXNoKCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHRyYW5zYWN0aW9uLm9uZXJyb3IgPSBvbmVycm9yO1xuICAgIH07XG4gICAgb3BlblJlcXVlc3Qub25lcnJvciA9IG9uZXJyb3I7XG4gIH0sXG59O1xudmFyIFNZU0NBTExTID0ge1xuICBtYXBwaW5nczoge30sXG4gIERFRkFVTFRfUE9MTE1BU0s6IDUsXG4gIGNhbGN1bGF0ZUF0OiBmdW5jdGlvbiAoZGlyZmQsIHBhdGgsIGFsbG93RW1wdHkpIHtcbiAgICBpZiAocGF0aFswXSA9PT0gJy8nKSB7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgdmFyIGRpcjtcbiAgICBpZiAoZGlyZmQgPT09IC0xMDApIHtcbiAgICAgIGRpciA9IEZTLmN3ZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlyc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGRpcmZkKTtcbiAgICAgIGlmICghZGlyc3RyZWFtKSB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KTtcbiAgICAgIGRpciA9IGRpcnN0cmVhbS5wYXRoO1xuICAgIH1cbiAgICBpZiAocGF0aC5sZW5ndGggPT0gMCkge1xuICAgICAgaWYgKCFhbGxvd0VtcHR5KSB7XG4gICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaXI7XG4gICAgfVxuICAgIHJldHVybiBQQVRILmpvaW4yKGRpciwgcGF0aCk7XG4gIH0sXG4gIGRvU3RhdDogZnVuY3Rpb24gKGZ1bmMsIHBhdGgsIGJ1Zikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgc3RhdCA9IGZ1bmMocGF0aCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgJiYgZS5ub2RlICYmIFBBVEgubm9ybWFsaXplKHBhdGgpICE9PSBQQVRILm5vcm1hbGl6ZShGUy5nZXRQYXRoKGUubm9kZSkpKSB7XG4gICAgICAgIHJldHVybiAtNTQ7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBIRUFQMzJbYnVmID4+IDJdID0gc3RhdC5kZXY7XG4gICAgSEVBUDMyWyhidWYgKyA0KSA+PiAyXSA9IDA7XG4gICAgSEVBUDMyWyhidWYgKyA4KSA+PiAyXSA9IHN0YXQuaW5vO1xuICAgIEhFQVAzMlsoYnVmICsgMTIpID4+IDJdID0gc3RhdC5tb2RlO1xuICAgIEhFQVAzMlsoYnVmICsgMTYpID4+IDJdID0gc3RhdC5ubGluaztcbiAgICBIRUFQMzJbKGJ1ZiArIDIwKSA+PiAyXSA9IHN0YXQudWlkO1xuICAgIEhFQVAzMlsoYnVmICsgMjQpID4+IDJdID0gc3RhdC5naWQ7XG4gICAgSEVBUDMyWyhidWYgKyAyOCkgPj4gMl0gPSBzdGF0LnJkZXY7XG4gICAgSEVBUDMyWyhidWYgKyAzMikgPj4gMl0gPSAwO1xuICAgICh0ZW1wSTY0ID0gW1xuICAgICAgc3RhdC5zaXplID4+PiAwLFxuICAgICAgKCh0ZW1wRG91YmxlID0gc3RhdC5zaXplKSxcbiAgICAgICtNYXRoLmFicyh0ZW1wRG91YmxlKSA+PSAxXG4gICAgICAgID8gdGVtcERvdWJsZSA+IDBcbiAgICAgICAgICA/IChNYXRoLm1pbigrTWF0aC5mbG9vcih0ZW1wRG91YmxlIC8gNDI5NDk2NzI5NiksIDQyOTQ5NjcyOTUpIHwgMCkgPj4+IDBcbiAgICAgICAgICA6IH5+K01hdGguY2VpbCgodGVtcERvdWJsZSAtICsofn50ZW1wRG91YmxlID4+PiAwKSkgLyA0Mjk0OTY3Mjk2KSA+Pj4gMFxuICAgICAgICA6IDApLFxuICAgIF0pLFxuICAgICAgKEhFQVAzMlsoYnVmICsgNDApID4+IDJdID0gdGVtcEk2NFswXSksXG4gICAgICAoSEVBUDMyWyhidWYgKyA0NCkgPj4gMl0gPSB0ZW1wSTY0WzFdKTtcbiAgICBIRUFQMzJbKGJ1ZiArIDQ4KSA+PiAyXSA9IDQwOTY7XG4gICAgSEVBUDMyWyhidWYgKyA1MikgPj4gMl0gPSBzdGF0LmJsb2NrcztcbiAgICBIRUFQMzJbKGJ1ZiArIDU2KSA+PiAyXSA9IChzdGF0LmF0aW1lLmdldFRpbWUoKSAvIDFlMykgfCAwO1xuICAgIEhFQVAzMlsoYnVmICsgNjApID4+IDJdID0gMDtcbiAgICBIRUFQMzJbKGJ1ZiArIDY0KSA+PiAyXSA9IChzdGF0Lm10aW1lLmdldFRpbWUoKSAvIDFlMykgfCAwO1xuICAgIEhFQVAzMlsoYnVmICsgNjgpID4+IDJdID0gMDtcbiAgICBIRUFQMzJbKGJ1ZiArIDcyKSA+PiAyXSA9IChzdGF0LmN0aW1lLmdldFRpbWUoKSAvIDFlMykgfCAwO1xuICAgIEhFQVAzMlsoYnVmICsgNzYpID4+IDJdID0gMDtcbiAgICAodGVtcEk2NCA9IFtcbiAgICAgIHN0YXQuaW5vID4+PiAwLFxuICAgICAgKCh0ZW1wRG91YmxlID0gc3RhdC5pbm8pLFxuICAgICAgK01hdGguYWJzKHRlbXBEb3VibGUpID49IDFcbiAgICAgICAgPyB0ZW1wRG91YmxlID4gMFxuICAgICAgICAgID8gKE1hdGgubWluKCtNYXRoLmZsb29yKHRlbXBEb3VibGUgLyA0Mjk0OTY3Mjk2KSwgNDI5NDk2NzI5NSkgfCAwKSA+Pj4gMFxuICAgICAgICAgIDogfn4rTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKyh+fnRlbXBEb3VibGUgPj4+IDApKSAvIDQyOTQ5NjcyOTYpID4+PiAwXG4gICAgICAgIDogMCksXG4gICAgXSksXG4gICAgICAoSEVBUDMyWyhidWYgKyA4MCkgPj4gMl0gPSB0ZW1wSTY0WzBdKSxcbiAgICAgIChIRUFQMzJbKGJ1ZiArIDg0KSA+PiAyXSA9IHRlbXBJNjRbMV0pO1xuICAgIHJldHVybiAwO1xuICB9LFxuICBkb01zeW5jOiBmdW5jdGlvbiAoYWRkciwgc3RyZWFtLCBsZW4sIGZsYWdzLCBvZmZzZXQpIHtcbiAgICB2YXIgYnVmZmVyID0gSEVBUFU4LnNsaWNlKGFkZHIsIGFkZHIgKyBsZW4pO1xuICAgIEZTLm1zeW5jKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbiwgZmxhZ3MpO1xuICB9LFxuICBkb01rZGlyOiBmdW5jdGlvbiAocGF0aCwgbW9kZSkge1xuICAgIHBhdGggPSBQQVRILm5vcm1hbGl6ZShwYXRoKTtcbiAgICBpZiAocGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnLycpIHBhdGggPSBwYXRoLnN1YnN0cigwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICAgIEZTLm1rZGlyKHBhdGgsIG1vZGUsIDApO1xuICAgIHJldHVybiAwO1xuICB9LFxuICBkb01rbm9kOiBmdW5jdGlvbiAocGF0aCwgbW9kZSwgZGV2KSB7XG4gICAgc3dpdGNoIChtb2RlICYgNjE0NDApIHtcbiAgICAgIGNhc2UgMzI3Njg6XG4gICAgICBjYXNlIDgxOTI6XG4gICAgICBjYXNlIDI0NTc2OlxuICAgICAgY2FzZSA0MDk2OlxuICAgICAgY2FzZSA0OTE1MjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gLTI4O1xuICAgIH1cbiAgICBGUy5ta25vZChwYXRoLCBtb2RlLCBkZXYpO1xuICAgIHJldHVybiAwO1xuICB9LFxuICBkb1JlYWRsaW5rOiBmdW5jdGlvbiAocGF0aCwgYnVmLCBidWZzaXplKSB7XG4gICAgaWYgKGJ1ZnNpemUgPD0gMCkgcmV0dXJuIC0yODtcbiAgICB2YXIgcmV0ID0gRlMucmVhZGxpbmsocGF0aCk7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGJ1ZnNpemUsIGxlbmd0aEJ5dGVzVVRGOChyZXQpKTtcbiAgICB2YXIgZW5kQ2hhciA9IEhFQVA4W2J1ZiArIGxlbl07XG4gICAgc3RyaW5nVG9VVEY4KHJldCwgYnVmLCBidWZzaXplICsgMSk7XG4gICAgSEVBUDhbYnVmICsgbGVuXSA9IGVuZENoYXI7XG4gICAgcmV0dXJuIGxlbjtcbiAgfSxcbiAgZG9BY2Nlc3M6IGZ1bmN0aW9uIChwYXRoLCBhbW9kZSkge1xuICAgIGlmIChhbW9kZSAmIH43KSB7XG4gICAgICByZXR1cm4gLTI4O1xuICAgIH1cbiAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTtcbiAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuIC00NDtcbiAgICB9XG4gICAgdmFyIHBlcm1zID0gJyc7XG4gICAgaWYgKGFtb2RlICYgNCkgcGVybXMgKz0gJ3InO1xuICAgIGlmIChhbW9kZSAmIDIpIHBlcm1zICs9ICd3JztcbiAgICBpZiAoYW1vZGUgJiAxKSBwZXJtcyArPSAneCc7XG4gICAgaWYgKHBlcm1zICYmIEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCBwZXJtcykpIHtcbiAgICAgIHJldHVybiAtMjtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGRvRHVwOiBmdW5jdGlvbiAocGF0aCwgZmxhZ3MsIHN1Z2dlc3RGRCkge1xuICAgIHZhciBzdWdnZXN0ID0gRlMuZ2V0U3RyZWFtKHN1Z2dlc3RGRCk7XG4gICAgaWYgKHN1Z2dlc3QpIEZTLmNsb3NlKHN1Z2dlc3QpO1xuICAgIHJldHVybiBGUy5vcGVuKHBhdGgsIGZsYWdzLCAwLCBzdWdnZXN0RkQsIHN1Z2dlc3RGRCkuZmQ7XG4gIH0sXG4gIGRvUmVhZHY6IGZ1bmN0aW9uIChzdHJlYW0sIGlvdiwgaW92Y250LCBvZmZzZXQpIHtcbiAgICB2YXIgcmV0ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7XG4gICAgICB2YXIgcHRyID0gSEVBUDMyWyhpb3YgKyBpICogOCkgPj4gMl07XG4gICAgICB2YXIgbGVuID0gSEVBUDMyWyhpb3YgKyAoaSAqIDggKyA0KSkgPj4gMl07XG4gICAgICB2YXIgY3VyciA9IEZTLnJlYWQoc3RyZWFtLCBIRUFQOCwgcHRyLCBsZW4sIG9mZnNldCk7XG4gICAgICBpZiAoY3VyciA8IDApIHJldHVybiAtMTtcbiAgICAgIHJldCArPSBjdXJyO1xuICAgICAgaWYgKGN1cnIgPCBsZW4pIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICBkb1dyaXRldjogZnVuY3Rpb24gKHN0cmVhbSwgaW92LCBpb3ZjbnQsIG9mZnNldCkge1xuICAgIHZhciByZXQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW92Y250OyBpKyspIHtcbiAgICAgIHZhciBwdHIgPSBIRUFQMzJbKGlvdiArIGkgKiA4KSA+PiAyXTtcbiAgICAgIHZhciBsZW4gPSBIRUFQMzJbKGlvdiArIChpICogOCArIDQpKSA+PiAyXTtcbiAgICAgIHZhciBjdXJyID0gRlMud3JpdGUoc3RyZWFtLCBIRUFQOCwgcHRyLCBsZW4sIG9mZnNldCk7XG4gICAgICBpZiAoY3VyciA8IDApIHJldHVybiAtMTtcbiAgICAgIHJldCArPSBjdXJyO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuICB2YXJhcmdzOiB1bmRlZmluZWQsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIFNZU0NBTExTLnZhcmFyZ3MgKz0gNDtcbiAgICB2YXIgcmV0ID0gSEVBUDMyWyhTWVNDQUxMUy52YXJhcmdzIC0gNCkgPj4gMl07XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgZ2V0U3RyOiBmdW5jdGlvbiAocHRyKSB7XG4gICAgdmFyIHJldCA9IFVURjhUb1N0cmluZyhwdHIpO1xuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIGdldFN0cmVhbUZyb21GRDogZnVuY3Rpb24gKGZkKSB7XG4gICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbShmZCk7XG4gICAgaWYgKCFzdHJlYW0pIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH0sXG4gIGdldDY0OiBmdW5jdGlvbiAobG93LCBoaWdoKSB7XG4gICAgcmV0dXJuIGxvdztcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIF9mZF9jbG9zZShmZCkge1xuICB0cnkge1xuICAgIHZhciBzdHJlYW0gPSBTWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO1xuICAgIEZTLmNsb3NlKHN0cmVhbSk7XG4gICAgcmV0dXJuIDA7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gZS5lcnJubztcbiAgfVxufVxuXG5mdW5jdGlvbiBfZmRfcmVhZChmZCwgaW92LCBpb3ZjbnQsIHBudW0pIHtcbiAgdHJ5IHtcbiAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICB2YXIgbnVtID0gU1lTQ0FMTFMuZG9SZWFkdihzdHJlYW0sIGlvdiwgaW92Y250KTtcbiAgICBIRUFQMzJbcG51bSA+PiAyXSA9IG51bTtcbiAgICByZXR1cm4gMDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSB0aHJvdyBlO1xuICAgIHJldHVybiBlLmVycm5vO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9mZF9zZWVrKGZkLCBvZmZzZXRfbG93LCBvZmZzZXRfaGlnaCwgd2hlbmNlLCBuZXdPZmZzZXQpIHtcbiAgdHJ5IHtcbiAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtcbiAgICB2YXIgSElHSF9PRkZTRVQgPSA0Mjk0OTY3Mjk2O1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXRfaGlnaCAqIEhJR0hfT0ZGU0VUICsgKG9mZnNldF9sb3cgPj4+IDApO1xuICAgIHZhciBET1VCTEVfTElNSVQgPSA5MDA3MTk5MjU0NzQwOTkyO1xuICAgIGlmIChvZmZzZXQgPD0gLURPVUJMRV9MSU1JVCB8fCBvZmZzZXQgPj0gRE9VQkxFX0xJTUlUKSB7XG4gICAgICByZXR1cm4gLTYxO1xuICAgIH1cbiAgICBGUy5sbHNlZWsoc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSk7XG4gICAgKHRlbXBJNjQgPSBbXG4gICAgICBzdHJlYW0ucG9zaXRpb24gPj4+IDAsXG4gICAgICAoKHRlbXBEb3VibGUgPSBzdHJlYW0ucG9zaXRpb24pLFxuICAgICAgK01hdGguYWJzKHRlbXBEb3VibGUpID49IDFcbiAgICAgICAgPyB0ZW1wRG91YmxlID4gMFxuICAgICAgICAgID8gKE1hdGgubWluKCtNYXRoLmZsb29yKHRlbXBEb3VibGUgLyA0Mjk0OTY3Mjk2KSwgNDI5NDk2NzI5NSkgfCAwKSA+Pj4gMFxuICAgICAgICAgIDogfn4rTWF0aC5jZWlsKCh0ZW1wRG91YmxlIC0gKyh+fnRlbXBEb3VibGUgPj4+IDApKSAvIDQyOTQ5NjcyOTYpID4+PiAwXG4gICAgICAgIDogMCksXG4gICAgXSksXG4gICAgICAoSEVBUDMyW25ld09mZnNldCA+PiAyXSA9IHRlbXBJNjRbMF0pLFxuICAgICAgKEhFQVAzMlsobmV3T2Zmc2V0ICsgNCkgPj4gMl0gPSB0ZW1wSTY0WzFdKTtcbiAgICBpZiAoc3RyZWFtLmdldGRlbnRzICYmIG9mZnNldCA9PT0gMCAmJiB3aGVuY2UgPT09IDApIHN0cmVhbS5nZXRkZW50cyA9IG51bGw7XG4gICAgcmV0dXJuIDA7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAodHlwZW9mIEZTID09PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZTtcbiAgICByZXR1cm4gZS5lcnJubztcbiAgfVxufVxuXG5mdW5jdGlvbiBfZmRfd3JpdGUoZmQsIGlvdiwgaW92Y250LCBwbnVtKSB7XG4gIHRyeSB7XG4gICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7XG4gICAgdmFyIG51bSA9IFNZU0NBTExTLmRvV3JpdGV2KHN0cmVhbSwgaW92LCBpb3ZjbnQpO1xuICAgIEhFQVAzMltwbnVtID4+IDJdID0gbnVtO1xuICAgIHJldHVybiAwO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKHR5cGVvZiBGUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIHRocm93IGU7XG4gICAgcmV0dXJuIGUuZXJybm87XG4gIH1cbn1cblxuZnVuY3Rpb24gX3Byb2NfZXhpdChjb2RlKSB7XG4gIHByb2NFeGl0KGNvZGUpO1xufVxudmFyIEZTTm9kZSA9IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUsIG1vZGUsIHJkZXYpIHtcbiAgaWYgKCFwYXJlbnQpIHtcbiAgICBwYXJlbnQgPSB0aGlzO1xuICB9XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLm1vdW50ID0gcGFyZW50Lm1vdW50O1xuICB0aGlzLm1vdW50ZWQgPSBudWxsO1xuICB0aGlzLmlkID0gRlMubmV4dElub2RlKys7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMubW9kZSA9IG1vZGU7XG4gIHRoaXMubm9kZV9vcHMgPSB7fTtcbiAgdGhpcy5zdHJlYW1fb3BzID0ge307XG4gIHRoaXMucmRldiA9IHJkZXY7XG59O1xudmFyIHJlYWRNb2RlID0gMjkyIHwgNzM7XG52YXIgd3JpdGVNb2RlID0gMTQ2O1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRlNOb2RlLnByb3RvdHlwZSwge1xuICByZWFkOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubW9kZSAmIHJlYWRNb2RlKSA9PT0gcmVhZE1vZGU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHZhbCA/ICh0aGlzLm1vZGUgfD0gcmVhZE1vZGUpIDogKHRoaXMubW9kZSAmPSB+cmVhZE1vZGUpO1xuICAgIH0sXG4gIH0sXG4gIHdyaXRlOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKHRoaXMubW9kZSAmIHdyaXRlTW9kZSkgPT09IHdyaXRlTW9kZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdmFsID8gKHRoaXMubW9kZSB8PSB3cml0ZU1vZGUpIDogKHRoaXMubW9kZSAmPSB+d3JpdGVNb2RlKTtcbiAgICB9LFxuICB9LFxuICBpc0ZvbGRlcjoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEZTLmlzRGlyKHRoaXMubW9kZSk7XG4gICAgfSxcbiAgfSxcbiAgaXNEZXZpY2U6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBGUy5pc0NocmRldih0aGlzLm1vZGUpO1xuICAgIH0sXG4gIH0sXG59KTtcbkZTLkZTTm9kZSA9IEZTTm9kZTtcbkZTLnN0YXRpY0luaXQoKTtcblxuZnVuY3Rpb24gaW50QXJyYXlGcm9tU3RyaW5nKHN0cmluZ3ksIGRvbnRBZGROdWxsLCBsZW5ndGgpIHtcbiAgdmFyIGxlbiA9IGxlbmd0aCA+IDAgPyBsZW5ndGggOiBsZW5ndGhCeXRlc1VURjgoc3RyaW5neSkgKyAxO1xuICB2YXIgdThhcnJheSA9IG5ldyBBcnJheShsZW4pO1xuICB2YXIgbnVtQnl0ZXNXcml0dGVuID0gc3RyaW5nVG9VVEY4QXJyYXkoc3RyaW5neSwgdThhcnJheSwgMCwgdThhcnJheS5sZW5ndGgpO1xuICBpZiAoZG9udEFkZE51bGwpIHU4YXJyYXkubGVuZ3RoID0gbnVtQnl0ZXNXcml0dGVuO1xuICByZXR1cm4gdThhcnJheTtcbn1cbnZhciBhc21MaWJyYXJ5QXJnID0ge1xuICBmZF9jbG9zZTogX2ZkX2Nsb3NlLFxuICBmZF9yZWFkOiBfZmRfcmVhZCxcbiAgZmRfc2VlazogX2ZkX3NlZWssXG4gIGZkX3dyaXRlOiBfZmRfd3JpdGUsXG4gIHByb2NfZXhpdDogX3Byb2NfZXhpdCxcbn07XG52YXIgYXNtID0gY3JlYXRlV2FzbSgpO1xudmFyIF9TY2hub3JyUV9LZXlHZW5lcmF0aW9uID0gKE1vZHVsZVsnX1NjaG5vcnJRX0tleUdlbmVyYXRpb24nXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIChfU2Nobm9yclFfS2V5R2VuZXJhdGlvbiA9IE1vZHVsZVsnX1NjaG5vcnJRX0tleUdlbmVyYXRpb24nXSA9XG4gICAgTW9kdWxlWydhc20nXVsnU2Nobm9yclFfS2V5R2VuZXJhdGlvbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufSk7XG52YXIgX0thbmdhcm9vVHdlbHZlID0gKE1vZHVsZVsnX0thbmdhcm9vVHdlbHZlJ10gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoX0thbmdhcm9vVHdlbHZlID0gTW9kdWxlWydfS2FuZ2Fyb29Ud2VsdmUnXSA9IE1vZHVsZVsnYXNtJ11bJ0thbmdhcm9vVHdlbHZlJ10pLmFwcGx5KFxuICAgIG51bGwsXG4gICAgYXJndW1lbnRzXG4gICk7XG59KTtcbnZhciBfU2Nobm9yclFfU2lnbiA9IChNb2R1bGVbJ19TY2hub3JyUV9TaWduJ10gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoX1NjaG5vcnJRX1NpZ24gPSBNb2R1bGVbJ19TY2hub3JyUV9TaWduJ10gPSBNb2R1bGVbJ2FzbSddWydTY2hub3JyUV9TaWduJ10pLmFwcGx5KFxuICAgIG51bGwsXG4gICAgYXJndW1lbnRzXG4gICk7XG59KTtcbnZhciBfZnJlZSA9IChNb2R1bGVbJ19mcmVlJ10gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoX2ZyZWUgPSBNb2R1bGVbJ19mcmVlJ10gPSBNb2R1bGVbJ2FzbSddWydmcmVlJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59KTtcbnZhciBfU2Nobm9yclFfVmVyaWZ5ID0gKE1vZHVsZVsnX1NjaG5vcnJRX1ZlcmlmeSddID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKF9TY2hub3JyUV9WZXJpZnkgPSBNb2R1bGVbJ19TY2hub3JyUV9WZXJpZnknXSA9IE1vZHVsZVsnYXNtJ11bJ1NjaG5vcnJRX1ZlcmlmeSddKS5hcHBseShcbiAgICBudWxsLFxuICAgIGFyZ3VtZW50c1xuICApO1xufSk7XG52YXIgX0NvbXByZXNzZWRQdWJsaWNLZXlHZW5lcmF0aW9uID0gKE1vZHVsZVsnX0NvbXByZXNzZWRQdWJsaWNLZXlHZW5lcmF0aW9uJ10gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoX0NvbXByZXNzZWRQdWJsaWNLZXlHZW5lcmF0aW9uID0gTW9kdWxlWydfQ29tcHJlc3NlZFB1YmxpY0tleUdlbmVyYXRpb24nXSA9XG4gICAgTW9kdWxlWydhc20nXVsnQ29tcHJlc3NlZFB1YmxpY0tleUdlbmVyYXRpb24nXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn0pO1xudmFyIF9Db21wcmVzc2VkS2V5R2VuZXJhdGlvbiA9IChNb2R1bGVbJ19Db21wcmVzc2VkS2V5R2VuZXJhdGlvbiddID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKF9Db21wcmVzc2VkS2V5R2VuZXJhdGlvbiA9IE1vZHVsZVsnX0NvbXByZXNzZWRLZXlHZW5lcmF0aW9uJ10gPVxuICAgIE1vZHVsZVsnYXNtJ11bJ0NvbXByZXNzZWRLZXlHZW5lcmF0aW9uJ10pLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59KTtcbnZhciBfQ29tcHJlc3NlZFNlY3JldEFncmVlbWVudCA9IChNb2R1bGVbJ19Db21wcmVzc2VkU2VjcmV0QWdyZWVtZW50J10gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoX0NvbXByZXNzZWRTZWNyZXRBZ3JlZW1lbnQgPSBNb2R1bGVbJ19Db21wcmVzc2VkU2VjcmV0QWdyZWVtZW50J10gPVxuICAgIE1vZHVsZVsnYXNtJ11bJ0NvbXByZXNzZWRTZWNyZXRBZ3JlZW1lbnQnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn0pO1xudmFyIF9QdWJsaWNLZXlHZW5lcmF0aW9uID0gKE1vZHVsZVsnX1B1YmxpY0tleUdlbmVyYXRpb24nXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIChfUHVibGljS2V5R2VuZXJhdGlvbiA9IE1vZHVsZVsnX1B1YmxpY0tleUdlbmVyYXRpb24nXSA9XG4gICAgTW9kdWxlWydhc20nXVsnUHVibGljS2V5R2VuZXJhdGlvbiddKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufSk7XG52YXIgX0tleUdlbmVyYXRpb24gPSAoTW9kdWxlWydfS2V5R2VuZXJhdGlvbiddID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKF9LZXlHZW5lcmF0aW9uID0gTW9kdWxlWydfS2V5R2VuZXJhdGlvbiddID0gTW9kdWxlWydhc20nXVsnS2V5R2VuZXJhdGlvbiddKS5hcHBseShcbiAgICBudWxsLFxuICAgIGFyZ3VtZW50c1xuICApO1xufSk7XG52YXIgX1NlY3JldEFncmVlbWVudCA9IChNb2R1bGVbJ19TZWNyZXRBZ3JlZW1lbnQnXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIChfU2VjcmV0QWdyZWVtZW50ID0gTW9kdWxlWydfU2VjcmV0QWdyZWVtZW50J10gPSBNb2R1bGVbJ2FzbSddWydTZWNyZXRBZ3JlZW1lbnQnXSkuYXBwbHkoXG4gICAgbnVsbCxcbiAgICBhcmd1bWVudHNcbiAgKTtcbn0pO1xudmFyIF9faW5pdGlhbGl6ZSA9IChNb2R1bGVbJ19faW5pdGlhbGl6ZSddID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKF9faW5pdGlhbGl6ZSA9IE1vZHVsZVsnX19pbml0aWFsaXplJ10gPSBNb2R1bGVbJ2FzbSddWydfaW5pdGlhbGl6ZSddKS5hcHBseShcbiAgICBudWxsLFxuICAgIGFyZ3VtZW50c1xuICApO1xufSk7XG52YXIgX21hbGxvYyA9IChNb2R1bGVbJ19tYWxsb2MnXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIChfbWFsbG9jID0gTW9kdWxlWydfbWFsbG9jJ10gPSBNb2R1bGVbJ2FzbSddWydtYWxsb2MnXSkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn0pO1xudmFyIGNhbGxlZFJ1bjtcblxuZnVuY3Rpb24gRXhpdFN0YXR1cyhzdGF0dXMpIHtcbiAgdGhpcy5uYW1lID0gJ0V4aXRTdGF0dXMnO1xuICB0aGlzLm1lc3NhZ2UgPSAnUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgnICsgc3RhdHVzICsgJyknO1xuICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbn1cbnZhciBjYWxsZWRNYWluID0gZmFsc2U7XG52YXIgbWFpbkFyZ3MgPSB1bmRlZmluZWQ7XG5kZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBmdW5jdGlvbiBydW5DYWxsZXIoKSB7XG4gIGlmICghY2FsbGVkUnVuKSBydW4oKTtcbiAgaWYgKCFjYWxsZWRSdW4pIGRlcGVuZGVuY2llc0Z1bGZpbGxlZCA9IHJ1bkNhbGxlcjtcbn07XG5cbmZ1bmN0aW9uIGNhbGxNYWluKGFyZ3MpIHtcbiAgdmFyIGVudHJ5RnVuY3Rpb24gPSBNb2R1bGVbJ19faW5pdGlhbGl6ZSddO1xuICBtYWluQXJncyA9IFt0aGlzUHJvZ3JhbV0uY29uY2F0KGFyZ3MpO1xuICB0cnkge1xuICAgIGVudHJ5RnVuY3Rpb24oKTtcbiAgICB2YXIgcmV0ID0gMDtcbiAgICBleGl0KHJldCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBoYW5kbGVFeGNlcHRpb24oZSk7XG4gIH0gZmluYWxseSB7XG4gICAgY2FsbGVkTWFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcnVuKGFyZ3MpIHtcbiAgYXJncyA9IGFyZ3MgfHwgYXJndW1lbnRzXztcbiAgaWYgKHJ1bkRlcGVuZGVuY2llcyA+IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJlUnVuKCk7XG4gIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZnVuY3Rpb24gZG9SdW4oKSB7XG4gICAgaWYgKGNhbGxlZFJ1bikgcmV0dXJuO1xuICAgIGNhbGxlZFJ1biA9IHRydWU7XG4gICAgTW9kdWxlWydjYWxsZWRSdW4nXSA9IHRydWU7XG4gICAgaWYgKEFCT1JUKSByZXR1cm47XG4gICAgaW5pdFJ1bnRpbWUoKTtcbiAgICBwcmVNYWluKCk7XG4gICAgaWYgKE1vZHVsZVsnb25SdW50aW1lSW5pdGlhbGl6ZWQnXSkgTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddKCk7XG4gICAgaWYgKHNob3VsZFJ1bk5vdykgY2FsbE1haW4oYXJncyk7XG4gICAgcG9zdFJ1bigpO1xuICB9XG4gIGlmIChNb2R1bGVbJ3NldFN0YXR1cyddKSB7XG4gICAgTW9kdWxlWydzZXRTdGF0dXMnXSgnUnVubmluZy4uLicpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIE1vZHVsZVsnc2V0U3RhdHVzJ10oJycpO1xuICAgICAgfSwgMSk7XG4gICAgICBkb1J1bigpO1xuICAgIH0sIDEpO1xuICB9IGVsc2Uge1xuICAgIGRvUnVuKCk7XG4gIH1cbn1cbk1vZHVsZVsncnVuJ10gPSBydW47XG5cbmZ1bmN0aW9uIGV4aXQoc3RhdHVzLCBpbXBsaWNpdCkge1xuICBFWElUU1RBVFVTID0gc3RhdHVzO1xuICBpZiAoa2VlcFJ1bnRpbWVBbGl2ZSgpKSB7XG4gIH0gZWxzZSB7XG4gICAgZXhpdFJ1bnRpbWUoKTtcbiAgfVxuICBwcm9jRXhpdChzdGF0dXMpO1xufVxuXG5mdW5jdGlvbiBwcm9jRXhpdChjb2RlKSB7XG4gIEVYSVRTVEFUVVMgPSBjb2RlO1xuICBpZiAoIWtlZXBSdW50aW1lQWxpdmUoKSkge1xuICAgIGlmIChNb2R1bGVbJ29uRXhpdCddKSBNb2R1bGVbJ29uRXhpdCddKGNvZGUpO1xuICAgIEFCT1JUID0gdHJ1ZTtcbiAgfVxuICBxdWl0Xyhjb2RlLCBuZXcgRXhpdFN0YXR1cyhjb2RlKSk7XG59XG5pZiAoTW9kdWxlWydwcmVJbml0J10pIHtcbiAgaWYgKHR5cGVvZiBNb2R1bGVbJ3ByZUluaXQnXSA9PSAnZnVuY3Rpb24nKSBNb2R1bGVbJ3ByZUluaXQnXSA9IFtNb2R1bGVbJ3ByZUluaXQnXV07XG4gIHdoaWxlIChNb2R1bGVbJ3ByZUluaXQnXS5sZW5ndGggPiAwKSB7XG4gICAgTW9kdWxlWydwcmVJbml0J10ucG9wKCkoKTtcbiAgfVxufVxudmFyIHNob3VsZFJ1bk5vdyA9IHRydWU7XG5pZiAoTW9kdWxlWydub0luaXRpYWxSdW4nXSkgc2hvdWxkUnVuTm93ID0gZmFsc2U7XG5ydW4oKTtcblxuZXhwb3J0IGRlZmF1bHQgTW9kdWxlOyIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL3NyYy9pbmRleC50c1wiKTtcbiIsIiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==